<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frdqy的博客</title>
  
  <subtitle>记录默默到无闻的学习路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-12T06:32:03.661Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Frdqy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis(2)-数据类型和常用命令</title>
    <link href="http://yoursite.com/2020/02/12/Redis-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/12/Redis-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-12T06:31:28.000Z</published>
    <updated>2020-02-12T06:32:03.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>redis中存储的是KV键值对，其中key是一个对象，其内存储与value类型有关。</p><p>value是有类型的值，包括string、hash、list、set等。</p><a id="more"></a><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查key对应值的数据类型</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">type</span></span><br><span class="line">TYPE key</span><br></pre></td></tr></table></figure><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取redis对象的信息</span></span><br><span class="line"><span class="built_in">help</span> object</span><br><span class="line">OBJECT subcommand [arguments [arguments ...]]</span><br><span class="line">[subcommand]</span><br><span class="line">encoding：查看key对应value的编码格式</span><br></pre></td></tr></table></figure><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#情空所有key</span></span><br><span class="line"><span class="built_in">help</span> flushall</span><br><span class="line">FLUSHALL [ASYNC]</span><br></pre></td></tr></table></figure><h4 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清空当前db的所有key</span></span><br><span class="line"><span class="built_in">help</span> flushdb</span><br><span class="line">FLUSHDB [ASYNC]</span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取匹配pattern的所有key</span></span><br><span class="line"><span class="built_in">help</span> keys</span><br><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换数据库</span></span><br><span class="line"><span class="built_in">help</span> select</span><br><span class="line">SELECT INDEX</span><br></pre></td></tr></table></figure><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重命名key</span></span><br><span class="line"><span class="built_in">help</span> rename</span><br><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure><h4 id="ttl"><a href="#ttl" class="headerlink" title="ttl"></a>ttl</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以秒为单位返回指定key剩余生存时间</span></span><br><span class="line"><span class="built_in">help</span> ttl</span><br><span class="line">TTL key</span><br></pre></td></tr></table></figure><h4 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给指定key设置生存时间</span></span><br><span class="line"><span class="built_in">help</span> expire</span><br><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><h4 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除指定key的生存时间</span></span><br><span class="line"><span class="built_in">help</span> persist</span><br><span class="line">PERSIST key</span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除给定的key</span></span><br><span class="line"><span class="built_in">help</span> del</span><br><span class="line">DEL key [key ...]</span><br></pre></td></tr></table></figure><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">help</span> exists</span><br><span class="line">EXISTS key [key ...]</span><br></pre></td></tr></table></figure><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前数据库的指定key转移到指定数据库中</span></span><br><span class="line"><span class="built_in">help</span> move</span><br><span class="line">MOVE key db</span><br></pre></td></tr></table></figure><h4 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从当前数据库随机返回一个key，不删除</span></span><br><span class="line"><span class="built_in">help</span> randomkey</span><br><span class="line">RANDOMKEY -</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string数据类型具体编码格式分为字符串、bitmap、数值。它是二进制安全的，即redis与socket交互时使用的是字节流而不是字符流。因为不同编程语言对字符流的理解不同(长度等)，可能会出现截断溢出等，而字节流只需要收发双发能够编码与解码即可。</p><p>value为String类型的key，key中存储有type、encoding、length等对应value的属性，存储type是为了快速判断对value的操作是否合法，length等属性也是为了加速操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看string类型所有操作，本篇文章所有操作都在redis-cli中运行</span></span><br><span class="line"><span class="built_in">help</span> @string</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置key和value</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">set</span></span><br><span class="line">SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">NX：键存在时不能操作，类似于新建</span><br><span class="line">XX：键存在时才能操作，类似于更新</span><br></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取对应key的value</span></span><br><span class="line"><span class="built_in">help</span> get</span><br><span class="line">GET key</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">value不存在时返回nil</span><br><span class="line">key存储的不是字符串时返回错误，get只能获取字符串</span><br></pre></td></tr></table></figure><h5 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时设置多个key的value</span></span><br><span class="line"><span class="built_in">help</span> mset</span><br><span class="line">MSET key value [key value ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">mset是一个原子操作，不存在部分更新</span><br></pre></td></tr></table></figure><h5 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时获取多个key的value</span></span><br><span class="line"><span class="built_in">help</span> mget</span><br><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure><h5 id="msetnx"><a href="#msetnx" class="headerlink" title="msetnx"></a>msetnx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key存在时更新，原子操作</span></span><br><span class="line"><span class="built_in">help</span> msetnx</span><br><span class="line">MSETNX key value [key value ...]</span><br></pre></td></tr></table></figure><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#追加字符串</span></span><br><span class="line"><span class="built_in">help</span> append</span><br><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><h5 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定范围的字符串</span></span><br><span class="line"><span class="built_in">help</span> getrange</span><br><span class="line">GETRANGE key [start end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">给定字符串例如<span class="string">"Hello"</span>，它存在正向索引和反向索引。正向索引是从左到右0、1...反向索引是从右到左-1、-2...</span><br></pre></td></tr></table></figure><h5 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置某个范围的值</span></span><br><span class="line"><span class="built_in">help</span> setrange</span><br><span class="line">SETRANGE key offset value</span><br></pre></td></tr></table></figure><h5 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取字符串长度，包括空格</span></span><br><span class="line"><span class="built_in">help</span> strlen</span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><h5 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改key值为给出的value，并返回旧的value值，可以减少依次网络io</span></span><br><span class="line"><span class="built_in">help</span> getset</span><br><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><h5 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key值加1</span></span><br><span class="line"><span class="built_in">help</span> incr</span><br><span class="line">INCR key</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">key不存在时初始为0后加1</span><br><span class="line">范围为64位有符号数</span><br></pre></td></tr></table></figure><h5 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key值减1</span></span><br><span class="line"><span class="built_in">help</span> decr</span><br><span class="line">DECR key</span><br></pre></td></tr></table></figure><h5 id="incrby"><a href="#incrby" class="headerlink" title="incrby"></a>incrby</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加指定数值</span></span><br><span class="line"><span class="built_in">help</span> incrby</span><br><span class="line">INCRBY key increment</span><br></pre></td></tr></table></figure><h5 id="decrby"><a href="#decrby" class="headerlink" title="decrby"></a>decrby</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#减少指定数值</span></span><br><span class="line"><span class="built_in">help</span> decrby</span><br><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><h5 id="incrbyfloat"><a href="#incrbyfloat" class="headerlink" title="incrbyfloat"></a>incrbyfloat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加浮点数</span></span><br><span class="line"><span class="built_in">help</span> incrbyfloat</span><br><span class="line">INCRBYFLOAT key increment</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">increment为正表示增加</span><br><span class="line">increment为负表示减少</span><br></pre></td></tr></table></figure><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><h5 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置对应二进制偏移的值</span></span><br><span class="line"><span class="built_in">help</span> setbit</span><br><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><h5 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找bit第一次出现的位置</span></span><br><span class="line"><span class="built_in">help</span> bitpos</span><br><span class="line">BITPOS key bit [start] [end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">[start]和[end]表示字符序号，返回值为出现给定bit的字节序号</span><br></pre></td></tr></table></figure><h5 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计指定bit出现次数</span></span><br><span class="line"><span class="built_in">help</span> bitcount</span><br><span class="line">BITCOUNT key [start end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">[start]和[end]表示字符序号</span><br></pre></td></tr></table></figure><h5 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位操作</span></span><br><span class="line"><span class="built_in">help</span> bitop</span><br><span class="line">BITOP operation destkey key [key ...]</span><br><span class="line">and：与操作</span><br><span class="line">or：或操作</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>list类型的value对应的key对象存储着value链表的head和tail指针，key也存储value类型type为list。</p><p>list可以实现栈、队列、数组、阻塞单播队列</p><h4 id="lpush"><a href="#lpush" class="headerlink" title="lpush"></a>lpush</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从链表左端放入值</span></span><br><span class="line"><span class="built_in">help</span> lpush</span><br><span class="line">LPUSH key value [value ...]</span><br></pre></td></tr></table></figure><h4 id="rpush"><a href="#rpush" class="headerlink" title="rpush"></a>rpush</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从链表右边放入值</span></span><br><span class="line"><span class="built_in">help</span> rpush</span><br><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure><h4 id="lpop"><a href="#lpop" class="headerlink" title="lpop"></a>lpop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#左侧出第一个值</span></span><br><span class="line"><span class="built_in">help</span> lpop</span><br><span class="line">LPOP key</span><br></pre></td></tr></table></figure><h4 id="lrange"><a href="#lrange" class="headerlink" title="lrange"></a>lrange</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取list链表start开始stop结束的值，正反索引都可以</span></span><br><span class="line"><span class="built_in">help</span> lrange</span><br><span class="line">LRANGE key [start] [stop]</span><br></pre></td></tr></table></figure><h4 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定下标的值</span></span><br><span class="line"><span class="built_in">help</span> lindex</span><br><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><h4 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置指定index的value</span></span><br><span class="line"><span class="built_in">help</span> lset</span><br><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><h4 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从指定pivot前或后插入指定value，pivot是存在的元素值，不是索引</span></span><br><span class="line"><span class="built_in">help</span> linsert</span><br><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">如果pivot存在多个，只在第一个匹配处操作</span><br></pre></td></tr></table></figure><h4 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除list链表中指定个数的指定value</span></span><br><span class="line"><span class="built_in">help</span> lrem</span><br><span class="line">LREM key count value</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数时表示下标从0开始从前往后匹配</span><br><span class="line">count为负数时表示下标从-1开始从后往前匹配</span><br></pre></td></tr></table></figure><h4 id="llen"><a href="#llen" class="headerlink" title="llen"></a>llen</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取list链表长度</span></span><br><span class="line"><span class="built_in">help</span> llen</span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure><h4 id="blpop"><a href="#blpop" class="headerlink" title="blpop"></a>blpop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阻塞式获取左侧第一个list的值</span></span><br><span class="line"><span class="built_in">help</span> blpop</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若有多个客户端对同一个key进行blpop，那么会按照阻塞队列顺序进行获取值(先来后到)</span><br></pre></td></tr></table></figure><h4 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对给定start和stop的两端数据进行删除</span></span><br><span class="line"><span class="built_in">help</span> ltrim</span><br><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>表示value的类型为hash键值对，即KV类型的值中V的值本身又是一个hash键值对。</p><h4 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置一个键值对</span></span><br><span class="line"><span class="built_in">help</span> hset</span><br><span class="line">HSET key field value</span><br></pre></td></tr></table></figure><h4 id="hget"><a href="#hget" class="headerlink" title="hget"></a>hget</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取一个键值对</span></span><br><span class="line"><span class="built_in">help</span> hget</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><h4 id="hemset"><a href="#hemset" class="headerlink" title="hemset"></a>hemset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置多个键值对</span></span><br><span class="line"><span class="built_in">help</span> hmset</span><br><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure><h4 id="hmget"><a href="#hmget" class="headerlink" title="hmget"></a>hmget</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取多个键值对</span></span><br><span class="line"><span class="built_in">help</span> hmget</span><br><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><h4 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有"键"</span></span><br><span class="line"><span class="built_in">help</span> hkeys</span><br><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><h4 id="hvals"><a href="#hvals" class="headerlink" title="hvals"></a>hvals</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有"值"</span></span><br><span class="line"><span class="built_in">help</span> hvals</span><br><span class="line">HVALS key</span><br></pre></td></tr></table></figure><h4 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有键值对，一键一值显示</span></span><br><span class="line"><span class="built_in">help</span> hgetall</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><h4 id="hincrbyfloat"><a href="#hincrbyfloat" class="headerlink" title="hincrbyfloat"></a>hincrbyfloat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#浮点数增加</span></span><br><span class="line"><span class="built_in">help</span> hincrbyfloat</span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">increment为正表示增加</span><br><span class="line">increment为负表示减少</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>可以理解为去重的list，但是list是有序的(存储顺序，不是排序)，而set是<strong>无序</strong>的。元素类型为string。</p><h4 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member加入到key中</span></span><br><span class="line"><span class="built_in">help</span> sadd</span><br><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定的key的所有成员</span></span><br><span class="line"><span class="built_in">help</span> smembers</span><br><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><h4 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定集合的交集</span></span><br><span class="line"><span class="built_in">help</span> sinter</span><br><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#和sinter类似，它是将交集存到指定集合中</span></span><br><span class="line"><span class="built_in">help</span> sinterstore</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回多个集合的并集</span></span><br><span class="line"><span class="built_in">help</span> sunio</span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sunionstore"><a href="#sunionstore" class="headerlink" title="sunionstore"></a>sunionstore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#和sunion类似，它是将并集存到指定集合中</span></span><br><span class="line"><span class="built_in">help</span> sunionstore</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断指定key中是否存在指定member</span></span><br><span class="line"><span class="built_in">help</span> sismember</span><br><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><h4 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回key对应的集合中的元素数量</span></span><br><span class="line"><span class="built_in">help</span> scard</span><br><span class="line">SCARD key</span><br></pre></td></tr></table></figure><h4 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将member元素从source集合移动到destination集合中</span></span><br><span class="line"><span class="built_in">help</span> smove</span><br><span class="line">SMOVE <span class="built_in">source</span> destination member</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若destination集合中已包含了<span class="built_in">source</span>要移动的元素则单纯的删除<span class="built_in">source</span>集合中的待移动元素</span><br></pre></td></tr></table></figure><h4 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除并返回集合中的count个随机元素，如果count不指定那么随机返回一个元素</span></span><br><span class="line"><span class="built_in">help</span> spop</span><br><span class="line">SPOP key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数且小于集合大小时返回指定数量的随机元素(各不相同)</span><br><span class="line">count为正数但大于集合大小时返回全部集合元素</span><br><span class="line">count为负数则返回其绝对值个数个随机元素(元素可能重复)</span><br></pre></td></tr></table></figure><h4 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除指定集合的一个或多个集合</span></span><br><span class="line"><span class="built_in">help</span> srem</span><br><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合内的count个随机元素</span></span><br><span class="line"><span class="built_in">help</span> srandmember</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数且小于集合大小时返回指定数量的随机元素(各不相同)</span><br><span class="line">count为正数但大于集合大小时返回全部集合元素</span><br><span class="line">count为负数则返回其绝对值个数个随机元素(元素可能重复)</span><br></pre></td></tr></table></figure><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>它和set一样都是集合，但是它是string类型<strong>有序</strong>集合。</p><h4 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member及其socre添加到set中</span></span><br><span class="line"><span class="built_in">help</span> zadd</span><br><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">NX：键存在时不能操作，类似于新建</span><br><span class="line">XX：键存在时才能操作，类似于更新</span><br></pre></td></tr></table></figure><h4 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回集合中元素个数</span></span><br><span class="line"><span class="built_in">help</span> zcard</span><br><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><h4 id="zcount"><a href="#zcount" class="headerlink" title="zcount"></a>zcount</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合中score值在min和max之间的member</span></span><br><span class="line"><span class="built_in">help</span> zcount</span><br><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><h4 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合中区间内的成员，按score从小到大排序</span></span><br><span class="line"><span class="built_in">help</span> zrange</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若score相同则按字典顺序排列</span><br><span class="line">若想要从大到小排列则使用zrevrange</span><br><span class="line">下标支持正反索引</span><br><span class="line">WITHSCORES表示member和score一并返回</span><br></pre></td></tr></table></figure><h4 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回有序集合中member的排名，从0开始，且score从小到大</span></span><br><span class="line"><span class="built_in">help</span> zrank</span><br><span class="line">ZRANK key member</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若想要从大到小排列则使用zrevrank</span><br></pre></td></tr></table></figure><h4 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除一个或多个member</span></span><br><span class="line"><span class="built_in">help</span> zrem</span><br><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="zremrangebyrank"><a href="#zremrangebyrank" class="headerlink" title="zremrangebyrank"></a>zremrangebyrank</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除有序集合中指定区间内的所有成员</span></span><br><span class="line"><span class="built_in">help</span> zremrangebyrank</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><h4 id="zremrangebyscore"><a href="#zremrangebyscore" class="headerlink" title="zremrangebyscore"></a>zremrangebyscore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除有序集合中score值在指定范围的member</span></span><br><span class="line"><span class="built_in">help</span> zremrangebyscore</span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;redis中存储的是KV键值对，其中key是一个对象，其内存储与value类型有关。&lt;/p&gt;
&lt;p&gt;value是有类型的值，包括string、hash、list、set等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis(1)-基本原理和安装配置</title>
    <link href="http://yoursite.com/2020/02/11/Redis-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/02/11/Redis-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-11T09:34:30.000Z</published>
    <updated>2020-02-11T09:35:38.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Redis是一个KV型存储引擎，为了提高效率，它的所有工作都在内存中实现，但为了持久存储也会在磁盘上做冗余。它用作数据结构服务器，即存储例如String、list、Hash、Set、Bitmap等类型的数据。</p><p>Redis工作在单线程单进程单实例模式，它通过内核的epoll系统调用来处理多路并行请求。</p><a id="more"></a><h4 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h4><p>早期的内核程序处理多路请求时使用read系统调用来处理，用户空间的进程如果没有读取到对应的文件描述符fd就会一直阻塞，从而妨碍其他进程处理请求。这就是初期的BIO阻塞模型。</p><p>随后为了解决阻塞问题，提出了同步非阻塞的NIO模型。它支持单进程在用户空间通过轮询的方式处理多个并发请求，这样就不会阻塞(多个进程会阻塞，这里就使用单进程轮询处理)。</p><p>NIO又引出新的问题，即如果请求量很大那么进程将频繁的在用户空间和内核空间进行切换(之所以不停切换是用户空间进程不知道哪些fd已经准备好需要被使用)，会消耗大量CPU资源。为了解决这个问题，内核进行了修改，出现了新的系统调用select。select实现了将多个可以使用的fd同时从内核发送给用户空间进程，由用户空间进程遍历选择依次进行read系统调用读取该连接，这样就大大减少了进程切换的开销。</p><p>上述select方法已经很大程度上减少了资源消耗，但是仍然需要将fd相关数据从内核态内存拷贝到用户空间进程的内存空间，以及select并不知道哪个fd是有数据状态，它自身也需要不断遍历来选择，有没有办法减少这种开销呢？这就引出了epoll机制。它实际上是使用mmap系统调用将用户空间的一块内存和内核空间的一块内存作为共享内存空间，其内维护着数据结构(红黑树和双向链表)，其中红黑树用于管理哪些fd需要被监视，双向链表实现队列。其中双向链表由内核维护，当进程在等待fd时，会创建了一个epoll对象(epoll对象本身也是文件系统资源，也拥有自己的等待队列)并且该epoll对象会被添加到fd等待队列中(如果是多个fd就将epoll放到每个fd等待队列中)。当某个进程调用epoll_wait等待时，内核将该进程添加到epoll对象的等待队列中，当某个fd收到数据时中断程序会修改epoll的双向链表(就绪队列)，添加fd引用并且唤醒阻塞的进程，从而该进程再次得到CPU调用且根据双向链表知道是哪个fd有数据。</p><p>epoll是三个系统调用：</p><ul><li><p>epoll_create：用户创建epoll对象，该对象的成员包括内核维护的双向链表</p></li><li><p>epoll_wait：用于epoll对象等待数据</p></li><li><p>epoll_cli：用于给epoll对象添加需要监控的fd，将fd添加到红黑树上</p></li></ul><h4 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h4><p>redis持久存储主要有两种方式：快照和AOF</p><ul><li>snapshotting：快照，数据异步从内存传输到磁盘</li><li>AOF：即将每次的写操作附加在一个文件后面写入磁盘，类似于mysql的事务日志</li></ul><h4 id="NoSql特性"><a href="#NoSql特性" class="headerlink" title="NoSql特性"></a>NoSql特性</h4><p>Redis属于NoSql存储，NoSql存储主要分为四种：KV键值型、Column列式存储、Documentation文档存储、Graph图表存储</p><h4 id="与memcached区别"><a href="#与memcached区别" class="headerlink" title="与memcached区别"></a>与memcached区别</h4><p>memcached也是KV键值对的NoSql型数据库系统，他们都工作在内存中，一个重要的区别是memcached的value是没有数据类型的，而Redis的value是有数据类型的。memcached存储时将所有键值对都获取然后客户端通过程序解码(解析json格式数据)进行特定数据获取，而Redis由于有数据类型且提供了每种类型特定的获取方法(index、lpop等)，因此可以直接获取对应数据，不需要加载全部数据，换句话说所有的计算都是在server端实现不需要客户端额外的解码等消耗，因此大大提高了效率。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#官网http://download.redis.io/releases/redis-5.0.7.tar.gz，此处使用编译安装</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar xf redis-5.0.7.tar.gz</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#安装，将可执行文件迁移</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment">#服务安装，切换至util目录下进行，全部默认即可</span></span><br><span class="line">./install_server.sh</span><br><span class="line"><span class="comment">#启动，名字后面为端口号，根据不同端口进行修改</span></span><br><span class="line">systemctl start redis_6379</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，如果make失败产生垃圾需要清除，具体命令以README.md为准</span></span><br><span class="line">make distclean</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">redis根据监听端口号不同区分不同的服务</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>redis配置文件根据不同的端口号命名不同，通常以xxxx.conf(其中xxxx为端口号)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">loadmoudle<span class="comment">#加载自定义模块</span></span><br><span class="line"><span class="built_in">bind</span><span class="comment">#redis服务监听地址</span></span><br><span class="line">port<span class="comment">#redis服务运行端口</span></span><br><span class="line">timeout<span class="comment">#客户端连接超时时长，即多久没有操作则关闭连接，0表示不设置时长</span></span><br><span class="line">tcp-keepalive<span class="comment">#周期性检测客户端监控状态，同样0表示不检测</span></span><br><span class="line">protected-mode<span class="comment">#是否开启保护模式，即是否允许客户端连接，默认为yes</span></span><br><span class="line">tcp-backlog<span class="comment">#tcp等待队列长度</span></span><br><span class="line">daemonize<span class="comment">#redis是否运行为守护进程</span></span><br><span class="line">pidfile<span class="comment">#配置PID文件路径</span></span><br><span class="line">loglevel<span class="comment">#定义日志级别debug(开发测试)、verbose、notice(生产环境)、warning，默认为notice</span></span><br><span class="line">logfile<span class="comment">#配置log文件地址,默认打印在命令行终端的窗口上</span></span><br><span class="line">databases<span class="comment">#设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select &lt;dbid&gt;命令选择一个不同的数据库，dbid是一个介于0到databases-1之间的数值。默认值是16，也就是说默认Redis有16个数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#持久存储相关</span></span><br><span class="line">save<span class="comment">#这里是用来配置触发Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘，格式为save num1 num2表示num1秒内有num2个key发生变化则同步到磁盘</span></span><br><span class="line">rdbcompression<span class="comment">#对于存储在磁盘的快照是否压缩存储，默认为yes</span></span><br><span class="line">rdbchecksum<span class="comment">#对于存储的快照是否校验，默认yes</span></span><br><span class="line">dbfilename<span class="comment">#设置快照名称，默认为dump.rdb</span></span><br><span class="line">dir<span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，使用dbfilename作为文件名</span></span><br><span class="line">stop-writes-on-bgsave-error<span class="comment">#当同步磁盘失败时是否停止接收数据，默认为yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主从复制相关</span></span><br><span class="line">replica-serve-stale-data<span class="comment">#主从复制时如何处理客户端请求，默认yes表示正常应答(会有过时数据)，no表示拒绝并返回错误提示</span></span><br><span class="line">replica-read-only<span class="comment">#从节点是否处理请求，默认为yes</span></span><br><span class="line">repl-diskless-sync<span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line">repl-diskless-sync-delay<span class="comment">#当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能只需将它设置为0秒，传送会立即启动。默认值为5。</span></span><br><span class="line">repl-disable-tcp-nodelay<span class="comment">#默认值为no。yes表示redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#AOF主从相关</span></span><br><span class="line">appendonly<span class="comment">#使用AOF主从方式，默认为no</span></span><br><span class="line">appendfilename<span class="comment">#文件名称</span></span><br><span class="line">appendfsync<span class="comment">#持久策略，no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#集群相关</span></span><br><span class="line">cluster-enabled<span class="comment">#是否开启集群，默认为no</span></span><br><span class="line">cluster-config-file<span class="comment">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息</span></span><br><span class="line">cluster-node-timeout<span class="comment">#节点互连超时的阀值，集群节点超时毫秒数</span></span><br><span class="line">cluster-slave-validity-factor<span class="comment">#可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period。如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</span></span><br><span class="line">cluster-migration-barrier<span class="comment">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2个可工作的从节点时，它的一个从节点会尝试迁移。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;Redis是一个KV型存储引擎，为了提高效率，它的所有工作都在内存中实现，但为了持久存储也会在磁盘上做冗余。它用作数据结构服务器，即存储例如String、list、Hash、Set、Bitmap等类型的数据。&lt;/p&gt;
&lt;p&gt;Redis工作在单线程单进程单实例模式，它通过内核的epoll系统调用来处理多路并行请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="epoll" scheme="http://yoursite.com/tags/epoll/"/>
    
      <category term="多路复用" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>k8s(9)-helm程序包管理</title>
    <link href="http://yoursite.com/2020/02/10/k8s-9-helm%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/10/k8s-9-helm%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-10T06:05:12.000Z</published>
    <updated>2020-02-10T06:05:56.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为了解决各个服务安装pod时的依赖以及资源文件修改编写等问题从而提出helm。helm和yum类似，可以理解为包管理工具。</p><a id="more"></a><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>chart：一个helm程序包，是创建一个应用的信息集合，包含各种Kubernetes对象的配置模板、参数定义、依赖关系、文档说明等。可以将Chart比喻为yum中的软件安装包；char包括参数模板和值模板，因此可以自定义对其进行修改。</p></li><li><p>Repository：Charts仓库，本质是一个http服务器，用于集中存储和分发Charts；</p></li><li><p>Config：应用程序实例化安装运行时所需要的配置信息；就是chart模板的值文件</p></li><li><p>Release：特定的Chart部署于目标集群上的一个实例，代表这一个正在运行的应用。当chart被安装到Kubernetes集群，就会生成一个release，chart可以多次安装到同一个集群，每次安装都是一个release。</p></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li>helm：客户端，实现管理本地的Chart仓库，可管理Chart，与Tiller服务进行交互，用于发送Chart，实例安装、查询、卸载等操作。</li><li>Tiller：服务端，通常运行在K8S集群之上。用于接收helm发来的Charts和Conifg，合并生成release，完成部署。</li></ul><p>Helm把Kubernetes资源(比如deployments、services或 ingress等) 打包到一个chart中，而chart被保存到chart仓库，通过chart仓库可用来存储和分享chart。在k8s集群上想要创建pod必须通过APIServer，因此helm客户端将创建请求以及需要的文件发往Tiller服务端，由其向APIServer交互实现pod的创建。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="部署helm"><a href="#部署helm" class="headerlink" title="部署helm"></a>部署helm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载https://github.com/helm/helm/releases编译好的版本，此处使用2.11版本</span></span><br><span class="line">wget https://get.helm.sh/helm-v2.11.0-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#解压出linux-amd64文件</span></span><br><span class="line">tar xf helm-v2.11.0-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#将二进制文件复制到/usr/bin下直接命令行运行</span></span><br><span class="line"><span class="built_in">cd</span> </span><br><span class="line">mv helm /usr/bin</span><br><span class="line">mv tiller /usr/bin</span><br></pre></td></tr></table></figure><h4 id="部署Tiller"><a href="#部署Tiller" class="headerlink" title="部署Tiller"></a>部署Tiller</h4><p>3.0之后的helm部署时就没有这一步了，此处使用2.11部署。</p><p>部署Tiller就是执行helm的init指令。helm第一次init时，需要APIServer进行创建部署pod，因此需要链接api-server并进行认证，所以在运行helm时，会去读取kube-config文件，所以必须确认当前用户存在kube-config文件。</p><p>Tiller运行在K8s集群之上，也必须拥有集群的管理权限，也就是需要一个serviceaccount，进行一个clusterrolebinding到cluster-admin。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建rbac</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化，使用阿里云镜像，初始化之后会在kube-system中创建pod</span></span><br><span class="line"><span class="string">helm</span> <span class="string">init</span> <span class="string">--service-account</span> <span class="string">tiller</span> <span class="string">--upgrade</span> <span class="string">-i</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.11.0</span> <span class="string">--stable-repo-url</span> <span class="string">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否安装完成，正确的话可以看到helm和tiller的版本</span></span><br><span class="line"><span class="string">helm</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">helm常用命令：</span><br><span class="line">search:    <span class="comment">#搜索charts</span></span><br><span class="line">fetch:     <span class="comment">#下载charts到本地目录</span></span><br><span class="line">install:   <span class="comment">#安装charts</span></span><br><span class="line">list:      <span class="comment">#列出charts的所有版本</span></span><br><span class="line">repo list: <span class="comment">#列出仓库</span></span><br><span class="line">repo add:  <span class="comment">#添加仓库</span></span><br><span class="line"></span><br><span class="line">用法:</span><br><span class="line">  helm [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line">命令可用选项:</span><br><span class="line">  completion  <span class="comment">#为指定的shell生成自动补全脚本（bash或zsh）</span></span><br><span class="line">  create      <span class="comment">#创建一个新的charts</span></span><br><span class="line">  delete      <span class="comment">#删除指定版本的release</span></span><br><span class="line">  dependency  <span class="comment">#管理charts的依赖</span></span><br><span class="line">  fetch       <span class="comment">#下载charts并解压到本地目录</span></span><br><span class="line">  get         <span class="comment">#下载一个release</span></span><br><span class="line">  <span class="built_in">history</span>     <span class="comment">#release历史信息</span></span><br><span class="line">  home        <span class="comment">#显示helm的家目录</span></span><br><span class="line">  init        <span class="comment">#在客户端和服务端初始化helm</span></span><br><span class="line">  inspect     <span class="comment">#查看charts的详细信息</span></span><br><span class="line">  install     <span class="comment">#安装charts</span></span><br><span class="line">  lint        <span class="comment">#检测包的存在问题</span></span><br><span class="line">  list        <span class="comment">#列出release</span></span><br><span class="line">  package     <span class="comment">#将chart目录进行打包</span></span><br><span class="line">  plugin      <span class="comment">#add(增加), list（列出）, or remove（移除） Helm 插件</span></span><br><span class="line">  repo        <span class="comment">#add(增加), list（列出）, remove（移除）, update（更新）, and index（索引） chart仓库</span></span><br><span class="line">  reset       <span class="comment">#卸载tiller</span></span><br><span class="line">  rollback    <span class="comment">#release版本回滚</span></span><br><span class="line">  search      <span class="comment">#关键字搜索chart</span></span><br><span class="line">  serve       <span class="comment">#启动一个本地的http server</span></span><br><span class="line">  status      <span class="comment">#查看release状态信息</span></span><br><span class="line">  template    <span class="comment">#本地模板</span></span><br><span class="line">  <span class="built_in">test</span>        <span class="comment">#release测试</span></span><br><span class="line">  upgrade     <span class="comment">#release更新</span></span><br><span class="line">  verify      <span class="comment">#验证chart的签名和有效期</span></span><br><span class="line">  version     <span class="comment">#打印客户端和服务端的版本信息</span></span><br></pre></td></tr></table></figure><h3 id="chart"><a href="#chart" class="headerlink" title="chart"></a>chart</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>下载下来的chart放在/root/.helm/cache/archive下，为压缩文件。其内部由多个yaml文件组成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看jenkins打包目录</span></span><br><span class="line">[root@localhost archive]@ tree jenkins</span><br><span class="line">jenkins</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── OWNERS</span><br><span class="line">├── README.md</span><br><span class="line">├── templates</span><br><span class="line">│   ├── config.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── home-pvc.yaml</span><br><span class="line">│   ├── jenkins-agent-svc.yaml</span><br><span class="line">│   ├── jenkins-master-deployment.yaml</span><br><span class="line">│   ├── jenkins-master-ingress.yaml</span><br><span class="line">│   ├── jenkins-master-networkpolicy.yaml</span><br><span class="line">│   ├── jenkins-master-svc.yaml</span><br><span class="line">│   ├── jenkins-test.yaml</span><br><span class="line">│   ├── jobs.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── rbac.yaml</span><br><span class="line">│   ├── secret.yaml</span><br><span class="line">│   ├── service-account.yaml</span><br><span class="line">│   └── <span class="built_in">test</span>-config.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">1 directory, 19 files</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">template中放的yaml文件和平时定义的差不多，但是都是以模板定义，通过values.yaml进行默认赋值。我们可以自定义该文件进行赋值</span><br></pre></td></tr></table></figure><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以jenkins为例</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Release.Name &#125;&#125;</span>-ui-test-<span class="template-variable">&#123;&#123; randAlphaNum 5 | lower &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">"helm.sh/hook":</span> <span class="string">test-success</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.Master.NodeSelector</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.Master.NodeSelector</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">4</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.Master.Tolerations</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.Master.Tolerations</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">4</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"test-framework"</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">"dduportal/bats:0.4.0"</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"bash"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"-c"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">        <span class="string">set</span> <span class="string">-ex</span></span><br><span class="line">        <span class="comment"># copy bats to tools dir</span></span><br><span class="line">        <span class="string">cp</span> <span class="string">-R</span> <span class="string">/usr/local/libexec/</span> <span class="string">/tools/bats/</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tools</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-ui-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.Image</span> <span class="string">&#125;&#125;:&#123;&#123;</span> <span class="string">.Values.Master.ImageTag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">["/tools/bats/bats",</span> <span class="string">"-t"</span><span class="string">,</span> <span class="string">"/tests/run.sh"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tests</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tools</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tests</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"jenkins.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;-tests</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#解释</span></span><br><span class="line"><span class="string">.Release.Name：是Chart内置变量，表示创建的release的名称，其他类似</span></span><br><span class="line"><span class="string">.Chart.Name：也是内置变量，表示chart名称</span></span><br><span class="line"><span class="string">.Values.Master.NodeSelector：.Values表示的是Value.yaml文件，Master是一级字段(顶格写)，依次如此</span></span><br><span class="line"><span class="string">template</span> <span class="string">"jenkins.fullname"</span><span class="string">：表示引用template目录下的其他模板的某个属性字段</span></span><br><span class="line"><span class="string">randAlphaNum</span> <span class="number">5</span> <span class="string">|</span> <span class="string">lower：前者是Go模板的函数，通过|传递结果</span></span><br></pre></td></tr></table></figure><h4 id="自定义chart"><a href="#自定义chart" class="headerlink" title="自定义chart"></a>自定义chart</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建chart基本目录结构</span></span><br><span class="line"><span class="string">helm</span> <span class="string">create</span> <span class="string">myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目录结构为</span></span><br><span class="line"><span class="string">myapp/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">charts</span></span><br><span class="line"><span class="string">├──</span> <span class="string">Chart.yaml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">templates</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">deployment.yaml</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">_helpers.tpl</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">ingress.yaml</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">NOTES.txt</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">service.yaml</span></span><br><span class="line"><span class="string">└──</span> <span class="string">values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改Chart.yaml文件，里面是基本描述信息</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">"1.0"</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">maintainer:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Dqy</span></span><br><span class="line">  <span class="attr">email:</span> <span class="number">1259178786</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://www.frdqy.top</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#template/deployment文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">helm.sh/chart:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.chart"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Service</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.replicaCount</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Chart.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.image.tag &#125;&#125;</span>"</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.image.pullPolicy</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.resources</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">12</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.affinity</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.tolerations</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">myapp.fullname：是当前chart的完整名称，其他类似。myapp就是当前chart的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑完后，需要检查语法，需要在myapp目录外面使用</span></span><br><span class="line"><span class="string">helm</span> <span class="string">lint</span> <span class="string">./myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打包，默认放在本地的仓库local中</span></span><br><span class="line"><span class="string">helm</span> <span class="string">package</span> <span class="string">myapp/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启仓库，监听本地8879端口</span></span><br><span class="line"><span class="string">helm</span> <span class="string">serve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装，可以通过目录安装，压缩包安装，仓库安装以及URL安装</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">local/myapp</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">./myapp</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">./myapp-0.1.0.tgz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除，使用purge删除占用的名字</span></span><br><span class="line"><span class="string">helm</span> <span class="string">delete</span> <span class="string">--purge</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure><h4 id="自定义仓库"><a href="#自定义仓库" class="headerlink" title="自定义仓库"></a>自定义仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在node1上运行httpd，存储卷绑定于/var/www目录</span></span><br><span class="line">docker run -d -p 8080:80 -v /var/www/:/usr/<span class="built_in">local</span>/apache2/htdocs/ httpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行index命令生成页面。myrepo是目录，目录内放打包好的压缩文件</span></span><br><span class="line">helm repo index myrepo/ --url http://192.168.163.135:8080/charts</span><br><span class="line"></span><br><span class="line"><span class="comment">#将mychart-0.1.0.tgz和index.yaml上传到k8s-node1的/var/www/charts目录。</span></span><br><span class="line">scp ./* root@node01:/var/www/charts/</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加仓库源</span></span><br><span class="line">helm repo add newrepo http://192.168.163.135:8080/charts</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;为了解决各个服务安装pod时的依赖以及资源文件修改编写等问题从而提出helm。helm和yum类似，可以理解为包管理工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="helm" scheme="http://yoursite.com/tags/helm/"/>
    
  </entry>
  
  <entry>
    <title>k8s(8)-资源指标和监控</title>
    <link href="http://yoursite.com/2020/02/09/k8s-8-%E8%B5%84%E6%BA%90%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2020/02/09/k8s-8-%E8%B5%84%E6%BA%90%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%91%E6%8E%A7/</id>
    <published>2020-02-09T04:24:08.000Z</published>
    <updated>2020-02-09T04:28:23.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见指标"><a href="#常见指标" class="headerlink" title="常见指标"></a>常见指标</h3><p>request：需求，pod内容器运行时的资源最低保障</p><p>limits：限制，pod内容器可占用的最大资源阈值</p><p>CPU：一个物理CPU可分成多个逻辑CPU(根据核心数划分)，每个逻辑CPU又可以分为1000个微核心(millicores)</p><p>内存：以E、P、T、G、M、K为计量单位，特别的当以Ei、Pi等作为计量单位时表示使用1024作为单位</p><p>QoS：作资源限制后每个pod会自动分配QoS类别，主要分三种：</p><a id="more"></a><ul><li>Guaranteed：pod内每个容器同时设置CPU和内存的requests和limits且值相等，这类pod具有最高优先级</li><li>Burstable：pod内至少一个容器定义了CPU或者内存的requests属性，具有中等优先级</li><li>BestEffort：pod内容器没有定义资源限制，具有最低优先级</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义在pod.containers.spec.resources</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-demo</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">contaniers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">  <span class="attr">cpu:</span> <span class="string">"200m"</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">"256Mi"</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">"512Mi"</span></span><br></pre></td></tr></table></figure><h3 id="HeapSter"><a href="#HeapSter" class="headerlink" title="HeapSter"></a>HeapSter</h3><p>k8s集群上可以使用top命令查看各pod和node的资源使用情况，但是默认情况下无法使用，因为该命令实际上需要HeapSter来收集监控数据从而显示出来，因此需要先安装HeapSter。</p><p>我们知道每个node节点上都有一个kubelet程序，该程序用于管理node以及其上pod资源，它靠其插件cAdvisor来收集当前node节点上各pod内容器资源以及node资源的占用量。但是由于cAdvisor只能收集单个node节点的资源使用情况，因此使用HeapSter来收集cAdvisor收集的数据，即HeapSter是统一的多个指标的收集工具。另外，为了使得HeapSter能够存储收集的数据以便查看长久的趋势数据，它使用influxDB时序数据库系统来持久存储。最后可以使用Grafana作为前端显示监控工具，它可以连接influxDB数据库。</p><h4 id="部署influxDB"><a href="#部署influxDB" class="headerlink" title="部署influxDB"></a>部署influxDB</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源文件https://raw.githubusercontent.com/kubernetes-retired/heapster/master/deploy/kube-config/influxdb/influxdb.yaml，需要修改为如下样式</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">monitoring-influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/heapster-influxdb-amd64:v1.5.2</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">    <span class="comment"># For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</span></span><br><span class="line">    <span class="comment"># If you are NOT using this as an addon, you should comment out this line.</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">'true'</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">monitoring-influxdb</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">monitoring-influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8086</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#应用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">influxdb.yaml</span></span><br></pre></td></tr></table></figure><h4 id="部署RBAC"><a href="#部署RBAC" class="headerlink" title="部署RBAC"></a>部署RBAC</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源文件，https://raw.githubusercontent.com/kubernetes-retired/heapster/master/deploy/kube-config/rbac/heapster-rbac.yaml，不需要修改</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:heapster</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#应用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">heapster-rbac.yaml</span></span><br></pre></td></tr></table></figure><h4 id="部署heapster"><a href="#部署heapster" class="headerlink" title="部署heapster"></a>部署heapster</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源文件https://raw.githubusercontent.com/kubernetes-retired/heapster/master/deploy/kube-config/influxdb/heapster.yaml，需要修改为如下样式</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">heapster</span> </span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">heapster</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">heapster</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/heapster-amd64:v1.5.4</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/heapster</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--source=kubernetes:https://kubernetes.default</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--sink=influxdb:http://monitoring-influxdb.kube-system.svc:8086</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">    <span class="comment"># For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</span></span><br><span class="line">    <span class="comment"># If you are NOT using this as an addon, you should comment out this line.</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">'true'</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">Heapster</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">heapster</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#应用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">heapster.yaml</span></span><br></pre></td></tr></table></figure><h4 id="部署grafana"><a href="#部署grafana" class="headerlink" title="部署grafana"></a>部署grafana</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源文件，https://raw.githubusercontent.com/kubernetes-retired/heapster/master/deploy/kube-config/influxdb/grafana.yaml，需要修改为如下样式</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">monitoring-grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/heapster-grafana-amd64:v5.0.4</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/ssl/certs</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">ca-certificates</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">grafana-storage</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">INFLUXDB_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">monitoring-influxdb</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SERVER_HTTP_PORT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"3000"</span></span><br><span class="line">          <span class="comment"># The following env variables are required to make Grafana accessible via</span></span><br><span class="line">          <span class="comment"># the kubernetes api-server proxy. On production clusters, we recommend</span></span><br><span class="line">          <span class="comment"># removing these env variables, setup auth for grafana, and expose the grafana</span></span><br><span class="line">          <span class="comment"># service using a LoadBalancer or a public IP.</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_BASIC_ENABLED</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"false"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_ANONYMOUS_ENABLED</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"true"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_AUTH_ANONYMOUS_ORG_ROLE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">Admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SERVER_ROOT_URL</span></span><br><span class="line">          <span class="comment"># If you're only using the API Server proxy, set this value instead:</span></span><br><span class="line">          <span class="comment"># value: /api/v1/namespaces/kube-system/services/monitoring-grafana/proxy</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ca-certificates</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/ssl/certs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="comment"># For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</span></span><br><span class="line">    <span class="comment"># If you are NOT using this as an addon, you should comment out this line.</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">'true'</span></span><br><span class="line">    <span class="attr">kubernetes.io/name:</span> <span class="string">monitoring-grafana</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">monitoring-grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># In a production setup, we recommend accessing Grafana through an external Loadbalancer</span></span><br><span class="line">  <span class="comment"># or through a public IP.</span></span><br><span class="line">  <span class="comment"># type: LoadBalancer</span></span><br><span class="line">  <span class="comment"># You could also use NodePort to expose the service at a randomly-generated port</span></span><br><span class="line">  <span class="comment"># type: NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#应用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">grafana.yaml</span></span><br></pre></td></tr></table></figure><h3 id="新监控体系"><a href="#新监控体系" class="headerlink" title="新监控体系"></a>新监控体系</h3><p>上面讲的HeapSter监控体系在k8s1.11时已经被废弃，现在是普遍使用的是metrics-server来代替HeapSter进行资源指标的获取。另外，现在还使用prometheus进行自定义资源指标的获取(需要k8s-prometheus-adapter将自定义的监控数据转换成指标格式)，并且它本身还是一个监控系统，用于监控例如CPU、内存、报文收发、进程切换等指标。</p><p>整体监控体系主要分两部分：</p><ul><li><p>核心指标流水线：由kubelet、metrics-server以及由APIServer提供的api组成，主要有：CPU累计使用率、内存实时使用率、Pod资源占用率及容器的磁盘占用率等。这些资源需要被系统其他进程所使用，例如top。</p></li><li><p>监控流水线：用于从系统收集各种指标数据并提供中断用户、存储系统及HPA，它包含核心指标和非核心指标。但是非核心指标本身不能被k8s所解析，需要转换成固定指标格式才可以。</p></li></ul><h4 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h4><p>由于k8s不支持heapSter，为了获取系统核心指标而提出了metrics-server。它作为一个server工作，类似于APIServer，它拓展了k8s本身所没有的群组，从而实现资源监控功能。在多个server模型下，需要一个kube-aggregator聚合器来实现对外统一，以后用户访问时都通过这个聚合器进行访问，这样就可以即访问k8s原生的k8s群组，也可以使用拓展的metrics-server群组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/metrics-server</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> auth-delegator.yaml auth-reader.yaml metrics-apiservice.yaml metrics-server-deployment.yaml metrics-server-service.yaml resource-reader.yaml ;<span class="keyword">do</span> wget https://raw.githubusercontent.com/kubernetes/kubernetes/master/cluster/addons/metrics-server/<span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line">kubectl apply -f .</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">下载下来的yaml文件不能直接使用，需要修改两个文件</span><br><span class="line"><span class="comment">#修改resource-reader.yaml，在resources字段下增加node/stats，这是节点数据获取的资源路径</span></span><br><span class="line">resources:</span><br><span class="line">  - node/stats</span><br><span class="line"><span class="comment">#修改metrics-server-deployment.yaml，在deployment的command字段修改端口为10250，为kubelet</span></span><br><span class="line"><span class="built_in">command</span>:</span><br><span class="line">- --kubelet-port=10250</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用top命令不出错说明配置成功</span></span><br><span class="line">kubectl top</span><br></pre></td></tr></table></figure><h4 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h4><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p><img src="/2020/02/09/k8s-8-%E8%B5%84%E6%BA%90%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%91%E6%8E%A7/k8s-prometheus.png" alt></p><p>它本身是一个监控工具，分为server端和agent端，server端从被监控主机获取数据，而agent端需要部署一个node_exporter，主要用于数据采集和暴露node节点的数据，对于获取Pod级别或者是mysql等多种应用的数据时，需要部署相关的exporter来暴露。Prometheus部署过后会自动通过metricURL向各个pod采集数据，可以通过PromQL的方式对数据进行查询，但是由于本身prometheus属于第三方的解决方案，原生的k8s系统并不能对Prometheus的自定义指标进行解析，需要使用kube-state-metrics来转换，然后借助于k8s-prometheus-adapter将其配置为APIServer聚合到一起，从而能被访问。</p><p><img src="/2020/02/09/k8s-8-%E8%B5%84%E6%BA%90%E6%8C%87%E6%A0%87%E5%92%8C%E7%9B%91%E6%8E%A7/k8s-prometheus-2.png" alt></p><p>Prometheus通过pull metrics向每个exporter获取指标数据。也可以被动的接收，各个组件可以将数据推送至Push Gateway，由Prometheus从push gateway获取数据。获取到数据后，将这些数据存储到自己内建的时序存储数据库中。Prometheus通过Service Discovery来发现服务，从而知道需要监控哪些服务。对于获取的数据来说它支持API client、web UI、grafana来显示数据(将prometheus当作数据源)。当Prometheus发生异常时会将信息发送给一个外部独立组件Alertmanager，它负责发送报警信息。</p><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://github.com/iKubernetes/k8s-prom</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iKubernetes/k8s-prom.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建名称空间prom</span></span><br><span class="line">kubectl apply -f namespace.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署exporter，在prom名称空间中创建DaemonSet</span></span><br><span class="line"><span class="built_in">cd</span> node_exporter/</span><br><span class="line">kubectl apply -f .</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署Prometheus，需要删除deploy的资源限制</span></span><br><span class="line"><span class="built_in">cd</span> prometheus/</span><br><span class="line">kubectl apply -f .</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署kube-state-metrics，用于转换指标</span></span><br><span class="line"><span class="built_in">cd</span> kube-state-metrics/</span><br><span class="line">kubectl apply -f .</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署k8s-prometheus-adapter，本身是http协议，需要k8s签署一个证书给他</span></span><br><span class="line"><span class="comment">#制作证书</span></span><br><span class="line"><span class="built_in">cd</span> /etc/kubernetes/pki/</span><br><span class="line">(<span class="built_in">umask</span> 077; openssl genrsa -out serving.key 2048)</span><br><span class="line">openssl req -new -key serving.key -out serving.csr -subj <span class="string">"/CN=serving"</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> serving.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -out serving.crt -days 3650</span><br><span class="line"><span class="comment">#创建secret</span></span><br><span class="line">kubectl create secret generic cm-adapter-serving-certs --from-file=serving.crt=./serving.crt --from-file=serving.key -n prom</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署k8s-prometheus-adapter，注意自带的custom-metrics-apiserver-deployment.yaml和custom-metrics-config-map.yaml有问题，需要重新下载，并且修改名称空间为prom</span></span><br><span class="line">wget https://raw.githubusercontent.com/DirectXMan12/k8s-prometheus-adapter/master/deploy/manifests/custom-metrics-apiserver-deployment.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/DirectXMan12/k8s-prometheus-adapter/master/deploy/manifests/custom-metrics-config-map.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">部署后可以使用grafana进行数据绑定</span><br><span class="line">需要注意grafana和Prometheus通信属于pod通信，配置时的url写为http://prometheus.prom.svc:9090表示prom名称空间内的service，注意端口是9090，不是NodePort暴露出集群的端口</span><br></pre></td></tr></table></figure><h3 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h3><p>Horizontal Pod Autoscaling，简称HPA，用于实现Pod的动态增减功能。HPA会从Heapster或者用户自定义的RESTclient端获取每个Pod利用率或原始值的平均值，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值并进行相应的操作。HPA也是k8s集群的资源对象。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建pod</span></span><br><span class="line">kubectl run nginx --image=nginx --replicas=1 --requests=<span class="string">'cpu=50m,memory=256Mi'</span> --limits=<span class="string">'cpu=50m,memory=256Mi'</span> --labels=<span class="string">'app=nginx'</span> --expose --port=80</span><br><span class="line"><span class="comment">#设置autoscale</span></span><br><span class="line">kubectl autoscale deployment nginx --min=1 --max=8 --cpu-percent=60</span><br><span class="line"><span class="comment">#暴露service端口进行压测</span></span><br><span class="line">kubectl patch svc nginx -p <span class="string">'&#123;"spec":&#123;"type":"NodePort"&#125;&#125;'</span></span><br><span class="line"><span class="comment">#压测</span></span><br><span class="line">ab -c 1000 -n 500000 http://192.168.163.135:32126</span><br></pre></td></tr></table></figure><h4 id="资源定义"><a href="#资源定义" class="headerlink" title="资源定义"></a>资源定义</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ngixn-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">10</span>                   <span class="comment">#最大pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">1</span>                    <span class="comment">#最小pod数量</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>           <span class="comment">#针对扩容deployment</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span>        <span class="comment">#需要扩容的类型</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>        <span class="comment">#需要扩容的deployment名称</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">90</span>  <span class="comment">#CPU使用率，平均数</span></span><br><span class="line">  <span class="attr">metrics:</span><span class="comment">#对哪些指标进行评估</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">  <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">    <span class="attr">targetAverageUtilization:</span> <span class="number">55</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">memory</span></span><br><span class="line">      <span class="attr">targetAverageValue:</span> <span class="string">50Mi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常见指标&quot;&gt;&lt;a href=&quot;#常见指标&quot; class=&quot;headerlink&quot; title=&quot;常见指标&quot;&gt;&lt;/a&gt;常见指标&lt;/h3&gt;&lt;p&gt;request：需求，pod内容器运行时的资源最低保障&lt;/p&gt;
&lt;p&gt;limits：限制，pod内容器可占用的最大资源阈值&lt;/p&gt;
&lt;p&gt;CPU：一个物理CPU可分成多个逻辑CPU(根据核心数划分)，每个逻辑CPU又可以分为1000个微核心(millicores)&lt;/p&gt;
&lt;p&gt;内存：以E、P、T、G、M、K为计量单位，特别的当以Ei、Pi等作为计量单位时表示使用1024作为单位&lt;/p&gt;
&lt;p&gt;QoS：作资源限制后每个pod会自动分配QoS类别，主要分三种：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="metrics" scheme="http://yoursite.com/tags/metrics/"/>
    
      <category term="prometheus" scheme="http://yoursite.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>k8s(7)-调度</title>
    <link href="http://yoursite.com/2020/02/07/k8s-7-%E8%B0%83%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/02/07/k8s-7-%E8%B0%83%E5%BA%A6/</id>
    <published>2020-02-07T06:00:34.000Z</published>
    <updated>2020-02-07T06:01:50.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当APIServer收到新的pod创建请求时会根据请求的资源清单使用schedule进行node节点调度。调度分为三个阶段：节点预选(Predicate)-&gt;节点优选(Priority)-&gt;节点选定(Select)</p><ul><li>节点预选：基于一系列的预选规则对每个节点进行检查，将那些不符合条件的节点过滤(如端口冲突、资源不足等)，从而完成节点的预选</li><li>节点优选：对预选出的节点进行优先级排序，以便选出最合适运行Pod对象的节点</li><li>节点选定：从优先级排序结果中挑选出优先级最高的节点运行Pod，当这类节点多于1个时，则进行随机选择<a id="more"></a></li></ul><h3 id="节点预选"><a href="#节点预选" class="headerlink" title="节点预选"></a>节点预选</h3><p>若定义多个预选策略，必须全部满足才可以通过预选。下面是常见的一些预算策略：</p><ul><li>CheckNodeCondition：检查节点是否工作正常</li><li>HostName：如果Pod对象拥有pod.spec.hostname属性，则检查节点名称字符串是否和该属性值匹配。</li><li>PodFitsHostPorts：如果Pod对象定义了pod.spec.container.ports.hostPort属性，则检查Pod指定的端口是否已经被节点上的其他容器或服务占用。</li><li>MatchNodeSelector：如果Pod对象定义了pod.spec.nodeSelector属性，则检查节点标签是否和该属性匹配。</li><li>NoDiskConflict：检查Pod对象请求的存储卷在该节点上可用。</li><li>PodFitsResources：检查节点上的资源（CPU、内存）可用性是否满足Pod对象的运行需求。</li><li>PodToleratesNodeTaints：如果Pod对象中定义了pod.spec.tolerations属性，则需要检查该属性值是否可以接纳节点定义的污点（taints），且node污点改变后默认仍接收。</li><li>PodToleratesNodeNoExecuteTaints：如果Pod对象定义了pod.spec.tolerations属性，检查该属性是否接纳节点的NoExecute类型的污点，node污点改变后如果不容忍则不接受。</li><li>CheckNodeLabelPresence：仅检查节点上指定的所有标签的存在性，要检查的标签以及其可否存在取决于用户的定义。</li><li>CheckServiceAffinity：将同一Service下的pod节点优先放在一个node上。</li><li>MaxEBSVolumeCount：检查节点上是否已挂载EBS存储卷数量是否超过了设置的最大值，默认值：39</li><li>MaxGCEPDVolumeCount：检查节点上已挂载的GCE PD存储卷是否超过了设置的最大值，默认值：16</li><li>MaxAzureDiskVolumeCount：检查节点上已挂载的Azure Disk存储卷数量是否超过了设置的最大值，默认值：16</li><li>CheckVolumeBinding：检查节点上已绑定和未绑定的PVC是否满足Pod对象的存储卷需求。</li><li>NoVolumeZoneConflct：在给定了区域限制的前提下，检查在该节点上部署Pod对象是否存在存储卷冲突。</li><li>CheckNodeMemoryPressure：在给定了节点已经上报了存在内存资源压力过大的状态，则需要检查该Pod是否可以调度到该节点上。</li><li>CheckNodePIDPressure：如果给定的节点已经报告了存在PID资源压力过大的状态，则需要检查该Pod是否可以调度到该节点上。</li><li>CheckNodeDiskPressure：如果给定的节点存在磁盘资源压力过大，则检查该Pod对象是否可以调度到该节点上。</li><li>MatchInterPodAffinity：检查给定的节点能否可以满足Pod对象的亲和性和反亲和性条件，用来实现Pod亲和性调度或反亲和性调度。</li></ul><h3 id="节点优选"><a href="#节点优选" class="headerlink" title="节点优选"></a>节点优选</h3><p>预选后的一些列节点列表会进入优选阶段，在这个过程schedule会向每个通过预选的节点传递一系列的优选函数来计算其优先级分值，优先级分值介于0-10之间，其中0表示不适用，10表示最适合托管该Pod对象。另外，调度器还支持给每个优选函数指定一个简单的值，表示权重，进行节点优先级分值计算时，它首先将每个优选函数的计算得分乘以权重，然后再将所有优选函数的得分相加，从而得出节点的最终优先级分值。权重可以让管理员定义优选函数倾向性的能力，其计算优先级的得分公式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finalScoreNode = (weight1 * priorityFunc1) + (weight2 * priorityFunc2) + ......</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">weight表示该优选函数的权重</span><br><span class="line">priorityFunc表示该优选函数的优先级</span><br></pre></td></tr></table></figure><ul><li>least_requested：选择消耗最小的节点（根据空闲比率评估 cpu((总容量-已使用)*10/总容量) ）</li><li>most_requested：选择消耗最大的节点上（尽量将一个节点上的资源用完）</li><li>balanced_resource_allocation：从节点列表中选出各项资源使用率最均衡的节点（CPU和内存）</li><li>node_prefer_avoid_pods：节点倾向。判断节点是否有注解”scheduler.alpha.kubernetes.io/preferAvoidPods”，如果有就权重为0，没有则权重为10000。</li><li>taint_toleration：将pod对象的spec.toleration与节点的taints列表项进行匹配度检查，匹配的条目越多，得分越低。</li><li>selector_spreading：与services上其他pod尽量不在同一个节点上，节点上通一个service的pod越少得分越高。</li><li>interpod_affinity：遍历node上的亲和性条目，与pod亲和性匹配项越多的得分越高</li><li>node_label：根据节点标签得分，存在标签既得分，没有标签没得分。标签越多得分越高。</li><li>image_locality：节点上有所需要的镜像既得分，所需镜像越多得分越高。（根据已有镜像体积大小之和）</li></ul><h3 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h3><p>节点亲和性指的是pod定义的pod.spec.affinity.nodeAffinity字段定义的标签列表和node节点的标签的匹配程度。</p><p>定义节点亲和性规则有2种：</p><ul><li><p>硬亲和性（require）：实现的是强制性规则，是Pod调度时必须满足的规则，否则Pod对象的状态会一直是Pending</p></li><li><p>软亲和性（preferred）：实现的是一种柔性调度限制，在Pod调度时可以尽量满足其规则，在无法满足规则时，可以调度到一个不匹配规则的节点之上。</p></li></ul><h4 id="硬亲和性实例"><a href="#硬亲和性实例" class="headerlink" title="硬亲和性实例"></a>硬亲和性实例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义pod-nodeaffinity-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-require-nodeaffinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">bar</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><h4 id="软亲和性实例"><a href="#软亲和性实例" class="headerlink" title="软亲和性实例"></a>软亲和性实例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义pod-nodeaffinity-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-prefered-nodeaffinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">preference:</span></span><br><span class="line">  <span class="attr">matchExpressions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">zone</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">    <span class="attr">values:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bar</span></span><br><span class="line"><span class="attr">weight:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><h3 id="Pod亲和性"><a href="#Pod亲和性" class="headerlink" title="Pod亲和性"></a>Pod亲和性</h3><p>pod之间也需要亲和性调度。比如NMP架构，NMP三种服务的pod放在一个物理主机或者同一个机柜的物理主机上，那么他们的通信效率肯定是很高的。</p><p>调度器把第一个Pod放到任意位置，然后和该Pod有亲和或反亲和关系的Pod根据该动态完成位置编排，这就是Pod亲和性和反亲和性调度的作用。Pod的亲和性定义也存在硬亲和性和软亲和性的区别，其约束的意义和节点亲和性类似。</p><p>另外，对于同一位置的理解是根据不同的。例如可以根据主机名来作为同一位置的标准，那么具有亲和性的pod都会被调度到同一主机上；再比如将同一机架上的主机打上标签标明是同一组主机，亲和性以该标签为标准，那么pod调度时就会被调度到一组主机的一个上面。</p><h4 id="硬亲和实例"><a href="#硬亲和实例" class="headerlink" title="硬亲和实例"></a>硬亲和实例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-first</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-second</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx-back</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend-back</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffninity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIngnoreDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">      <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">labelSelector</span> <span class="string">&lt;Object&gt;：指明与哪些pod亲和</span></span><br><span class="line"><span class="string">namespace</span> <span class="string">&lt;[]string&gt;：指明labelSelector选中的pod匹配哪个名称空间的pod，不指默认该pod当前名称空间</span></span><br><span class="line"><span class="string">topologyKey</span> <span class="string">&lt;string&gt;：用于定义位置标准，kubernetes.io/hostname表示以node节点的主机名作为位置判断</span></span><br></pre></td></tr></table></figure><h4 id="软亲和实例"><a href="#软亲和实例" class="headerlink" title="软亲和实例"></a>软亲和实例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#大体上与节点亲和一样</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-first-prefer</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-second-prefer</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx-back</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend-back</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffninity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">        <span class="attr">labelSelector:</span></span><br><span class="line">               <span class="attr">matchExpressions:</span></span><br><span class="line">               <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                 <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                 <span class="attr">values:</span></span><br><span class="line">                 <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">         <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure><h4 id="反亲和实例"><a href="#反亲和实例" class="headerlink" title="反亲和实例"></a>反亲和实例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给node节点打标，使得第一个pod配到一个node后由于反亲和，另一个pod必然处于pending状态</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">nodes</span> <span class="string">node1.day.com</span> <span class="string">zone=foo</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">nodes</span> <span class="string">node2.day.com</span> <span class="string">zone=foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资源</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-first</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-second</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">myapp:</span> <span class="string">nginx-back</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend-back</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAntiAffninity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIngnoreDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">      <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">in</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">topologyKey:</span> <span class="string">zone</span></span><br></pre></td></tr></table></figure><h3 id="污点调度"><a href="#污点调度" class="headerlink" title="污点调度"></a>污点调度</h3><p>污点是定义在node上的一组键值型数据，用来让node拒绝将Pod调度到该节点上，除非该Pod对象具有容纳节点污点的容忍度。而容忍度是定义在Pod对象上的键值型数据，用来配置让Pod对象可以容忍节点的污点。</p><p>前面的节点选择器和节点亲和性的调度方式都是通过在Pod对象上添加标签选择器来完成对特定类型node标签的匹配，实现的是Pod选择节点的方式。而污点和容忍度则是通过对node添加污点信息来控制Pod对象的调度结果，让node拥有了控制哪种Pod对象可以调度到该节点上的 一种方式。</p><p>Kubernetes使用PodToleratesNodeTaints预选策略和TaintTolerationPriority优选函数来完成这种调度方式。</p><h4 id="定义污点"><a href="#定义污点" class="headerlink" title="定义污点"></a>定义污点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#node.spec.taints.effect定义node对pod的排斥效果</span></span><br><span class="line">NoSchedule：只影响调度过程，对已有的pod不产生影响</span><br><span class="line">NoExecute：既影响调度过程也影响现存的pod对象，不容忍的pod会被驱逐</span><br><span class="line">PreferNoSchedule：程度比第一个轻，无其他可调度的node时可以调度到该node</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义taint格式</span></span><br><span class="line">key=value:effect</span><br><span class="line">表示对于该键值的污点如果pod不能容忍，那么执行effect相对应的排斥效果</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令</span></span><br><span class="line">kubectl taint node node1.dqy.com node-type=production:NoSchedule</span><br></pre></td></tr></table></figure><h4 id="定义容忍度"><a href="#定义容忍度" class="headerlink" title="定义容忍度"></a>定义容忍度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Equal</span></span><br><span class="line">tolerations:</span><br><span class="line">- key: <span class="string">"node-type"</span></span><br><span class="line">  operator: <span class="string">"Equal"</span></span><br><span class="line">  value: <span class="string">"production"</span></span><br><span class="line">  effect: <span class="string">"Noexecute"</span></span><br><span class="line">  tolerationSeconds: 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#Exists</span></span><br><span class="line">tolerations: </span><br><span class="line">- key: <span class="string">"node-type"</span> </span><br><span class="line">  operator: <span class="string">"Exists"</span></span><br><span class="line">  value:<span class="string">""</span></span><br><span class="line">  effect: <span class="string">"Noexecute"</span> </span><br><span class="line">  tolerationSeconds: 3600</span><br><span class="line"></span><br><span class="line"><span class="comment">#operator字段选项</span></span><br><span class="line">Equal：等值比较，表示容忍度和污点必须在key、value、effect三者之上完全匹配。</span><br><span class="line">Exists：存在性判断，表示二者的key和effect必须完全匹配，而容忍度中的value字段使用空值。</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">第一个使用Equal操作模式，表示node上的node-type字段的值为production，且Noexecute的污点可以容忍</span><br><span class="line">第二个使用Exists操作模式，表示node上只要存在node-type字段且Noexecute的污点，可以容忍</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;当APIServer收到新的pod创建请求时会根据请求的资源清单使用schedule进行node节点调度。调度分为三个阶段：节点预选(Predicate)-&amp;gt;节点优选(Priority)-&amp;gt;节点选定(Select)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点预选：基于一系列的预选规则对每个节点进行检查，将那些不符合条件的节点过滤(如端口冲突、资源不足等)，从而完成节点的预选&lt;/li&gt;
&lt;li&gt;节点优选：对预选出的节点进行优先级排序，以便选出最合适运行Pod对象的节点&lt;/li&gt;
&lt;li&gt;节点选定：从优先级排序结果中挑选出优先级最高的节点运行Pod，当这类节点多于1个时，则进行随机选择&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="污点" scheme="http://yoursite.com/tags/%E6%B1%A1%E7%82%B9/"/>
    
      <category term="容忍度" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%BF%8D%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>k8s(6)-网络配置</title>
    <link href="http://yoursite.com/2020/02/06/k8s-6-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/02/06/k8s-6-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-06T06:36:03.000Z</published>
    <updated>2020-02-06T06:41:22.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><ul><li>容器间通信：同一个pod内的多个容器间的通信，使用lo接口</li><li>pod间通信：overlay叠加网络实现。直达，不要经过NAT转换</li><li>pod与service通信：由iptables规则或者lvs规则实现。直达，不要经过NAT转换</li><li>service与集群外部通信：配置nodePort或者ingress<a id="more"></a><h4 id="实现格式"><a href="#实现格式" class="headerlink" title="实现格式"></a>实现格式</h4></li></ul><p>k8s集群自身不提供网络解决方案，它支持CNI接口的插件来解决。CNI的主要核心是：在创建容器时，先创建好网络名称空间（netns），然后调用CNI插件为这个netns配置网络，最后在启动容器内的进程。每次Pod被初始化或删除，kubelet都会调用默认的CNI插件去创建一个虚拟设备接口附加到相关的底层网络，为Pod去配置IP地址、路由信息并映射到Pod对象的网络名称空间。网络插件存放在/etc/cni/net.d目录下，由kubelet加载该目录下的网络插件，根据其type属性到/opt/cni/bin中查找相关的插件二进制文件，由这些二进制文件和配置文件代为分配网络地址、创建等信息。常见的插件有：flannel、calico、canel等。</p><ul><li>Flannel：为Kubernetes提供叠加网络的网络插件，基于TUN/TAP隧道技术，使用UDP封装IP报文进行创建叠 加网络，借助etcd维护网络的分配情况，缺点：无法支持网络策略访问控制。</li><li>Calico：基于BGP的三层网络插件，也支持网络策略进而实现网络的访问控制；它在每台主机上都运行一个虚拟路由，利用Linux内核转发网络数据包，并借助iptables实现防火墙功能。实际上Calico最后的实现就是将每台主机都变成了一台路由器，将各个网络进行连接起来，实现跨主机通信的功能。</li><li>Canal：由Flannel和Calico联合发布的一个统一网络插件，提供CNI网络插件，并支持网络策略实现。</li><li>其他的还包括Weave Net、Contiv、OpenContrail、Romana、NSX-T、kube-router等等。而Flannel和Calico是目前最流行的选择方案。</li></ul><h3 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h3><p>flannel使用叠加式网络进行pod间通信，通过节点上的flannel.1网卡实现隧道来通信。当前节点有pod时会创建一个eni接口的网卡，它的地址是与flannel.1网卡同网络，用于隧道通信。flannel作为pod以daemonset的方式工作在各个具有kubelet的node节点上，用于kubelet调用flannel进行网络部署。因此，有多少node节点(拥有kubelet)就有多少个flannel pod。</p><p>创建flannel的过程在第一章讲过，此处不再赘述。</p><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看配置信息</span></span><br><span class="line">kubectl get configmap kube-flannel-cfg -o yaml -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment">#常见参数</span></span><br><span class="line">Network：flannel使用的CIDR格式的网络地址，用于为Pod配置网络功能</span><br><span class="line">例如Network：10.244.0.0/16，代表master：10.244.0.0/24、node1：10.244.1.0/24以此类推</span><br><span class="line">Subnetlen：把network切分子网供个节点使用时，使用多长的掩码进行切分，默认为24位，表示每个node可以创建256个pod</span><br><span class="line">SubnetMin：子网起始</span><br><span class="line">SubnetMax：子网最大</span><br><span class="line">Backend：指明pod间通信方式vxlan、host-gw、udp</span><br></pre></td></tr></table></figure><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看master网卡，会发现几个特殊的，有flannel、cni和一些veth开头的网卡</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看master路由信息</span></span><br><span class="line">ip route show</span><br><span class="line">default via 192.168.163.2 dev ens33 proto dhcp metric 100 </span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1 </span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink </span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink </span><br><span class="line">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 </span><br><span class="line">192.168.163.0/24 dev ens33 proto kernel scope link src 192.168.163.132 metric 100</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看cni0网卡的虚拟网桥信息</span></span><br><span class="line">brctl show cni0</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">cni08000.eae2fc220dbanoveth2bdcb591</span><br><span class="line">veth3648ee64</span><br><span class="line">veth6cca7eb2</span><br><span class="line">veth899cf515</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">cni为flannel创建的虚拟网桥，用于pod本地通信使用</span><br><span class="line">flannel为每个Pod创建一对veth虚拟设备，一端放在容器接口上，一端放在cni0桥上(和docker一样)</span><br><span class="line">上面这些路由信息可以看出，发送到主机10.244.2.0/24及10.244.1.0/24网段的报文都通过flannel.1网卡接口进行隧道封装(VxLAN协议)</span><br></pre></td></tr></table></figure><h4 id="VxLAN"><a href="#VxLAN" class="headerlink" title="VxLAN"></a>VxLAN</h4><p>默认情况下使用VxLAN协议实现隧道方式进行不通过主机间pod通信，其报文格式如下图：</p><p><img src="/2020/02/06/k8s-6-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/k8s-VxLAN.png" alt></p><p>它支持两种方式：</p><ul><li>第一种是当运行pod的node节点处于 同一网段中时使用Directrouting方式进行通信，即将该pod的物理主机网卡当作网关，发往其他主机的报文通过网卡查路由表进行转发；这种方式传输效率很高，类似host-gw模式</li><li>第二种是当pod处于不同网段时，使用隧道进行叠加式网络通信，其中隧道是以太网帧的二层隧道。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认为VxLAN隧道模式，此处演示修改为Directrouting模式</span></span><br><span class="line"><span class="comment">#修改configmap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"Network"</span>: <span class="string">"10.244.0.0/16"</span>,   <span class="comment">#默认网段</span></span><br><span class="line">    <span class="string">"Backend"</span>: &#123;</span><br><span class="line"><span class="string">"Type"</span>: <span class="string">"vxlan"</span>,</span><br><span class="line"><span class="string">"Directrouting"</span>: <span class="literal">true</span>   <span class="comment">#增加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新应用</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">修改flannel时使用edit不能生效，需要重新部署</span><br></pre></td></tr></table></figure><h4 id="host-gw"><a href="#host-gw" class="headerlink" title="host-gw"></a>host-gw</h4><p>该方式类似于VxLAN的Directrouting模式，即不同node节点处于同一网段中时，其上的pod直接使用node物理网卡进行通信，网卡上维护路由表用于路由转发，因此必须处于同一网段，否则可能会被路由转发到其他主机。</p><p>具体配置只需要改Backend字段的type字段即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"Network"</span>: <span class="string">"10.244.0.0/16"</span>,   <span class="comment">#默认网段</span></span><br><span class="line">    <span class="string">"Backend"</span>: &#123;</span><br><span class="line"><span class="string">"Type"</span>: <span class="string">"host-gw"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h3><p>上文提到的Flannel只是一款网络地址分配的插件，它不具备网络策略功能。即在Flannel插件工作下，整个网络各个pod之间都可以通信，它不具备隔离某些pod间通信的功能。因此为了实现网络策略功能，通常使用Calico实现网络策略功能，而flannel实现地址分配功能，二者结合就变成了Canal。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署RBAC</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.2/getting-started/kubernetes/installation/hosted/canal/rbac.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署canal</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.2/getting-started/kubernetes/installation/hosted/canal/canal.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">Canal作为DaemonSet部署到每个节点，属于kube-system这个名称空间</span><br></pre></td></tr></table></figure><h4 id="配置策略"><a href="#配置策略" class="headerlink" title="配置策略"></a>配置策略</h4><p><img src="/2020/02/06/k8s-6-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/k8s-canal.png" alt></p><p>在Kubernetes系统中，报文的流入和流出的核心组件是Pod资源，它们也是网络策略功能的主要应用对象。NetworkPolicy对象通过podSelector选择 一组Pod资源作为控制对象。NetworkPolicy是定义在一组Pod资源之上用于管理入站(ingress)流量，或出站(egress)流量的一组规则，有可以是出入站规则一起生效，规则的生效模式通常由spec.policyTypes进行定义。</p><p>默认情况下，Pod对象的流量控制是为空的，报文可以自由出入。在附加网络策略之后，Pod对象会因为NetworkPolicy而被隔离，一旦名称空间中有任何NetworkPolicy对象匹配了某特定的Pod对象，则该Pod将拒绝NetworkPolicy规则中不允许的所有连接请求，但是那些未被匹配到的Pod对象依旧可以接受所有流量。</p><p>就特定的Pod集合来说，入站和出站流量默认是放行状态，除非有规则可以进行匹配。还有一点需要注意的是，在networkpolicy.spec.policyTypes中指定了生效的规则类型，但是在networkpolicy.spec字段中嵌套定义了没有任何规则的Ingress或Egress时，则表示拒绝入站或出站的一切流量。即默认的ingress和egress规则都是拒绝一切。</p><h4 id="资源定义"><a href="#资源定义" class="headerlink" title="资源定义"></a>资源定义</h4><p>networkpolicy自身就是k8s集群的资源对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#spec属性</span></span><br><span class="line">egress &lt;[]Object&gt;<span class="comment">#定义出站规则</span></span><br><span class="line">ports &lt;[]Object&gt;<span class="comment">#定义目标端口</span></span><br><span class="line">port &lt;string&gt;<span class="comment">#端口</span></span><br><span class="line">protocol &lt;string&gt;<span class="comment">#协议</span></span><br><span class="line">to &lt;[]Object&gt;<span class="comment">#定义目标地址</span></span><br><span class="line">ipBlock &lt;Object&gt;<span class="comment">#目标为ip地址范围或主机的pod</span></span><br><span class="line">namespaceSelector<span class="comment">#目标为名称空间内所有pod</span></span><br><span class="line">podSelector &lt;Object&gt;<span class="comment">#目标为一组pod</span></span><br><span class="line"></span><br><span class="line">ingress &lt;[]Object&gt;<span class="comment">#定义入站规则，与egress相似</span></span><br><span class="line">from &lt;[]Object&gt;</span><br><span class="line">ports &lt;[]Object&gt;</span><br><span class="line">podSelector &lt;Object&gt;<span class="comment">#定义管理的pod</span></span><br><span class="line">policyTypes &lt;[]string&gt;<span class="comment">#定义选择的策略类型</span></span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>设置两个名称空间，一个为dev，一个为prod。下面进行不同名称空间访问的控制</p><p>创建名称空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace dev</span><br><span class="line">kubectl create namespace prod</span><br></pre></td></tr></table></figure><p>定义networkpolicy规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">deny-all-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">policyTypes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#应用于dev名称空间</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">ingress-def.yaml</span> <span class="string">-n</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">podSelector为空表示选择所有名称空间中的pod</span></span><br><span class="line"><span class="string">policyTypes选择了ingress而没定义ingress表示使用ingress默认规则，即拒绝所有请求</span></span><br><span class="line"><span class="string">如果明确定义ingress但内容为空，则表示允许全部，如下所示</span></span><br><span class="line"><span class="attr">ingree:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>在dev名称空间下创建pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#应用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">pod-a.yaml</span> <span class="string">-n</span> <span class="string">dev</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">pod-a.yaml</span> <span class="string">-n</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">上述创建好后可以使用master访问prod名称空间的prod，但无法访问dev名称空间的pod</span></span><br></pre></td></tr></table></figure><p>修改dev名称空间下的ingress规则，允许外部访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将pod1打标签，用于被ingress的podSelector控制</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">pods</span> <span class="string">pod1</span> <span class="string">app=nginx</span> <span class="string">-n</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">allow-nginx-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">podSelector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">  <span class="attr">cidr:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.2</span><span class="string">/32</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">上述ingress规则表示允许10.244.0.0/16网段的主机且标签app为nginx访问，但不允许10.244.1.2/32访问，对外开放端口为tcp/80，tcp/443</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; class=&quot;headerlink&quot; title=&quot;通信方式&quot;&gt;&lt;/a&gt;通信方式&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;容器间通信：同一个pod内的多个容器间的通信，使用lo接口&lt;/li&gt;
&lt;li&gt;pod间通信：overlay叠加网络实现。直达，不要经过NAT转换&lt;/li&gt;
&lt;li&gt;pod与service通信：由iptables规则或者lvs规则实现。直达，不要经过NAT转换&lt;/li&gt;
&lt;li&gt;service与集群外部通信：配置nodePort或者ingress&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="VxLAN" scheme="http://yoursite.com/tags/VxLAN/"/>
    
      <category term="flannel" scheme="http://yoursite.com/tags/flannel/"/>
    
      <category term="canal" scheme="http://yoursite.com/tags/canal/"/>
    
  </entry>
  
  <entry>
    <title>k8s(5)-认证</title>
    <link href="http://yoursite.com/2020/02/05/k8s-5-%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2020/02/05/k8s-5-%E8%AE%A4%E8%AF%81/</id>
    <published>2020-02-05T03:35:24.000Z</published>
    <updated>2020-02-05T03:39:49.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在与APIServer交互时需要做认证、权限检查、准入控制来确保集群资源安全。与APIServer交互的对象有两种，一种是工作在集群外部的用户使用kubectl来访问APIServer对外端口，另一种是集群内部pod节点通过service访问。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该service就是集群内pod节点访问APIServer的service</span></span><br><span class="line">kubectl get service kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细信息，可以看到master的地址是该service的Endpoints地址</span></span><br><span class="line">kubectl describe service kubernetes</span><br></pre></td></tr></table></figure><p>每个pod或多或少都需要和APIServer进行通信，因此在其创建时都会默认设置一个存储卷，该卷是一个token信息，它以存储卷的形式挂载到pod的容器内，使得该容器能够使用该token来与APIServer通信时进行认证。</p><h4 id="资源请求"><a href="#资源请求" class="headerlink" title="资源请求"></a>资源请求</h4><p>在整个k8s集群的资源请求中，kubectl命令对资源的操作实际是对http的访问路径，可以通过本地代理kubectl访问集群来实现http的资源请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源请求格式</span></span><br><span class="line">/apis/&lt;GROUP&gt;/&lt;VERSION&gt;/namespaces/&lt;NAMESPACE_NAME&gt;/&lt;KIND&gt;[/OBJECT_ID]</span><br><span class="line"></span><br><span class="line"><span class="comment">#代理，使用curl命令访问本地8080端口实现对集群资源的访问</span></span><br><span class="line">kubectl proxy --port=8080</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问路径</span></span><br><span class="line">http://ip:port/apis/apps/namespaces/default/deployments/nginx-deploy</span><br><span class="line">apis整个资源的访问入口</span><br><span class="line">apps是apis的一个组</span><br><span class="line">因此，之前使用kubectl命令对各种资源的操作实际就是对资源路径的操作</span><br></pre></td></tr></table></figure><h4 id="请求动作"><a href="#请求动作" class="headerlink" title="请求动作"></a>请求动作</h4><p>http请求需要转换为对API对象的请求来进行访问</p><p>http：get、post、put、delete</p><p>API request：get、list、create、update、patch、watch、proxy、redirect、delete、deletecollection</p><h4 id="访问用户"><a href="#访问用户" class="headerlink" title="访问用户"></a>访问用户</h4><p>整个k8s集群中访问APIServer的用户有两类，一类为Useraccount，另一类为Serviceaccount，区别如下：</p><ul><li>User account是为人设计的，而service account则是为Pod中的进程调用Kubernetes API而设计；</li><li>User account是跨namespace的，而service account则是仅局限它所在的namespace；</li><li>每个namespace都会自动创建一个default service account；</li><li>Token controller检测service account的创建，并为它们创建secret</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>APIServer是整个访问请求进入的网关接口，请求过程中认证用于实现身份识别，授权用于实现权限检查，准入控制用于补充权限检查功能，一般在创建、修改、删除、代理等情况下做补充。</p><h3 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h3><p>它是一个k8s对象资源。当集群内pod节点与APIServer交互时，需要pod提供认证信息，该信息定义在pod上的serviceaccount字段中。serviceaccount是仅局限它所在的namespace中有意义的，且每个namespace都会自动创建一个default service account，当创建 pod 的时候，如果没有指定一个 service account，系统会自动在与该pod 相同的 namespace 下为其指派一个default service account。而pod和APIserver之间进行通信的账号，称为serviceAccountName。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看默认sa，其名称为default</span></span><br><span class="line">kubectl get sa</span><br></pre></td></tr></table></figure><p>默认的service account 仅仅只能获取当前Pod自身的相关属性，无法观察到其他名称空间Pod的相关属性信息。如果想要扩展Pod，假设有一个Pod需要用于管理其他Pod或者是其他资源对象，是无法通过自身的名称空间的serviceaccount进行获取其他Pod的相关属性信息的，此时就需要进行手动创建一个serviceaccount，并在创建Pod时进行定义。</p><p>自定义serviceaccount</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl create serviceacount admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">创建后会在sa里新建一个admin名称的sa；在secret中也会创建一个admin名称的token做认证使用</span><br></pre></td></tr></table></figure><p>创建pod并设置其serviceAccountName</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-sa-demo</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">serviceAccountName:</span> <span class="string">admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">serviceAccountName用于与已创建的sa绑定</span></span><br></pre></td></tr></table></figure><h3 id="认证配置文件"><a href="#认证配置文件" class="headerlink" title="认证配置文件"></a>认证配置文件</h3><p>各个APIServer客户端与APIServer通信时不仅可以使用上述的Serviceaccount来进行认证，还可以使用配置文件进行认证</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看配置文件</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">config</span> <span class="string">view</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#详细信息</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">DATA+OMITTED</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://192.168.163.132:6443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-admin@kubernetes</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-admin@kubernetes</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">clusters表示集群列表，可以定义多个集群从而控制多个集群</span></span><br><span class="line"><span class="string">users表示用户列表</span></span><br><span class="line"><span class="string">contexts表示上下文列表，用于指明用哪个user访问哪个cluster</span></span><br><span class="line"><span class="string">current-context：表示当前使用哪个user访问哪个cluster</span></span><br></pre></td></tr></table></figure><p>在/etc/kubernetes/pki文件中都是整个k8s集群的ca证书和密钥，其中有ca.crt证书用于签署哪些用户可以连入APIServer中。下面演示自建账户并使用APIServer的ca签署流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成私钥</span></span><br><span class="line">(<span class="built_in">umask</span> 077;openssl genrsa -out dqy.key 2048)</span><br><span class="line"><span class="comment">#生成证书，且由ca.crt签署</span></span><br><span class="line"><span class="comment">#生成证书申请请求</span></span><br><span class="line">openssl req -new -key dqy.key -out dqy.csr -subj <span class="string">"/CN=dqy"</span></span><br><span class="line"><span class="comment">#用ca.crt签署</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> dqy.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -out dqy.crt -days 365</span><br><span class="line"><span class="comment">#查看证书内容</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> dqy.crt -text -noout</span><br><span class="line"><span class="comment">#创建集群用户</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials dqy --client-certificate=./dqy.crt --client-key=./dqy.key --embed-certs=<span class="literal">true</span></span><br><span class="line"><span class="comment">#设置上下文</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context dqy@kubernetes --cluster=kubernetes --user=dqy</span><br><span class="line"><span class="comment">#设置当前上下文</span></span><br><span class="line">kubectl config use-context dqy@kubernetes</span><br><span class="line"><span class="comment">#新增集群，使用新增集群的ca证书来进行认证</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-cluster e2e --server=<span class="string">"https://192.168.163.132:6443"</span> --certificate-authority=~/.kube/e2e/kubernetes.ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">CN的值就是你的需要访问APIServer的用户账号名</span><br><span class="line">CAcreateserial表示自建序列号</span><br><span class="line">text表示以文本格式不适用base64编码</span><br><span class="line">certificate-authority指明需要的集群ca</span><br><span class="line">上述创建的用户没有管理员权限，可以使用RBAC进行授权</span><br></pre></td></tr></table></figure><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>Role-based AC，即基于角色的访问控制。让一个用户(user)扮演一个角色(Role)，这个用户就拥有了该角色的权限，并且后续的权限授予都只针对角色而不是用户来进行。主要用于为上文中创建出用户的权限进行授予。</p><p><img src="/2020/02/05/k8s-5-%E8%AE%A4%E8%AF%81/k8s-RBAC.png" alt></p><p>在集群中的所有操作都是在某个对象上施加的某种行为，一个对象上许可的行为组合起来就叫做许可权限，可以在role上授予该role具有某些许可权限。首先定义role，role中需要定义operations和object。之后使用rolebinding将role绑定到user(user account、service account)上实现名称空间级别的授权。</p><p><img src="/2020/02/05/k8s-5-%E8%AE%A4%E8%AF%81/k8s-rolebind.png" alt></p><p>在k8s中有两类资源，一类是名称空间级资源，一类是集群级资源。</p><p>在名称空间A中定义一个角色role，将User1和role进行rolebinding绑定，这样user1就获得了role上定义的在该<strong>名称空间内</strong>的资源的访问权限。</p><p>在集群定义角色clusterRole，通过clusterRoleBinding将其和User1进行绑定，那么它就拥有<strong>整个集群内</strong>的资源的访问权限。</p><p><strong>注意</strong>，绑定可以跨界。换句话说，可以将user1通过RoleBinding绑定到ClusterRole中，注意虽然此时ClusterRole定义的是整个集群上的权限，但是由于使用NamespaceA中的RoleBinding进行绑定，那么此时User1只拥有该名称空间中的访问权限。(用谁绑定就拥有哪个级别的权限)。该操作适用于为每个名称空间设置一个管理员，如果使用rolebinding绑定role和user，那么需要定义多个role；而此处可以定义一个ClusterRole再使用对应名称空间的RoleBinding来绑定，也可以达到同样的效果。</p><p>上文提到的role、clusterRole、roleBinding、clusterRoleBinding都是k8s资源</p><h4 id="定义role"><a href="#定义role" class="headerlink" title="定义role"></a>定义role</h4><p>创建role</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#干跑模式，可以查看yaml格式</span></span><br><span class="line">kubectl create role pods-reader --verb=get,list,watch --resource=pods --dry-run -o yaml</span><br><span class="line"><span class="comment">#查看创建的role</span></span><br><span class="line">kubectl get role</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">verb：指明资源请求动作</span><br><span class="line">resource：指明资源对象</span><br><span class="line">resource names：具体资源的名称</span><br></pre></td></tr></table></figure><p>创建roleBinding并绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#干跑模式，可以查看yaml格式</span></span><br><span class="line">kubectl create rolebinding dqy-read-pods --role=pods-reader --user=dqy --dry-run -o yaml</span><br><span class="line"><span class="comment">#查看绑定信息</span></span><br><span class="line">kubectl describe rolebinding dqy-read-pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">role：指明role</span><br><span class="line">user：要绑定的用户</span><br></pre></td></tr></table></figure><h4 id="定义clusterrole"><a href="#定义clusterrole" class="headerlink" title="定义clusterrole"></a>定义clusterrole</h4><p>创建clusterRole</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrole cluster-read --verb=get,list,watch --resource=pods -o yaml</span><br></pre></td></tr></table></figure><p>创建clusterRoleBinding并绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#干跑一下看看</span></span><br><span class="line">kubectl create clusterrolebinding dqy-read-all-pods --clusterrole=cluster-read --user=dqy --dry-run -o yaml</span><br></pre></td></tr></table></figure><h4 id="跨界绑定"><a href="#跨界绑定" class="headerlink" title="跨界绑定"></a>跨界绑定</h4><p>使用roleBinding绑定clusterRole，将clusterRole降级为普通role</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#干跑看一下</span></span><br><span class="line">kubectl create rolebinding dqy-read-pods --clusterrole=cluster-read --user=dqy --dry-run -o yaml</span><br></pre></td></tr></table></figure><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc3/aio/deploy/recommended.yaml</span><br><span class="line"><span class="comment">#会创建如下资源</span></span><br><span class="line">namespace/kubernetes-dashboard created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">secret/kubernetes-dashboard-csrf created</span><br><span class="line">secret/kubernetes-dashboard-key-holder created</span><br><span class="line">configmap/kubernetes-dashboard-settings created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/dashboard-metrics-scraper created</span><br><span class="line">deployment.apps/dashboard-metrics-scraper created</span><br><span class="line"></span><br><span class="line"><span class="comment">#将service/kubernetes-dashboard改为nodeport进行集群外访问</span></span><br><span class="line">kubectl patch svc kubernetes-dashboard -n kubernetes-dashboard -p <span class="string">'&#123;"spec":&#123;"type":"NodePort"&#125;&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>部署成功并且暴露service端口后既有如下页面：</p><p><img src="/2020/02/05/k8s-5-%E8%AE%A4%E8%AF%81/k8s-dashboard.png" alt></p><p>认证方式有两种，一种是token认证，一种是Kubeconfig认证</p><h5 id="token认证"><a href="#token认证" class="headerlink" title="token认证"></a>token认证</h5><p>dashboard安装在自建的名称空间kubernetes-dashboard中，如果想要dashboard的pod能够管理整个集群，就需要创建serviceaccount并将其绑定到clusterrole上，其中serviceaccount需要的token认证文件就是这里需要填入的token信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将dashboard自带的serviceaccount和clusterrole进行绑定</span></span><br><span class="line">kubectl create clusterrolebinding dash-role-admin --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取该sa的token信息</span></span><br><span class="line">kubectl describe sa -n kubernetes-dashboard kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment">#从token信息中提取出token</span></span><br><span class="line">kubectl describe secret kubernetes-dashboard-token-wh87j -n kubernetes-dashboard</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6Ik9FeEZPa0pTcnF6Yl9tMzVkQUZRS3lISTdVZjhvTGNGZ0lDdjJtQjRSQzAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZC10b2tlbi13aDg3aiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjA1MDg4YjFhLTExMGEtNGFkNS04ZmQwLWZiYWFhNWM1NmM3OSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDprdWJlcm5ldGVzLWRhc2hib2FyZCJ9.7joqmYOT3AQKtJs8sQVx8mlYcb5Vy4R8NhZDSYGXzOA259DpIvbHeBZBJBi_SBnVsQ_XNZTinC33j8zSwlb5jdlTKBGLoWTdWxbaFgH3GjSXigSS5yq4h-7A-aVj_bjmycejnWDfzOG-vpqlXtmLabUWYCUa2Bihw_TnxTaWqNnNqqVHQ7Gaq8O84fe61W0gMUAWoZ2iQol2raohoEEzMURQceozSa_CaBxZd2X2gztWnBrqsmsG3PorVR-E7wt1bqYkW8OnTXat-T9FNChp3iDP70k-Le1CD7MzvyPE4L2U7MN_vHndRTbw9a9tFHbboO2Rx6qoJokA0hE7BbjdZA</span><br></pre></td></tr></table></figure><h5 id="Kubeconfig认证"><a href="#Kubeconfig认证" class="headerlink" title="Kubeconfig认证"></a>Kubeconfig认证</h5><p>kubeconfig配置文件也可以使用token来认证，将其添加到kubeconfig文件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建serviceaccount并绑定role或者clusterrole，和上面一样，此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加集群</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=<span class="string">"https://192.168.163.132:6443"</span> --embed-certs=<span class="literal">true</span> --kubeconfig=/root/def-ns-admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加token</span></span><br><span class="line">KUBE_ADMIN_TOKEN=`kubectl get secret kubernetes-dashboard-token-wh87j -n kubernetes-dashboard -o jsonpath=&#123;.data.token&#125; | base64 -d`</span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials def-ns-admin --token=<span class="variable">$KUBE_ADMIN_TOKEN</span> --kubeconfig=/root/def-ns-admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加上下文</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context def-ns-admin@kubernetes --cluster=kubernetes --user=def-ns-admin --kubeconfig=/root/def-ns-admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置当前上下文</span></span><br><span class="line">kubectl config use-context def-ns-admin@kubernetes --kubeconfig=/root/def-ns-admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看完整配置文件</span></span><br><span class="line">kubectl config view --kubeconfig=/root/def-ns-admin.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;在与APIServer交互时需要做认证、权限检查、准入控制来确保集群资源安全。与APIServer交互的对象有两种，一种是工作在集群外部的用户使用kubectl来访问APIServer对外端口，另一种是集群内部pod节点通过service访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="认证" scheme="http://yoursite.com/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="dashboard" scheme="http://yoursite.com/tags/dashboard/"/>
    
  </entry>
  
  <entry>
    <title>k8s(4)-存储卷</title>
    <link href="http://yoursite.com/2020/02/03/k8s-4-%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    <id>http://yoursite.com/2020/02/03/k8s-4-%E5%AD%98%E5%82%A8%E5%8D%B7/</id>
    <published>2020-02-03T04:18:18.000Z</published>
    <updated>2020-02-09T11:25:23.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>在docker中就引入了存储卷的概念，它在docker内和物理机做映射使得即使docker容器挂掉数据也保存在其他地方，下次启动docker时数据依然存在。但是在k8s集群体系中，pod作为最小的调度单位(因此存储卷概念是建立在pod之上)，如果pod挂掉还是要被调度器进行调度，那么就有可能调度到其他的node节点上，这样使得docker存储卷的处理方案行不通(因为docker挂掉不会被调度，一直在一个主机上)。上述情况只是pod挂掉就可能会导致pod调度到其他node，那么如果node挂掉情况会更加严重。</p><p>鉴于上述需求，k8s提出了脱离节点存在的存储概念。在此之前，考虑一个问题，为什么pod本身具有存储卷和网络名称空间？这取决于pod基础容器pause，这个容器是执行k8s初始化时拉取的一个容量很小的容器，它不启动，可以理解为它是pod的根，所有pod的网络名称空间等资源分配实际上是分配给pause镜像，在pod中运行的主容器是共享pause的网络名称空间，同理容器挂载存储卷也是挂载pause的存储卷而已。</p><a id="more"></a><p><img src="/2020/02/03/k8s-4-%E5%AD%98%E5%82%A8%E5%8D%B7/k8s-pvc.png" alt></p><p>k8s作为一个集群需要管理多个主机，各个主机的存储系统接口可能不一样，面对这么多的差异性提出了PVC和PV的概念。PVC全称为PersistentVolumeClaim，即持久卷申请，是对多个存储接口的抽象申请。PV全称为PersistentVolume，是分配的真实的存储管理空间。PVC的申请就是对PV进行操作。这里仍然存在一个问题：PV大小如何指定？即如何根据具体需求定制PV大小，虽然可以管理员定义，但是考虑云计算环境的不同用户的不同需求使用管理员手动创建显然不合实际，因此引入StorageClass概念，又叫存储类，它是对PV的抽象。当用户通过PVC申请存储空间时，通过StorageClass分配指定的PV给用户。</p><p>pv和pvc是kubernetes抽象出来的一种存储资源，定义方法与pod等类似。</p><h4 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h4><p>PersistentVolume（PV）是集群中已由管理员配置的一段网络存储。 集群中的资源就像一个节点是一个集群资源。 PV是诸如卷之类的卷插件，但是具有独立于使用PV的任何单个pod的生命周期。</p><h4 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h4><p>PersistentVolumeClaim（PVC）是用户存储的请求。PVC的使用逻辑：在pod中定义一个存储卷（该存储卷类型为PVC），定义的时候直接指定大小，pvc必须与对应的pv建立关系，pvc会根据定义去pv申请，而pv是由存储空间创建出来的。</p><h4 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h4><p>存储类，是对多个存储设备的封装(设备必须支持Restful格式的请求)，也是一个标准k8s的资源。定义存储类后，pvc申请对象不是pv而是存储类，由存储类动态创建出pv来满足申请。主要使用在多个应用场景下，不同的应用对存储性能要求的不同，因此将不同性能的存储设备分组对外提供可以很好的解决这个问题。</p><h4 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h4><p>它是一个k8s资源，作用相当于配置中心的作用。它可以通过挂载到pod上的某个容器内作为该容器进程的配置文件；也可以类似docker的entrypoint脚本一样对容器内的环境变量进行注入从而修改配置文件。总之，configMap实现的就是同一配置多个pod配置文件的功能。</p><h4 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h4><p>它是一个类似configMap的k8s资源，功能实现和configMap一样，不过他是configMap的加密版。configMap采用明文传输，而secret采用base64编码传输(也比较容易反解)。一般密钥使用secret来定义，其它仍然使用configMap。</p><p>常见的secret类型有三种：docker-registry、tls、generic。</p><ul><li>docker-registry：用于创建docker私有仓库的认证</li><li>tls：用于证书私钥等</li><li>generic：其他如mysql认证等</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h4><p>只在节点本地使用，一旦pod被删除该存储卷也被删除，通常用于做临时目录、缓存(将物理机的内存空间作为存储空间)等</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>    <span class="comment">#在容器内定义挂载存储名称和挂载路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data/</span>    <span class="comment">#在容器内定义挂载存储名称和挂载路径</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">['/bin/sh','-c','while</span> <span class="literal">true</span><span class="string">;do</span> <span class="string">echo</span> <span class="string">$(date)</span> <span class="string">&gt;&gt;</span> <span class="string">/data/index.html;sleep</span> <span class="number">2</span><span class="string">;done']</span></span><br><span class="line">  <span class="attr">volumes:</span>  <span class="comment">#定义存储卷</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span>    <span class="comment">#定义存储卷名称  </span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span>  <span class="comment">#定义存储卷类型</span></span><br></pre></td></tr></table></figure><h4 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h4><p>与docker存储卷一样，在物理机找一个目录作为pod的挂载目录，且该目录不能是pod名称空间中的目录，可以实现pod删除时存储卷仍然存在。该存储为node节点级存储，若node挂掉或者pod被调度到其他node上也会丢失数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-vol-hostpath</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/data/pod/volume1</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">type类型可以参考https://kubernetes.io/docs/concepts/storage/volumes#hostpath</span></span><br><span class="line"><span class="string">DirectoryOrCreate：如果目录不存在就创建(物理主机被挂载的目录)</span></span><br><span class="line"><span class="string">FileOrCreate：如果文件不存在就就创建(物理主机被挂载的文件)</span></span><br></pre></td></tr></table></figure><h4 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h4><p>主要解决hostPath存储遇到node节点不同时数据丢失的问题，此处以NFS为例，NFS主机IP为192.168.163.137</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在NFS主机安装nfs，其他主机也要安装否则无法挂载</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nfs和rpcbind服务，rpcbind必须在nfs之前启动</span></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建共享目录</span></span><br><span class="line">mkdir /data/volumes -pv</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑/etc/exports文件，或者编辑/etc/exports.d/下的文件</span></span><br><span class="line">/data/volumes 192.168.163.0/24(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在node1/2主机(192.168.163.135)上挂载，需要提前在/etc/hosts做域名解析</span></span><br><span class="line">mount -t nfs node3:/data/volumes /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出export</span></span><br><span class="line">exportfs -arv</span><br><span class="line">showmount -e</span><br></pre></td></tr></table></figure><p>编写nfs.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-vol-nfs</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.dqy.io</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="定义PVC-PV"><a href="#定义PVC-PV" class="headerlink" title="定义PVC/PV"></a>定义PVC/PV</h4><p>在网络存储基础上构建PV。</p><p>配置nfs存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在nfs上创建多个目录</span></span><br><span class="line">mkdir /data/volumes/v&#123;1,2,3,4,5&#125;</span><br><span class="line"><span class="comment">#导出</span></span><br><span class="line">exportfs -arv</span><br><span class="line">shoumount -e</span><br></pre></td></tr></table></figure><p>定义pv</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pv-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv001</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes/v1</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.day.io</span></span><br><span class="line">    <span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv002</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv002</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes/v2</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.day.io</span></span><br><span class="line">    <span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv003</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes/v3</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.day.io</span></span><br><span class="line">    <span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv004</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv004</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes/v4</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.day.io</span></span><br><span class="line">    <span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">4Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv005</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv005</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/volumes/v5</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">node3.day.io</span></span><br><span class="line">    <span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">pv属于集群级资源，被名称空间共享，不需要指明名称空间</span></span><br><span class="line"><span class="string">pvc属于名称空间级资源，需要指明名称空间</span></span><br><span class="line"><span class="string">更多accessModes见文档https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes</span></span><br></pre></td></tr></table></figure><p>定义PVC和pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">accessModes:</span> <span class="string">["ReadWriteMany"]</span></span><br><span class="line"><span class="attr">resources:</span> </span><br><span class="line"><span class="attr">requests:</span></span><br><span class="line"><span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-vol-pvc</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span><span class="comment">#在容器内定义挂载存储名称和挂载路径</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">persistentVolumeClaim:</span><span class="comment">#绑定哪个pvc</span></span><br><span class="line">  <span class="attr">claimName:</span> <span class="string">mypvc</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">pvc属于名称空间级资源，需要指明名称空间，其名称空间和pod一致</span></span><br><span class="line"><span class="string">pvc定义的accessModes必须是pv的子集，否则无法分配到pv</span></span><br><span class="line"><span class="string">resources定义资源数</span></span><br></pre></td></tr></table></figure><h4 id="定义configMap"><a href="#定义configMap" class="headerlink" title="定义configMap"></a>定义configMap</h4><p>创建configMap资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接在命令行给出键值对</span></span><br><span class="line">kubectl create configmap nginx-config --from-literal=nginx_port=80 --from-literal=server_name=nginx.dqy.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#以文件方式创建www.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">server_name nginx.dqy.com;</span><br><span class="line">listen 80;</span><br><span class="line">root /data/web/html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#将使用文件名作为键，内容作为值</span></span><br><span class="line">kubectl create configmap nginx-www --from-file=./www.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看定义的configMap</span></span><br><span class="line">kubectl get configmap -o yaml</span><br></pre></td></tr></table></figure><p>以环境变量方式注入nginx容器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-cm-1</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NGINX_SERVER_PORT</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">nginx_port</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NGINX_SERVER_NAME</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">server_name</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">configMapKeyRef中name即为存在的已定义的configMap的名称，key即为其内的键名称</span></span><br><span class="line"><span class="string">当镜像运行时即使改变configmap的值镜像内的环境变量也不会改变，因此只在镜像启动时有效</span></span><br></pre></td></tr></table></figure><p>以存储卷方式挂载configmap</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">pod-cm-2</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginxconf</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/etc/nginx/config.d/</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginxconf</span></span><br><span class="line">  <span class="attr">configMap:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">在volumes中定义挂载类型为configMap，name指明已创建的configMap资源</span></span><br><span class="line"><span class="string">修改configMap的值后容器内的值也会改变，需要等待一个随机时间(同步需要时间)，可以理解为链接文件</span></span><br></pre></td></tr></table></figure><h4 id="定义StorageClass"><a href="#定义StorageClass" class="headerlink" title="定义StorageClass"></a>定义StorageClass</h4><p>StorageClass的定义主要包括名称、后端存储的提供者(Provisioner)和后端存储的相关参数配置。StorageClass一旦被创建出来，将无法修改。如需修改，则只能删除原StorageClass的定义重建。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建nfs-client的自动配置程序，根据已经创建好的nfs服务器进行自动创建PV</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">fuseim.pri/ifs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.163</span><span class="number">.137</span>           <span class="comment">#nfs server 地址</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">/data/k8s-volume</span>     <span class="comment">#nfs共享目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.163</span><span class="number">.137</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/data/k8s-volume</span></span><br></pre></td></tr></table></figure><p>定义serviceaccount</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["persistentvolumes"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["persistentvolumeclaims"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">["storage.k8s.io"]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["storageclasses"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["events"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["list",</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">["endpoints"]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">["create",</span> <span class="string">"delete"</span><span class="string">,</span> <span class="string">"get"</span><span class="string">,</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>创建storageclass</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">managed-nfs-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">fuseim.pri/ifs</span> <span class="comment"># or choose another name, must match deployment's env PROVISIONER_NAME'</span></span><br></pre></td></tr></table></figure><p>创建pvc</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-claim</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">volume.beta.kubernetes.io/storage-class:</span> <span class="string">"managed-nfs-storage"</span>    <span class="comment">#storageclass 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span>              <span class="comment">#访问模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1024Mi</span>        <span class="comment">#请求数据大小</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#成功后可以看到自动创建了一个pv给pvc</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;p&gt;在docker中就引入了存储卷的概念，它在docker内和物理机做映射使得即使docker容器挂掉数据也保存在其他地方，下次启动docker时数据依然存在。但是在k8s集群体系中，pod作为最小的调度单位(因此存储卷概念是建立在pod之上)，如果pod挂掉还是要被调度器进行调度，那么就有可能调度到其他的node节点上，这样使得docker存储卷的处理方案行不通(因为docker挂掉不会被调度，一直在一个主机上)。上述情况只是pod挂掉就可能会导致pod调度到其他node，那么如果node挂掉情况会更加严重。&lt;/p&gt;
&lt;p&gt;鉴于上述需求，k8s提出了脱离节点存在的存储概念。在此之前，考虑一个问题，为什么pod本身具有存储卷和网络名称空间？这取决于pod基础容器pause，这个容器是执行k8s初始化时拉取的一个容量很小的容器，它不启动，可以理解为它是pod的根，所有pod的网络名称空间等资源分配实际上是分配给pause镜像，在pod中运行的主容器是共享pause的网络名称空间，同理容器挂载存储卷也是挂载pause的存储卷而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="存储卷" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>nfs各种问题解决</title>
    <link href="http://yoursite.com/2020/02/02/nfs%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/02/02/nfs%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2020-02-02T10:25:38.000Z</published>
    <updated>2020-02-02T10:29:36.940Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.xuebuyuan.com/2158147.html" target="_blank" rel="noopener">https://www.xuebuyuan.com/2158147.html</a></p><p>在配置kubenetes存储卷时遇到nfs配置问题，在网上找到如下解决方案</p><a id="more"></a><h3 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h3><p>mount: 192.168.81.32:/opt failed, reason given by server: Permission denied</p><p>查看配置文件exports,是否为允许挂载的客户。</p><h3 id="error-No-route-to-host"><a href="#error-No-route-to-host" class="headerlink" title="error = No route to host"></a>error = No route to host</h3><p>mount: RPC: Unable to receive; errno = No route to host</p><p>首先看是否在同一网段</p><p>再者输入：</p><p>[root@localhost etc]# service iptables status</p><p>看防火墙是否开启，有则将其关闭</p><p>[root@localhost etc]# service iptables stop</p><p> 注意：但是这样子有时候其实还是有一些问题, 因此我们干脆直接将防火墙关闭掉, 同时关闭selinux</p><h3 id="error-Connection-refused"><a href="#error-Connection-refused" class="headerlink" title="error = Connection refused"></a>error = Connection refused</h3><p>mount: RPC: Unable to receive; errno = Connection refused</p><p>① 首先看nfs服务是否开启，</p><p>② 其次看rpcbind是否开启，</p><p>如果rpcbind没有运行，那在重新开启rpcbind后，要再restart nfs服务，</p><p>因为重启rpcbind已对nfs的一些配置造成影响，需要restart.</p><p>没错，看到这时候，你已经找到问题了，</p><h3 id="not-responding-still-trying"><a href="#not-responding-still-trying" class="headerlink" title="not responding,still trying.."></a>not responding,still trying..</h3><p>有时候传输大文件会出错,</p><p>NFS: server 192.168.81.32 not responding,still trying..</p><p>这个可能是NFS有问题,与RING或buffer的大小有关,</p><p> 问题的原因分析：</p><p>1、NFS 的默认传输协议是 UDP，而PC机与嵌入式系统通过UPD交互时就会出现严重的网卡丢包现象；</p><p>2、server机和目标机网卡传输速率冲突，使得目标机需要大量时间复制大量数据包，其实如果目标机的网卡速率够大，则不用分那么多包，也不会冲突。</p><p>问题的解决方案：</p><p>方法一：</p><p>在客户端改用TCP协议，使用下面的命令，在mount命令中加上参数tcp</p><p>mount -o tcp ,nolock 192.168.14.223:/nfs_root /mnt</p><p>也可这样干：</p><p>跟踪了fs/nfs/nfsroot.c的代码，发现在nfs作为根文件系统时，参数可以直接写在“nfsroot=”后面，每个参数用逗号隔开，如：</p><p>nfsroot=192.168.10.1:/rootfs,proto=tcp,nfsvers=3,nolock</p><p>这样就可以指定nfs使用tcp协议</p><p>方法二：</p><p>指定传输速率（限定传输时一次读写的数据大小）</p><p>#mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.14.223:/nfs_root /mnt</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://www.xuebuyuan.com/2158147.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.xuebuyuan.com/2158147.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在配置kubenetes存储卷时遇到nfs配置问题，在网上找到如下解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="疑难杂症" scheme="http://yoursite.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="nfs" scheme="http://yoursite.com/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>k8s(3)-ingress详解</title>
    <link href="http://yoursite.com/2020/02/01/k8s-3-ingress%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/01/k8s-3-ingress%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-01T09:40:41.000Z</published>
    <updated>2020-02-02T10:27:17.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当nginx实现七层负载均衡时通过upstream反向代理多个后端主机。但在k8s集群中，使用nginx反代时如果后端新增加pod组就需要通过修改nginx配置文件来新增upstream，但在k8s种修改nginx不方便，不能直接修改配置文件，由此引入ingress。ingress包括如下组件：</p><a id="more"></a><ul><li>ingress对象：使用yaml格式定义不同的nginx配置文件。</li><li>ingress controller：用于管理ingress对象，当ingress对象变化时自动读取并生成对应的nginx配置并重新加载nginx服务。</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/2020/02/01/k8s-3-ingress%E8%AF%A6%E8%A7%A3/k8s-ingress.png" alt></p><p>用户请求经由外部负载均衡器调度到集群内部的service然后访问IngressController，它根据ingress定义的规则从而访问后端的pod。注意后端的pod也是根据ingress定义来分组，它通过一个Service来分组，该Service只用于标记哪些pod属于同一组，不起到调度作用。</p><p>其实，IngressController可以不定义于某个Service后，可以采用共享主机网络名称空间的方式(定义hostnetwork)，定义成DaemonSet运行于指定几个主机上(用污点实现)，这样也可以实现七层负载均衡调度。</p><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><p>安装ingress-controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建名称空间</span></span><br><span class="line">kubectl create namespace ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署ingressController</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.28.0/deploy/static/mandatory.yaml</span><br></pre></td></tr></table></figure><p>配置ingress-nginx</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看开放端口,80和443端口都有相应的映射</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">describe</span> <span class="string">service</span> <span class="string">ingress-nginx</span> <span class="string">-n</span> <span class="string">ingress-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">此处需要使用nodeport来暴露端口，或者将ingress-controller配置为DaemonSet，并共享物理主机网络配置也可以实现类似功能</span></span><br><span class="line"><span class="string">注意名称空间是ingress-nginx</span></span><br><span class="line"><span class="string">targetPort是容器端口</span></span><br><span class="line"><span class="string">port是service端口</span></span><br></pre></td></tr></table></figure><p>定义service，该service负责标记两个后端web服务器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此处直接expose暴露</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">expose</span> <span class="string">deployment</span> <span class="string">nginx-deploy</span> <span class="string">--name=nginx</span> <span class="string">--port=80</span> <span class="string">--target-port=80</span> <span class="string">--protocol=TCP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">这里可以使用上面这种直接暴露的方法，也可以在pod控制器的yaml中同时定义一个service，如下：</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">            <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">            <span class="attr">labels:</span></span><br><span class="line">                <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">                <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">              <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">              <span class="attr">ports:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">                <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>定义ingress文件规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">annotations:</span> </span><br><span class="line"><span class="attr">kubenetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.dqy.com</span></span><br><span class="line">  <span class="attr">http:</span> </span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">path:</span></span><br><span class="line">    <span class="attr">backend:</span> </span><br><span class="line">      <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">该ingress的namespace必须与要发布的service(上面那个)处在同一namespace中</span></span><br><span class="line"><span class="string">annotations的作用是表示此处使用nginx作为反代，必须要设置</span></span><br><span class="line"><span class="string">rules下的host指定为域名时必须能解析到之前定义的NodePort上，即ingress-nginx上</span></span><br><span class="line"><span class="string">backend用来定义后端相关信息，serviceName就是代理后端2个web主机的service的名称</span></span><br><span class="line"><span class="string">path默认不写代表/</span></span><br></pre></td></tr></table></figure><p>至此，整个nginx七层代理就搭好了，不出意外的话在物理主机上可以使用nginx.dqy.com来进行访问，注意要指定Nodeport暴露的端口号，以及定义好hosts文件进行域名解析。另外此处定义虚拟主机的host为nginx.dqy.com就必须使用该域名来访问，不能使用其ip地址访问。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>上述只能实现http访问，这里拓展一下https的实现。</p><p>为了方便就本地自签证书，先生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out tls.key 2048</span><br></pre></td></tr></table></figure><p>生成自签证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key tls.key -out tls.crt -subj /C=CN/ST=Huaian/L=Huaian/O=Linux/CN=nginx.dqy.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">CN一定要设置为要访问的域名</span><br></pre></td></tr></table></figure><p>将crt证书转换成secret对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret tls nginx-ingress-secret --cert=tls.crt --key=tls.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">nginx-ingress-secret是一个名称可以随意</span><br><span class="line">指明证书和密钥</span><br></pre></td></tr></table></figure><p>编写ingress-tls.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ingress-tls</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">annotations:</span> </span><br><span class="line">        <span class="attr">kubenetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nginx.dqy.com</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">nginx-ingress-secret</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.dqy.com</span></span><br><span class="line">      <span class="attr">http:</span> </span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span></span><br><span class="line">          <span class="attr">backend:</span> </span><br><span class="line">            <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">            <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">ingress-tls.yaml</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">定义tls字段时host主机可以有多个</span></span><br><span class="line"><span class="string">secretName就是创建的secret</span></span><br></pre></td></tr></table></figure><p>至此就可以使用https端口访问了，注意要在地址前手动添加https协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;当nginx实现七层负载均衡时通过upstream反向代理多个后端主机。但在k8s集群中，使用nginx反代时如果后端新增加pod组就需要通过修改nginx配置文件来新增upstream，但在k8s种修改nginx不方便，不能直接修改配置文件，由此引入ingress。ingress包括如下组件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="ingress" scheme="http://yoursite.com/tags/ingress/"/>
    
  </entry>
  
  <entry>
    <title>k8s(2)-pod和service</title>
    <link href="http://yoursite.com/2020/02/01/k8s-2-pod%E5%92%8Cservice/"/>
    <id>http://yoursite.com/2020/02/01/k8s-2-pod%E5%92%8Cservice/</id>
    <published>2020-02-01T09:37:24.000Z</published>
    <updated>2020-02-03T04:23:01.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p>kubernetes使用REST格式的API将各种操作对象当作资源来管理。常见资源对象如下：</p><ul><li><p>workload：工作负载型资源对象，主要运行应用程序对外提供服务；如pod、deployment、statefileset等</p></li><li><p>服务发现和负载均衡有关：service、ingress等</p></li><li><p>配置与存储相关：volume、CSI第三方存储卷、configmap、secret等</p></li><li><p>集群级资源：名称空间、node、role、cluster role等</p></li><li><p>元数据型资源：HPA、podtemplate、limitrange</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod资源清单查看，以yaml格式查看指定pod的资源配置文件</span></span><br><span class="line">kubectl get pod nginx-xxxx -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件</span></span><br><span class="line">apiVersion：api群组和版本，一般为group/version，group省略则为core组；使用如下命令可以获取</span><br><span class="line">kubectl api-version</span><br><span class="line">kind：资源类别，就是上文指定的资源类别</span><br><span class="line">metadata：元数据</span><br><span class="line">name：pod名称</span><br><span class="line">namespace：名称空间</span><br><span class="line">labels：标签</span><br><span class="line">annotations：资源注解</span><br><span class="line">spec：规格，定义对象满足哪些特性，是用户定义的目标状态；容器、容忍度等</span><br><span class="line">stats：当前资源的当前状态，当前状态与目标状态不同时，当前状态需要向期望状态转变</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看某个资源如何定义，可以逐级查看</span></span><br><span class="line">kubectl explain pod.metadata</span><br></pre></td></tr></table></figure></li></ul><p>资源清单文件实例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="comment">#containers内容为列表，因此需要使用- name这种格式来定义；可以多次定义</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">    <span class="attr">imagePullPolocy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="comment">#替换busybox容器默认启动执行命令</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"/bin/sh"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"-c"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"date &gt;&gt; /usr/share/nginx/html/index.html"</span></span><br></pre></td></tr></table></figure><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>自主创建的Pod：通过手动指定yaml文件进行创建的pod，它不受pod控制器的管理，即使容器失效后也不会自动给重启</p></li><li><p>控制器管理的Pod：使用run指令创建的pod，它受到控制器管理，可以根据指定条件维持pod内容器数量</p></li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>首先需要初始化容器进行初始化，可以理解为docker中的ENTRYPOINT脚本执行效果。在初始化结束后存在类似awk的begin和end的post start和pre stop。</p><p>另外，在主容器进程执行时会有两个健康探测一直执行，探测方式主要有ExecActino(自定义命令)、TCPSocketAction(向套接字发请求)、HTTPGetAction(向http发送get请求)。常见的pod状态如下：</p><p>Pending：挂起，请求pod后调度没有完成，如标签不符合</p><p>Running：运行态</p><p>Failed：失败态</p><p>Succeeded：成功态</p><p>Unknown：未知态，可能是kubelet自身出问题</p><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>首先，创建请求提交给API server，之后API server将其保存在etcd数据库中，之后请求schedule进行调度并将其调度结果保存到etcd的pod状态中；对于node节点来说，node节点上的kubelet会收到API server变动事件，然后该kubelet会得到创建的pod的资源清单，根据清单在当前node上进行pod创建。如果创建失败，其结果会反馈给API server并保存在etcd中</p><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><p>先发送terminal信号，使得内部容器执行stop命令(给时间保存数据)；达到pod设定缓冲时间后再执行kill信号杀死pod。</p><h4 id="资源定义"><a href="#资源定义" class="headerlink" title="资源定义"></a>资源定义</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#spec</span></span><br><span class="line"><span class="string">containers</span> <span class="string">&lt;[]object&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;string&gt;</span><span class="comment">#pod名称</span></span><br><span class="line">    <span class="string">image</span> <span class="string">&lt;string&gt;</span><span class="comment">#镜像名称</span></span><br><span class="line">    <span class="string">imagePullPolicy</span> <span class="string">&lt;string&gt;</span><span class="comment">#拖取镜像方式，有三种方式</span></span><br><span class="line">    <span class="string">Always</span><span class="comment">#总是向仓库拖取，即使本地存在</span></span><br><span class="line">    <span class="string">Never</span><span class="comment">#从不向仓库拖取</span></span><br><span class="line">    <span class="string">IfNotPresent</span><span class="comment">#如果本地不存在就下载</span></span><br><span class="line">    <span class="string">ports</span> <span class="string">&lt;[]object&gt;</span><span class="comment">#定义暴露端口，但是这里不指定pod也会将容器内的服务监听端口暴露，这里主要是信息式的显示，方便查看</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;string&gt;</span><span class="comment">#端口名称，如http等</span></span><br><span class="line">      <span class="string">containerPort</span> <span class="string">&lt;string&gt;</span><span class="comment">#容器端口，如80等</span></span><br><span class="line">    <span class="string">command</span> <span class="string">&lt;[]string&gt;</span><span class="comment">#用于替换docker中的cmd和entrypoint</span></span><br><span class="line">    <span class="string">args</span> <span class="string">&lt;[]string&gt;</span><span class="comment">#用于替换docker中的cmd(cmd做参数时)，此时当作command参数   </span></span><br><span class="line">    <span class="string">livenessProbe</span><span class="comment">#容器存活状态检测，在post start后检测</span></span><br><span class="line">      <span class="string">exec</span><span class="comment">#command &lt;[]string&gt;，通过命令来直接探测</span></span><br><span class="line">      <span class="string">httpGet</span><span class="comment">#http探测，需要指明port和path；port也可以是上面ports暴露的名称，path是相对路径，相对于容器内服务定义的doc_root路径</span></span><br><span class="line">      <span class="string">tcpSocket</span><span class="comment">#tcp探测</span></span><br><span class="line">      <span class="string">failureThreshold</span><span class="comment">#探测失败次数，默认3次</span></span><br><span class="line">      <span class="string">periodSeconds</span><span class="comment">#每次间隔时间，默认10秒</span></span><br><span class="line">      <span class="string">timeoutSeconds</span><span class="comment">#超时时间，默认1秒</span></span><br><span class="line">      <span class="string">initialDelaySeconds</span><span class="comment">#容器启动后多久开始探测</span></span><br><span class="line">    <span class="string">readinessProbe</span><span class="comment">#服务就绪状态检测，在post start后检测</span></span><br><span class="line">    <span class="string">lifecycle</span><span class="comment">#生命周期</span></span><br><span class="line">      <span class="string">poststart</span><span class="comment">#类似于awk的begin，与检测逻辑相似，都包含三种方式；其执行在command后</span></span><br><span class="line">      <span class="string">prestop</span><span class="comment">#类似于awk的end，与检测逻辑相似，都包含三种方式；其执行在command后</span></span><br><span class="line"><span class="string">nodeSelector</span> <span class="string">&lt;map[string]string&gt;</span><span class="comment">#节点标签选择器，可以根据label限定Pod运行的节点</span></span><br><span class="line">  <span class="string">label=value</span></span><br><span class="line"><span class="string">nodeName</span><span class="comment">#直接运行pod于指定节点上，不通过nodeSelector选择</span></span><br><span class="line"><span class="string">restartPolicy</span><span class="comment">#重启策略，Always，OnFailure，Never，默认Always</span></span><br></pre></td></tr></table></figure><h4 id="健康检测实例"><a href="#健康检测实例" class="headerlink" title="健康检测实例"></a>健康检测实例</h4><p>ReadinessProbe，使用httpGet做就绪性探测</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">readiness-httpget-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-httpget-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/index.html</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>LivenessProbe，使用command做存活性探测</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-exec-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">"/bin/sh"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"-c"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"touch /tmp/health; sleep 30; rm -f /tmp/health; sleep 3600;"</span></span><br><span class="line">    <span class="attr">livenessProbe:</span> </span><br><span class="line">      <span class="attr">exec:</span> </span><br><span class="line">        <span class="attr">command:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">"test"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"-e"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"/tmp/healthy"</span></span><br></pre></td></tr></table></figure><h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>主要由三个主要部件组成，用于管理无状态pod。</p><p>部件：用户期望的pod副本数、标签选择器、pod模板。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">selector:</span> </span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">templates:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">environment:</span> <span class="string">qa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">spec中需要定义三个字段：replicas、selector、templates</span></span><br><span class="line"><span class="string">matchLabels用于匹配pod的labels字段，因此在templates中的labels字段中必须包含matchlabels的字段</span></span><br><span class="line"><span class="string">templates中定义的pod名称并没有意义，控制器会自动为各个pod添加自身名称后加随机字符串</span></span><br><span class="line"><span class="string">修改可以使用patch或edit编辑</span></span><br></pre></td></tr></table></figure><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>工作在ReplicaSet之上，不直接控制pod而是控制ReplicaSet，一般都使用Deployment作为pod控制器。另外，在使用Deployment进行版本更新时，它会创建一个新的RepicaSet然后在旧的RepicaSet上删除一个pod，在新的RepicaSet上新建一个pod，从而实现动态更新。当然，如果考虑到删除一个pod时会不会导致业务瓶颈导致服务中断，Deployment还支持临时允许多添加或减少pod，即可以暂时超过RepicaSet设置的replicas数，从而实现先创建一个新的，再删除旧的，这样更稳定。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp-deploy</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">Deployment会自动创建ReplicaSet进行管理</span></span><br><span class="line"><span class="string">修改可以使用patch或edit编辑</span></span><br></pre></td></tr></table></figure><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>用于确保指定的node节点只运行一个pod副本，通常用来实现系统级后台任务，且pod必须是无状态的。它也支持滚动更新。可以用于工作在指定pod上做七层负载均衡调度(打污点)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp-daemon</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">filebeat</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">filebeat</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ikubernetes/filebeat:v1</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_HOST</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">redis.default.cluster.svc.cluster.local</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">定义env一般是设置服务工作，手动指定filebeat将日志传给redis，从而实现pod之间的通信</span></span><br><span class="line"><span class="string">由于一个node上运行一个DaemonSet，因此可以使用spec字段的hostNetwork共享该pod和node的网络地址空间，这样就不用service暴露ip端口也可以直接通过node的IP进行访问</span></span><br></pre></td></tr></table></figure><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>用于执行一次性pod，如果正常执行结束则不会被重启，如果未结束时被异常终止那么会重启该pod。</p><h4 id="Cronjob"><a href="#Cronjob" class="headerlink" title="Cronjob"></a>Cronjob</h4><p>周期性job</p><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><p>用于管理有状态的pod，且每一个pod都被单独管理。如redis、mysql等。该控制器主要管理有以下特性的控制程序：</p><ul><li>稳定且唯一的网络标识符</li><li>稳定且持久的存储</li><li>有序平滑的部署扩展和终止删除</li><li>有序的滚动更新</li></ul><p>它需要三个组件：</p><p>headless service：用于确保pod删除后再重建它的名称等信息必须和原来一样，因为pod名称是唯一标识符。因此使用headless service，它确保解析直达后端pod而不是代理的service。</p><p>statefulSet：pod管理器</p><p>volumeClaimTemplate：有状态的pod不能使用同一个存储卷，因此不能使用deployment中template定义pod来定义。这里使用volumeClaimTemplate实现动态创建pvc，并且绑定各自的pv，从而实现各自挂载各自的存储卷(分布式存储)</p><h5 id="资源定义-1"><a href="#资源定义-1" class="headerlink" title="资源定义"></a>资源定义</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">meatadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">serviceName:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">sepc:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginxdata</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">volumeClaimTemplates:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nginxdata</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="string">["ReadWriteOnce"]</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">"gluster-dynamic"</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line"><span class="attr">requests:</span></span><br><span class="line"><span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">删除pod是有顺序依次删除，且不会删除对应的pvc，可以保证数据不丢失；删除后重新绑定仍然是之前对应的pvc</span></span><br><span class="line"><span class="string">每个pod名称都需要被解析，这里解析需要额外指明service_name，如：pod_name.service_name.ns_name.svc.cluster.local</span></span><br></pre></td></tr></table></figure><h5 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#扩容，顺序增序</span></span><br><span class="line">kubectl scale sts nginx --replicas=5</span><br><span class="line"><span class="comment">#镜像升级</span></span><br><span class="line">这里升级支持定义updateStrategy升级策略，其rollingUpdate属性下有一个属性为partition，它指明更新边界。</span><br><span class="line">我们知道statefulSet创建的pod有编号，从0-n，如果partition为n，表示编号大于等于n的都会更新，可以模拟出灰度更新的效果</span><br><span class="line">kubectl <span class="built_in">set</span> image sts/nginx nginx=nginx:v2</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>用于解决pod更新时地址等资源改变的问题而提出的新概念，是对多个pod的封装，pod客户端访问其他pod时是通过service访问，其本质是iptables规则或者是ipvs规则。这些规则由node节点上的kube-proxy组件实现，它一直使用watch方法监视apiserver，service资源有变动时对应kube-proxy会将其定义为规则。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="userspace"><a href="#userspace" class="headerlink" title="userspace"></a>userspace</h5><p><img src="/2020/02/01/k8s-2-pod%E5%92%8Cservice/k8s-userspace.png" alt></p><p>请求由ClientPod发给ServiceIP，ServiceIP将其转发给本地的kube-proxy，再由kube-proxy经由ServiceIP发送给目的地的kube-proxy，最后发送给对应的ServerPod。这种模式的通信kube-proxy是工作在用户空间的进程，这种通信方式效率很低(内核和用户空间的切换)。</p><h5 id="iptables-ipvs"><a href="#iptables-ipvs" class="headerlink" title="iptables/ipvs"></a>iptables/ipvs</h5><p><img src="/2020/02/01/k8s-2-pod%E5%92%8Cservice/k8s-iptables.png" alt></p><p>请求经过ServiceIP后不再转发到本地kube-proxy，而是直接由ServiceIP的规则转发，大大减少了时间开销。根据转发的规则是iptables还是ipvs来划分。</p><p>默认使用iptables规则，如果要使用ipvs规则则需要在初始化之前在/etc/sysconfig/kubelete文件中设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBE_PROXY_MODE=ipvs</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>ClusterIP：默认类型，分配一个集群内地址给service，由于是私网地址因此只用于集群内通信</p><p>NodePort：用于集群外部访问集群内部pod，并需要定义nodeport字段的端口，该模式工作于ClusterIP之上，客户端请求先经由NodeIP:NODEPORT到ClusterIP:PORT最后到pod。</p><p>LoadBalance：工作在LAAS创建负载均衡时使用</p><p>ExternalName：集群内部节点访问外部服务时定义的service，该服务必须要被DNS解析</p><h4 id="定义清单"><a href="#定义清单" class="headerlink" title="定义清单"></a>定义清单</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">role:</span> <span class="string">logstor</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">6379</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">端口有三种，port是service端口；targetPort是pod端口；nodePort是使用NodePort类型service时对外通信的端口</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;资源清单&quot;&gt;&lt;a href=&quot;#资源清单&quot; class=&quot;headerlink&quot; title=&quot;资源清单&quot;&gt;&lt;/a&gt;资源清单&lt;/h3&gt;&lt;p&gt;kubernetes使用REST格式的API将各种操作对象当作资源来管理。常见资源对象如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;workload：工作负载型资源对象，主要运行应用程序对外提供服务；如pod、deployment、statefileset等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务发现和负载均衡有关：service、ingress等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置与存储相关：volume、CSI第三方存储卷、configmap、secret等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集群级资源：名称空间、node、role、cluster role等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;元数据型资源：HPA、podtemplate、limitrange&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="pod" scheme="http://yoursite.com/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>k8s(1)-基本架构及部署</title>
    <link href="http://yoursite.com/2020/01/30/k8s-1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2020/01/30/k8s-1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%83%A8%E7%BD%B2/</id>
    <published>2020-01-30T09:54:20.000Z</published>
    <updated>2020-02-05T04:10:04.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>kubernetes是一个容器编排工具，其本质是集群，即组合多台主机的资源对外提供统一服务。在每台主机上安装相关程序，并使得这些程序实现通信，从而实现多个主机的协调。</p><a id="more"></a><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>k8s的集群内部主要分为三种网络模式，分别为节点网络、集群网络、pod网络。外部请求经由节点网络代理至集群网络，集群网络再代理至pod网络实现通信。</p><p>同一pod内：直接使用lo网卡即可通信</p><p>各pod之间通信：使用overlay Network方式实现叠加网络通信。overlay构建一个虚拟网段，实现各节点的主机内的pod处于同一个虚拟网段，这样就可以直接进行通信，不需要各种NAT转换。原理是利用隧道技术进行二层封装，主机网卡收到pod虚拟地址的报文时封装一层ip地址发送给另一台主机，另一台主机再解封装发现里面仍然是ip报文，根据ip判断是发送给自身虚拟pod的地址，从而实现各pod之间在同一虚拟网段中通信。</p><p>pod与service通信：通过iptables规则或者lvs规则进行通信。其规则由proxy生成。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>由上文可以知道，想要与pod通信需要先与service通信，而pod更新或者挂掉换新都会导致service规则的更新，这个过程需要通知master的API server进行事务处理。这里就有问题了，因为pod更新通知master那么master必然存储了大量的不必要的通知信息，这很占空间因此不可能存储在master本地，因此这里使用共享存储etcd。</p><p>etcd是键值存储的数据库系统，需要做成高可用集群，etcd通信一般使用https通信。etcd内部使用一个端口进行通信，外部使用另一个端口与master通信，这个过程都是https协议通信。</p><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>在一个k8s集群中，将多个pod划分成不同的空间实现隔离效果，这个隔离是管理的隔离比如分成生成环境、开发环境等等，各个pod仍然可以正常通信不受影响。</p><h4 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h4><p>用于实现在网络层面上隔离各个名称空间，定义iptables规则来限制pod之间的访问。k8s虽然本身网络很复杂(三种网络)但是它自身不提供网络配置以及策略的解决方案，因此需要使用第三方插件如canel来实现网络配置和网络策略的设置。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>kubernetes是一个有中心节点的集群，其架构为master/nodes模型。用户请求(启动容器等)通过API server发往master，master根据调度器(scheduler)分析各node节点资源，判断哪个适合完成用户请求的操作，接着将请求发给调度过的node上，node通过容器引擎(一般为docker)运行相关容器。</p><p><img src="/2020/01/30/k8s-1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%83%A8%E7%BD%B2/k8s%E6%9E%B6%E6%9E%84.jpg" alt></p><p>scheduler：工作在master的调度器。负责观测各node节点可供使用的CPU、RAM等资源，并根据用户申请所需要的资源量来判断将请求交给哪个node相应。调度时一般分成两步，第一步选出所有符合资源需求的node；第二步根据优选算法再挑选最符合的node进行调度。</p><p>controllers：控制器管理器。用于管理各控制器的健康状态。管理器自身基于master做冗余从而保证自身的健康。</p><p>pod：它是逻辑组件，是kubernetes的最小调度单位，有前端pod与后端pod等根据不同功用分配的类型。它是容器的封装，可以理解为docker中的多个容器共享一个网络名称空间实现的效果。pod内的多个容器除了共享网络名称空间外还共享存储卷。另外，虽然它可以组合多个容器，但是一般关联不大的容器不封装为一个pod，只有像日志记录容器和主服务容器可以建议封装在一个pod中。pod使用标签来实现不同pod的身份识别，从而可以统一控制一类pod，一般使用label selector来实现过滤。</p><p>replication controller：副本控制器，用于管理pod，可以实现pod调度。它也可以实现pod的版本滚动更新。常见的pod控制器有：Deployment(无状态)、StatefulSet(有状态)、Job(用于实现小功能，如删除数据)等。一般情况下不直接对pod进行调用而调用其控制器。</p><p>service：它是定义一系列pod的逻辑抽象，本质就是iptables规则或者lvs规则。它工作在一组pod之前，根据lvs实现负载均衡式的对pod的调度。考虑一种情况，当某个pod节点坏掉后需要新的pod替换，那么新的pod的ip地址、主机名等关键资源都将变动，那么如何才能让master无视这种变得来调用pod呢？service就是为解决此问题而提出的抽象概念，它通过label来识别不同的pod。service本身具有名称，可以根据集群内部的DNS pod实现解析，并且一旦service地址改变DNS会自动修改对应条目，使得pod客户端在下次申请资源时依旧正确连接service从而与后端pod进行交互。</p><p>node：物理机，通常成为Minion，主要运行多个pod。</p><p>kubelet：node的集群代理。工作在node节点，用于与master通信并接收执行各种任务的组件。它调用容器引擎如docker来管理容器。</p><p>proxy：node代理。负责随时与master的API server通信。因为每次node节点上的pod有变动时会主动通知API server生成一个事件，该事件会通知proxy创建新的service规则。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装一般有两种方式：</p><p>第一种方式是手动将k8s的master以及node节点的各个功能以守护进程的方式运行在主机上，这种方式需要全程手动参与，且要解决大量证书问题，很繁琐。</p><p>第二种方式是使用kubeadm部署，它将k8s本身也部署为pod，且各个master以及node只需要安装配置docker以及kubelet即可。前者是容器运行的必备引擎，后者是运行pod化容器的核心组件，这些pod都是静态pod。最后部署好flanner即可通信。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>节点网络：192.168.163.0/24</p><p>service网络：10.96.0.0/12</p><p>Pod网络：10.244.0.0/16，该网络为flannel默认网段</p><h4 id="配置master"><a href="#配置master" class="headerlink" title="配置master"></a>配置master</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置yum源，编辑/etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=kubernetes repo</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置docker-ce源，此处省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y docker-ce kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables</span><br><span class="line"><span class="comment">#修改配置文件/etc/sysconfig/kubelet，使得开启swap时不会出错</span></span><br><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--fail-swap-on=false"</span></span><br><span class="line"><span class="comment">#初始化init</span></span><br><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">拖镜像需要科学上网</span><br><span class="line">上述命令会pull镜像到本地，可以先使用kubeadm config images pull预先拖取镜像</span><br><span class="line">安装成功后会提示建议执行的一系列指令，按照要求执行即可</span><br><span class="line">成功后最后一行会有一串命令用来使得别的node加入该k8s集群中，包括密钥认证等，需要保存好该指令，如下</span><br><span class="line">kubeadm join 192.168.163.132:6443 --token m01is4.mhh9mcgn4nz4b0c3 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:3089b2a13f124b82b87a33f04ab1f2c4eb3a5286576783b34aea7964f635d50a --ignore-preflight-errors=Swap</span><br><span class="line"><span class="comment">#后续指令</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载fanner镜像，从github上手册下载</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">执行上述命令后很快会显示create，但是并没有好，需要等待docker image有flannel镜像拉取成功并且名称空间中有对应节点才说明安装好</span><br><span class="line"><span class="comment">#查看kube-system名称空间节点</span></span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><h4 id="配置node"><a href="#配置node" class="headerlink" title="配置node"></a>配置node</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将master的docker-ce.repo和kubernetes.repo复制过来</span></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y docker-ce kubelet kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment">#将master的/etc/sysconfig/kubelet配置文件复制过来</span></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用之前保存的join命令加入k8s集群，需要指明--ignore-preflight-error=Swap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载fanner镜像，从github上手册下载</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">执行上述命令后很快会显示create，但是并没有好，需要等待docker image有flannel镜像拉取成功并且名称空间中有对应节点才说明安装好</span><br><span class="line"><span class="comment">#查看kube-system名称空间节点</span></span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看状态，包括scheduler、controller、etcd</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="comment">#获取节点信息，显示详细信息</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"><span class="comment">#获取名称空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment">#查看pod信息，默认节点是default名称空间内的pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment">#列举所有service</span></span><br><span class="line">kubectl get services</span><br><span class="line"><span class="comment">#查看指定控制器</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment">#查看指定标签</span></span><br><span class="line">kubectl get pods -l <span class="string">"release in (canary,beta,alpha)"</span></span><br><span class="line">kubectl get pods -l <span class="string">"release notin (canary,beta,alpha)"</span></span><br><span class="line">kubectl get pods -l release,app</span><br><span class="line">kubectl get pods -l release=stable,app</span><br><span class="line">kubectl get pods -l release!=stable,app</span><br><span class="line"></span><br><span class="line">--all-namespaces：显示所有名称空间</span><br><span class="line">-o wide：显示详细信息</span><br><span class="line">-l label1,laebl2：查看指定label的pod</span><br><span class="line">-w：监控方式查看</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>创建并运行一个镜像，且创建指定pod控制器(deployment或者job)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--image=nginx<span class="comment">#使用指定镜像创建资源</span></span><br><span class="line">--replicas=5<span class="comment">#指定启动多少个pod资源</span></span><br><span class="line">--restart=Never<span class="comment">#容器结束不自动启动</span></span><br><span class="line">--port=80<span class="comment">#暴露哪个端口</span></span><br><span class="line">--dry-run=<span class="literal">true</span><span class="comment">#是否只执行命令不创建</span></span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交互式连入指定pod</span></span><br><span class="line">kubelet <span class="built_in">exec</span> -it pod_name -- /bin/sh</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n ns<span class="comment">#指明删除哪个名称空间下的资源</span></span><br><span class="line">-l name=label<span class="comment">#删除指定label的pod</span></span><br><span class="line">-f name.yaml<span class="comment">#删除指定资源清单定义的资源</span></span><br></pre></td></tr></table></figure><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p>调整指定deployment的pod个数，既可以增大也可以减小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=5 deployment nginx-deploy</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态升级</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment nginx-deploy nginx-deploy=docker_name/name:v2</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">第一个nginx-deploy表示控制器名称，即实例里第一命令创建的名称，第二个nginx-deploy表示容器名称</span><br><span class="line"><span class="comment">#查找指定容器对应详细信息，包括属于哪个deployment和镜像名称</span></span><br><span class="line">kubectl describe pods pods_name</span><br></pre></td></tr></table></figure><h4 id="rollout"><a href="#rollout" class="headerlink" title="rollout"></a>rollout</h4><p>回滚操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认回滚上一个，若指定回滚的版本需要指定--to-revision=VERSION</span></span><br><span class="line">kuberctl rollout undo deployment nginx-deploy</span><br><span class="line"><span class="comment">#进行canary发布即更新一个后暂停更新，通常使用&amp;&amp;结合set image使用</span></span><br><span class="line">kubectl rollout pause deployment nginx-deploy</span><br><span class="line"><span class="comment">#动态查看状态</span></span><br><span class="line">kubectl rollout deployment nginx-deploy</span><br><span class="line"><span class="comment">#继续进行更新操作</span></span><br><span class="line">kubectl rollout resume deployment nginx-deploy</span><br></pre></td></tr></table></figure><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>查看资源定义文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看某个资源如何定义，可以逐级查看</span></span><br><span class="line">kubectl explain pod.metadata</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>从yaml文件或标准输入来加载资源对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据自定义的pod-demo.yaml来创建pod</span></span><br><span class="line">kubectl create -f pod-demo.yaml</span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>类似于create，但是可以执行多次。执行后会通知APISERVER修改etcd相关内容，从而更改期望状态，从而使得pod从现有状态转向期望状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pod-demo.yaml</span><br></pre></td></tr></table></figure><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>显示一个或者多个资源对象的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe 资源类型 资源名称</span><br></pre></td></tr></table></figure><h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p>查看容器的日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br><span class="line"><span class="comment">#实时查看日志</span></span><br><span class="line">kubectl logs -f &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><h4 id="label"><a href="#label" class="headerlink" title="label"></a>label</h4><p>为资源打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl label &lt;type_name&gt; &lt;name&gt; KEY_1=VAL_1 KEY_2=VAL_2...</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">kubectl label pods pod-demo release=canary</span><br></pre></td></tr></table></figure><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>动态修改yaml配置文件，以json格式修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deployment myapp-deploy -p <span class="string">'&#123;"spec":&#123;"replicas":5&#125;&#125;'</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">外层用单引号，内层每个字段使用双引号</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在master上创建一个pod镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx-deploy --image=nginx --replicas=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">默认使用deployment调度</span><br></pre></td></tr></table></figure><p>在master上创建一个service，需要指明是为哪个pod创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCP</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">nginx-deploy就是上面创建的pod镜像</span><br><span class="line">--port指的是服务端口，即service_port；--target-port指的是容器端口，即pod_port</span><br><span class="line">创建好后其他pod即可访问该service名nginx来访问该service下的pod镜像</span><br><span class="line">注意直接以域名访问时需要用到CoreDNS来解析，必须创建一个pod客户端来访问，否则DNS检索时后缀补充会出问题</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看该service的详细信息，包括监听的标签，即关联的pod的标签名；还有关联pod的ip</span></span><br><span class="line">kubectl describe service nginx</span><br></pre></td></tr></table></figure><p>创建一个pod客户端来访问nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建名为client的pod镜像</span></span><br><span class="line">kubectl run client --image=busybox --replicas=1 -it --restart=Never</span><br></pre></td></tr></table></figure><p>删除nginx的pod后，会自动创建新的pod，自此简单的k8s已搭好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete nginx-xxx</span><br><span class="line"><span class="comment">#删除后查看发现已经重新创建pod，且名称后缀已经改变</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;kubernetes是一个容器编排工具，其本质是集群，即组合多台主机的资源对外提供统一服务。在每台主机上安装相关程序，并使得这些程序实现通信，从而实现多个主机的协调。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="kubectl" scheme="http://yoursite.com/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>docker详解</title>
    <link href="http://yoursite.com/2020/01/28/docker%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/28/docker%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-28T10:02:04.000Z</published>
    <updated>2020-01-28T10:03:04.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>虚拟化技术可以实现将多台物理主机虚拟为一个逻辑主机或者将一台物理主机虚拟为多台逻辑主机，其中后者现在被广泛运用。虚拟化技术可以分为完全虚拟化和半虚拟化，其中完全虚拟化又分为硬件辅助虚拟化和软件辅助虚拟化。</p><a id="more"></a><h4 id="软件辅助全虚拟化"><a href="#软件辅助全虚拟化" class="headerlink" title="软件辅助全虚拟化"></a>软件辅助全虚拟化</h4><p>该虚拟化方式是将虚拟化管理器(VMM)运行在用户态中。当虚拟机里的程序需要执行系统调用时，CPU并不知道它是虚拟机的指令还是真正物理机的指令，因此需要VMM来实现对每条虚拟机指令的捕获和翻译，此时VMM充当一个中间人的角色，虚拟机通过VMM来调用真正的物理资源，而实际上是VMM来向物理机的内核申请使用物理资源。对于物理机内核来说，VMM只是一个用户空间的普通进程；对于虚拟机内核来说，它认为自己就是真正内核，这就是软件辅助虚拟化。这个过程由于需要VMM参与，导致其效率不高，现在逐渐被硬件辅助全虚拟化取代。</p><h4 id="硬件辅助全虚拟化"><a href="#硬件辅助全虚拟化" class="headerlink" title="硬件辅助全虚拟化"></a>硬件辅助全虚拟化</h4><p>该虚拟化是在CPU硬件层面支持虚拟化技术后实现的新技术。对于虚拟内核来说，只需要将标志位设置为虚拟状态，那么就可以直接在CPU上执行大部分指令，不需要VMM作转述。因为开启了虚拟化技术的CPU有两个新的执行状态，他们是Non-Root和Root。VMM运行在Root模式(装载在物理内核中，相当于本身就是物理内核)，虚拟机运行在Non-Root模式的Ring0状态，这就意味这它可以直接执行特权指令，不需要VMM转述，从而大大提高虚拟机的执行效率。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是虚拟化的一种方案，但它不是主机级别的虚拟化，而是应用级别的虚拟化。它将操作系统虚拟化，把物理上的操作系统虚拟为逻辑上的多个操作系统，不同的操作系统有自己的用户空间，用户空间相互隔离，彼此意识不到对方的存在，整个容器中只运行它本身一个进程。</p><h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>是内核实现的修改进程视图的机制，它实现了容器间资源的隔离。Namespaces包含种资源，分别是：Mount、UTS、IPC、PID、Network和User。每次创建并启动一个容器时，就指定了Namespaces的参数(通过clone()系统调用实现)，每个容器只能看到当前分配给他们的Namespaces内的内容。</p><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离内容</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、共享内存、消息队列等</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备、端口、网络栈等</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>文件系统挂载点</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和组</td></tr></tbody></table><h4 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h4><p>cgroup，即Control group。该机制实现的是将系统资源分配到指定的内存中进程组上。和Namespaces类似，但是实现的目的是为了对各组进程进行统一的资源监控和限制(Namespces是为了实现隔离)。它将进程分组，将有限的资源对这些组进行分配。每个进程组可以再细分组，分配给该组的系统资源在组内共享。</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#extra仓库版本较老，使用镜像安装</span></span><br><span class="line"><span class="comment">#首先下载repo仓库进行本地制作，放在本地/etc/yum.repo.d/目录下</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#仓库中指向的仍然是docker官方，速度很慢，此处在vim中修改为清华镜像(全局替换)</span></span><br><span class="line">%s@https://download.docker.com/@https://mirrors.tuna.tsinghua.edu.cn/docker-ce/@</span><br><span class="line"><span class="comment">#更新本地repo缓存</span></span><br><span class="line">yum repolist</span><br><span class="line"><span class="comment">#指向安装</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment">#若之前安装过extra仓库的docker，需要卸载如下包，否则会冲突导致docker-ce无法安装</span></span><br><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>docker配置文件为：/etc/docker/daemon.json，该文件初始并未创建，需要手动创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#编辑该文件，添加阿里云镜像加速，该链接在阿里云容器云上获取</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://pjfb83d0.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#如果docker已运行需要重载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="image"><a href="#image" class="headerlink" title="image"></a>image</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker image COMMANDS</span><br><span class="line">build：根据Dockerfile创建一个镜像</span><br><span class="line"><span class="built_in">history</span>：显示image使用历史</span><br><span class="line">import：</span><br><span class="line">inspect：显示image的详细信息</span><br><span class="line">load：从标准输入或者归档文件创建一个image</span><br><span class="line">-i：指明输入文件</span><br><span class="line">ls：显示所有image</span><br><span class="line">prune：删除没有使用的image</span><br><span class="line">pull：从docker hub上拉去指定image</span><br><span class="line">push：将image推送到docker hub上，或指定的docker镜像服务器</span><br><span class="line">rm：删除指定镜像</span><br><span class="line">save：保存指定image到归档文件中</span><br><span class="line">-o：指明保存文件</span><br><span class="line">tag：创建一个image的tag标签</span><br></pre></td></tr></table></figure><h5 id="container"><a href="#container" class="headerlink" title="container"></a>container</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker container COMMANDS</span><br><span class="line">attach</span><br><span class="line">commit：将最上层的可写层创建为image的一层，相当于基于容器制作镜像</span><br><span class="line">cp：在本地文件系统和容器内的文件系统中复制文件</span><br><span class="line">create：根据image创建一个容器</span><br><span class="line">diff</span><br><span class="line"><span class="built_in">exec</span>：在容器中运行命令</span><br><span class="line"><span class="built_in">export</span></span><br><span class="line">inspect：显示容器的详细信息</span><br><span class="line"><span class="built_in">kill</span>：杀死一个运行的容器，相当于<span class="built_in">kill</span> -9</span><br><span class="line">logs：获取容器运行进程的日志</span><br><span class="line">ls：显示容器</span><br><span class="line">pause：暂停所有容器</span><br><span class="line">port</span><br><span class="line">prune：删除所有停止状态的容器</span><br><span class="line">rename：重命名容器</span><br><span class="line">restart：重启容器</span><br><span class="line">rm：删除容器</span><br><span class="line">run：在容器中运行命令，需要指明image</span><br><span class="line">-i：保持交互式连接</span><br><span class="line">-t：启动终端</span><br><span class="line">start：启动容器</span><br><span class="line">stats</span><br><span class="line">stop：停止运行的容器，相当于<span class="built_in">kill</span> -15</span><br><span class="line">top：基于资源消耗比率显示容器</span><br><span class="line">unpause：继续暂停的容器</span><br><span class="line">update</span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>Docker镜像含有启动容器所需要的文件系统及其内容。因此，其用于创建并启动docker容器。</p><p>Docker镜像采用分层构建机制，最底层为bootfs，上层为rootfs</p><ul><li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约资源</li><li>rootfs：位于bootfs之上，表现为docker容器的根文件系统。在传统模式中系统启动时内核挂载rootfs时会首先将其挂载为只读模式，完成一系列自检操作后将其重新挂载为读写模式。而在docker中，rootfs由内核挂载为只读模式，而后通过联合挂载技术额外挂载一个可写层。因此由镜像创建容器时，实际就是在基础镜像层上添加一个可写的image层，所有的写操作都在此层。因此在删除容器时实际也是删除该可写image层，源镜像保持不变。</li></ul><p>一个完整的镜像是由多个镜像分层联合挂载而来。bootfs作为最底层在引导出用户空间的根文件系统后就自动卸载。之后有Base image基本镜像层，该层主要是封装各种操作系统；其次是各种应用程序层，比如vim编辑器层、nginx服务层等。这些多个镜像一层一层叠加形成完整的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从指定镜像仓库中拉取镜像</span></span><br><span class="line">docker pull &lt;registry&gt;[:&lt;port&gt;]/[&lt;namespace&gt;/]&lt;name&gt;:&lt;tag&gt;</span><br><span class="line">&lt;registry&gt;[:&lt;port&gt;]：指明仓库服务器和端口(默认443https)，如果是docker hub则可省略(一般都省略)</span><br><span class="line">&lt;namespace&gt;：指明用户空间(可以是用户名、组织名等)，如果是顶层仓库可以省略</span><br><span class="line">&lt;name&gt;:&lt;tag&gt;：仓库名和标签名</span><br></pre></td></tr></table></figure><h5 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h5><p>镜像的制作有三种途径：</p><p>基于容器的制作，即在<strong>运行</strong>的容器中使用commit命令将镜像最上层的可写层合并到原始镜像中变成新镜像；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建镜像</span></span><br><span class="line">docker commit [options] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">[REPOSITORY[:TAG]]：指定仓库名和标签名，不指明则为none</span><br><span class="line">-p：在制作镜像时暂停容器</span><br><span class="line"></span><br><span class="line"><span class="comment">#打标签</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录docker仓库，阿里云比较快</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#push镜像，如果不是dockerhub需要指明服务器地址、仓库名等</span></span><br><span class="line">docker push IMAGE_NAME[:TAG]</span><br></pre></td></tr></table></figure><p>基于Dockerfile的build命令制作；</p><p>基于Docker Hub的automated build制作，它本质也是基于Dockerfile来制作，它需要监视联合github，每次用户对Dockerfile的修改先推送到github上，然后Docker Hub会不断监视Github是否发生改动，如果有改动就拉取过来基于Dockerfile进行镜像制作。</p><h5 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先登录Registry，默认不指定SERVER为docker hub</span></span><br><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">-p password：指明密码</span><br><span class="line">-u username：指明用户名</span><br><span class="line">SERVER：指定Registry地址</span><br><span class="line"></span><br><span class="line"><span class="comment">#给指定镜像打标签，注意username必须是顶层仓库名，如果不是顶层仓库还需要依次指明仓库名</span></span><br><span class="line">docker tag image username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送，按照打标签的格式推上去即可</span></span><br><span class="line">docker push username/repository:tag</span><br></pre></td></tr></table></figure><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>docker网络通信主要有四种方式：bridge、host、none、container</p><table><thead><tr><th>模式</th><th>解释</th></tr></thead><tbody><tr><td>Bridge</td><td>使用虚拟网卡和虚拟交换机实现</td></tr><tr><td>Host</td><td>namespace不分配网络资源，公用物理主机网络资源</td></tr><tr><td>None</td><td>没有网卡，不能进行网络通信</td></tr><tr><td>Container</td><td>和已存在的运行的容器共享网络资源</td></tr></tbody></table><h5 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h5><p>该模式是docker的默认模式，它使用模拟网卡和模拟交换机实现。可以理解为将网卡分成两半即每个网卡都是成对出现的，一半在docker上，一半在软件模拟的交换机上(网卡名称一样)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模拟的虚拟交换机(有ip时也当作模拟网卡)，在物理机使用如下命令查看</span></span><br><span class="line"><span class="comment">#可以看出编号为3的docker0的设备即为虚拟交换机，编号为9的vethcf37621@if8的网卡设备为虚拟网卡，且该设备连接在docker0上</span></span><br><span class="line">ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:b1:56:1d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:6c:8a:31:24 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">9: vethcf37621@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 66:17:df:67:22:31 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    </span><br><span class="line"><span class="comment">#查看docker容器的虚拟网卡</span></span><br><span class="line"><span class="comment">#其中eth0@if9表示的就是上述vethcf37621@if8的另一半虚拟网卡，相当于连接到docker0上(类似于一根网线)</span></span><br><span class="line">ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>另外，在bridge模式下，不仅容器间可以正常通信(处于同一个虚拟交换机上)，容器也可以同外部主机进行通信。实现方法是通过iptables的nat规则实现SNAT，使用如下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t NAT -vnL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 567 packets, 44852 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#上述条目标明从本机发出报文时，如果不是发往docker0网卡的且源地址为172.17网段的，都要做源地址转换，转换后与外界通信时使用的是物理机的网卡信息</span></span><br></pre></td></tr></table></figure><p>最后，既然本机的docker容器可以访问外网地址，那么外网地址是否可以访问本机呢，答案是肯定的。当本机启动一个进程后(监听在某个端口上)，这是会添加一条新的iptables规则，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行nginx的docker映射到本地80端口，前者为主机端口，后者为容器内端口，-d表示后台运行docker</span></span><br><span class="line">docker run -p 80:80 -d nginx</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">iptables -t nat -vnL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br><span class="line">    </span><br><span class="line"><span class="comment">#可以看出，任何以目标端口为80的请求都会做DNAT，将其地址改为172.17.0.2，因此可以实现通信</span></span><br><span class="line"><span class="comment">#也可以使用如下命令查看端口映射</span></span><br><span class="line">docker port c6849e28cea7</span><br></pre></td></tr></table></figure><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>该模式下，docker和物理主机共用网络资源，换句话说没有对docker容器进行namespace的网络资源隔离。通信的话就直接使用物理网卡进行通信即可。</p><h5 id="None"><a href="#None" class="headerlink" title="None"></a>None</h5><p>不具有网络功能，主要用于实现一些计算等不用网络的docker容器。</p><h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><p>其实和host很像。但是该模式并不是没有隔离网络资源，而是仅设置为该模式的两个共享网络资源，即共享的是分配的namespace的网络资源，而host是共享的物理主机的资源，根本不存在namespace概念(单指网络，其他资源依旧隔离)。可以理解为一台主机上的两各进程间通信，但是有一定隔离。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示nginx容器和infracon容器使用Container模式网络</span></span><br><span class="line">docker run --name nginx --network container:infracon -it busybox</span><br></pre></td></tr></table></figure><h5 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建虚拟交换机mybr1</span></span><br><span class="line">docker network create -d bridge --subnet <span class="string">"192.163.10.0/24"</span> --gateway <span class="string">"192.168.10.1"</span> mybr1</span><br><span class="line"><span class="comment">#运行docker时加入自定义的mybr1</span></span><br><span class="line">docker run -it --network mybr1 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#若想要不同虚拟交换机之间的docker能够通信，只需要开启物理机的核心转发即可</span></span><br><span class="line"><span class="comment">#注意，iptables会添加很多规则，若想实验可以先保存规则再删掉</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><h5 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h5><p>此处使用ip netns命令模拟网络名称空间的设定。此处只是将Net的namespace隔离开，其他五个namespace资源全部共享。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加网络名称空间ns1和ns2</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"><span class="comment">#查看网络空间</span></span><br><span class="line">ip netns list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ns1和ns2内部的网卡，只能看到一个lo回环设备，无网卡</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig -a</span><br><span class="line"><span class="comment">#创建虚拟网卡对</span></span><br><span class="line">ip link add name veth1.1 <span class="built_in">type</span> veth peer name veth1.2</span><br><span class="line"><span class="comment">#查看创建的虚拟网卡对，可以从名字看出是成对的网卡</span></span><br><span class="line">ip link show</span><br><span class="line">24: veth1.2@veth1.1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 4e:20:59:46:17:81 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">25: veth1.1@veth1.2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether a2:a8:b7:cb:4d:8d brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment">#将成对的两个网卡分别移动到不同的netns中</span></span><br><span class="line">ip link <span class="built_in">set</span> dev veth1.2 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> dev veth1.1 netns ns2</span><br><span class="line"><span class="comment">#激活物理机网卡veth1</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ifconfig veth1.1 192.168.163.120/24 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig veth1.2 192.168.163.121/24 up</span><br></pre></td></tr></table></figure><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><p>修改默认docker0桥地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改/etc/docker/daemon.json，只需要添加bip即可，其他会自动添加，多个项之间使用","隔开</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"bip"</span>: <span class="string">"192.168.163.2/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改docker服务器监听地址，默认是基于本机/var/run/docker.sock通信</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑/etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"hosts"</span>: [<span class="string">"tcp://0.0.0.0:2375"</span>,<span class="string">"unix:///var/run/docker.sock"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一台主机使用-H选项指明docker服务器地址</span></span><br><span class="line">docker -H IP_ADDR COMMANDS</span><br></pre></td></tr></table></figure><h4 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>docker镜像由多个只读层叠加而成，启动容器时docker会加载只读镜像层并在镜像层顶部添加一个读写层，用户所有的对镜像的写操作都在此层中生效。如果运行中的容器修改了一个已存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，这就是所谓的<strong>写时复制</strong>机制。另外，用户在读写层对文件进行删除操作时，只是相当于在该文件上做了删除标记，此后在读写层该文件对用户不可见，在只读层该文件依然存在。</p><p>由上可知，docker容器在关闭后全部更改都会丢失，因此会存在容器间数据共享不便、删除容器数据丢失、不利于分布式容器集群管理等问题。因此，为解决以上问题提出了<strong>卷</strong>的概念。实际上卷是容器上的一个或多个目录，此目录与物理机上的某个目录存在绑定关系，这样即使容器删除后，其数据依然存在本地，下次再启动容器时该数据依然存在。</p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>docker中有两种类型的卷，每种类型都在容器中存在一个挂载点，但其物理主机上的位置有所不同</p><ul><li>Bind mount volume：容器和物理机的目录都需要手动指定</li><li>Docker-managed volume：容器内的目录手动指定，物理机的目录由docker管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker管理卷，指明容器内目录为/data</span></span><br><span class="line">docker run -it -v /data --name bbox1 busybox</span><br><span class="line"><span class="comment">#Bind挂载，指明物理机目录和容器内目录</span></span><br><span class="line">docker run -it -v HOSTDIR:VOLUMEDIR --name bbox2 busybox</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看挂载属性</span></span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox1</span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox2</span><br></pre></td></tr></table></figure><p>另外，可以实现用一个容器单独作为卷，其他容器绑定在该容器上。在实际使用中，使用一个专门做基础容器镜像的容器来代替此处自建的infracon，它只需要实现被其他容器关联即可，不需要启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx --network container:infracon --volumes-from infracon -it busybox</span><br></pre></td></tr></table></figure><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>前文创建镜像时提到过dockerfile，它是一个文本描述文件，其内包含了一条条指令来描述如何构建一个镜像文件。编写dockerfile时，需要创建一个目录将dockerfile文件放入该目录中，之后dockerfile内指令需要的所有文件都放到该目录或者该目录的子目录中。.dockerignore文件可以指定哪些文件不需要被build进镜像中。</p><p>不同的关键字定义不同的指令功能，dockerfile本身对字符大小写不敏感，但是一般关键字默认使用全大写。</p><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>FROM指令是dockerfile文件第一个非注释行，用于指明镜像文件的构建过程的基准镜像，后续的指令都运行于此基准镜像所提供的运行环境之上。默认情况下docker build时会在docker主机上查找指定的镜像文件，在其不存在时默认从docker hub上拉取镜像文件，也可以从指定的仓库拉取镜像文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line">&lt;repository&gt;：基准镜像名称</span><br><span class="line">&lt;tag&gt;：基准镜像的标签，默认为latest</span><br><span class="line"><span class="comment">#另外一种语法</span></span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt;</span><br><span class="line">&lt;digest&gt;：指明基准镜像的<span class="built_in">hash</span>值</span><br></pre></td></tr></table></figure><h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><p>用来取代MAINTAINER关键字。它是用来为镜像添加元数据，如镜像名称、制作时间、作者等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</span><br></pre></td></tr></table></figure><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>用于将dockerfile目录下的文件复制到镜像文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">&lt;src&gt;：要复制的源文件或目录，支持使用通配符</span><br><span class="line">&lt;dest&gt;：目标路径，即正在创建的镜像文件系统路径；建议为&lt;dest&gt;使用绝对路径，否则使用关键字WORKDIR指明的路径</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">COPY [<span class="string">"&lt;src&gt;"</span>...<span class="string">"&lt;dest&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">&lt;src&gt;必须是build上下文中的路径(即dockerfile文件所在的目录中的文件)，不能是其父目录中的文件</span><br><span class="line">如果&lt;src&gt;是目录，则其内部文件或子目录会被递归复制，但&lt;src&gt;目录自身不会被复制</span><br><span class="line">如果指定了多个&lt;src&gt;，或在&lt;src&gt;中使用通配符，则&lt;dest&gt;必须是一个目录且必须以/结尾指明是目录</span><br><span class="line">如果&lt;dest&gt;不存在，会自动创建(包括其父目录)</span><br></pre></td></tr></table></figure><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>与COPY类似，但是ADD支持tar文件打包和url文件联网下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">ADD [<span class="string">"&lt;src&gt;"</span>...<span class="string">"&lt;dest&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">COPY有的特性ADD都有</span><br><span class="line">如果&lt;src&gt;为URL且&lt;dest&gt;不以/结尾，则&lt;src&gt;指定的文件将被下载并创建为&lt;dest&gt;；如果&lt;dest&gt;以/结尾，则保存至其目录下</span><br><span class="line">如果&lt;src&gt;是一个本地系统上的压缩格式的tar文件，其将会被展开成目录放在&lt;dest&gt;下；如果是网上下载的tar文件则不会展开</span><br></pre></td></tr></table></figure><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>用于为dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY、ADD指明工作目录，可以多次指定且只对该关键字后的指令有效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">WORKDIR &lt;dirpath&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">WORKDIR可以出现多次，若其为相对路径则是相对上一个WORKDIR的相对路径</span><br><span class="line">WORKDIR可以调用由ENV指定定义的变量</span><br></pre></td></tr></table></figure><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>用于在镜像中创建挂载卷，用来挂载物理主机或者其他容器的卷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">VOLUME &lt;mountpoint&gt;</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">此处只能指定docker容器中的路径，不能手动指定物理主机的挂载路径，使用的是docker管理的挂载方式</span><br></pre></td></tr></table></figure><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>用于为容器打开指定要监听的端口以实现与外部通信</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">EXPOSE &lt;port&gt;[/&lt;protocol&gt;] [port][/&lt;protocol&gt;]...</span><br><span class="line">&lt;protocol&gt;：指定传输层协议，默认为tcp协议</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">镜像并不会直接暴露出可暴露的端口，而是当run时使用-P选项才暴露所有设定的端口</span><br></pre></td></tr></table></figure><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>用于为镜像定义所需要的环境变量，并可被dockerfile文件中定义于其后的其他指令(如ENV、ADD、COPY等)调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法，一次只能设置一个变量</span></span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line"><span class="comment">#另一种语法，一次可以设置多个变量，多个变量可以使用\续行来定义</span></span><br><span class="line">ENV &lt;key&gt; &lt;value&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用格式</span></span><br><span class="line"><span class="variable">$var_name</span></span><br><span class="line"><span class="variable">$&#123;var_name&#125;</span></span><br></pre></td></tr></table></figure><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>用于指定docker build过程中运行的程序，可以是多条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">RUN &lt;<span class="built_in">command</span>&gt; &amp;&amp; &lt;<span class="built_in">command</span>&gt;...</span><br><span class="line"><span class="comment">#另一种语法</span></span><br><span class="line">RUN [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">RUN命令执行的一般是shell命令，其以<span class="string">"/bin/sh -c"</span>来执行这些命令</span><br><span class="line">定义多个RUN时会依次执行</span><br><span class="line">第一种语法格式默认使用shell来解释执行，因此其父进程为shell，则其id不为1，不能接收unix信号</span><br><span class="line">第二种语法格式默认使用内核<span class="built_in">exec</span>来执行，不支持shell特性如通配等，但可以接收unix信号，若想以shell执行可以使用如下命令</span><br><span class="line">RUN [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br></pre></td></tr></table></figure><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>类似于RUN，不过该关键字定义的命令运行在docker run过程中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">CMD &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment">#语法2</span></span><br><span class="line">CMD [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br><span class="line"><span class="comment">#语法3</span></span><br><span class="line">CMD [<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">同RUN</span><br><span class="line">该指令运行于镜像启动为容器时默认要执行的命令，其执行结束后容器也会终止，可以被run选项覆盖</span><br><span class="line">在dockerfile中可以定义多条CMD，但仅最后一条会生效</span><br><span class="line">第三种语法格式用于为ENTRYPOINT指令提供默认参数</span><br></pre></td></tr></table></figure><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>类似于CMD指令的功能，用于为容器指定默认运行程序，从而使容器像一个单独的可执行程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ENTRYPOINT &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment">#语法2</span></span><br><span class="line">ENTRYPOINT [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">同CMD</span><br><span class="line">一般的例如CMD命令，在run执行时可以自己使用命令替换掉，但是ENTRYPOTIN不行，自己后写的命令只会被当作它的参数来运行</span><br><span class="line">同时定义CMD和ENTRYPOINT时，CMD会被当作ENTRYPOINT的参数</span><br></pre></td></tr></table></figure><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>用于指定运行镜像时或运行dockerfile种任何RUN、CMD、ENTRYPOINT等指令指定的程序时的用户名或UID。默认情况下，container的运行身份为root用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">USER &lt;UID&gt;|&lt;UserName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">指明的用户需要在/etc/passwd中有该用户的信息</span><br><span class="line">root用户不需要上述条件，因为root用户属于内核</span><br></pre></td></tr></table></figure><h5 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h5><p>用于检查容器工作是否正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法，运行脚本检查</span></span><br><span class="line">HEALTHCHECK [options] CMD <span class="built_in">command</span></span><br><span class="line">options：</span><br><span class="line">--interval=DUARATION<span class="comment">#间隔时间，默认30s</span></span><br><span class="line">--timeout=DURATION<span class="comment">#超时时长，默认30s</span></span><br><span class="line">--start-period=DURATION<span class="comment">#run之后等待主进程启动的时间，默认0s</span></span><br><span class="line">--retries=N<span class="comment">#检查次数，默认3次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#健康检测状态返回值</span></span><br><span class="line">0：表示容器健康</span><br><span class="line">1：表示不健康</span><br><span class="line">2：保留位，暂不使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">通常健康检测时使用CMD配合命令检测，最后加个||<span class="built_in">exit</span> 1即可，如果正常则不会执行<span class="built_in">exit</span> 1，如果不正常会执行<span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><p> 用于定义默认的shell环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">SHELL [<span class="string">"executable"</span>,<span class="string">"parameters"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">默认linux为：</span><br><span class="line">SHELL [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>]</span><br><span class="line">默认windows为：</span><br><span class="line">SHELL [<span class="string">"cmd"</span>,<span class="string">"/S"</span>,<span class="string">"/C"</span>]</span><br></pre></td></tr></table></figure><h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>用于定义变量，但指令只在build过程使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">可以在build时使用--build-arg &lt;varname&gt;=&lt;value&gt;来设置</span><br></pre></td></tr></table></figure><h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>用于在dockerfile中定义一个触发器，当该镜像文件被别人作为基础镜像文件时会执行该指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ONBUILD &lt;INSTRUCTION&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">ONBUILD不能自我嵌套</span><br><span class="line">ONBUILD中最好不要使用ADD或COPY指令，因为无法判断另一个制作镜像的人是否有指定的文件路径</span><br></pre></td></tr></table></figure><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>实现nginx配置</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">ENV</span> NGX_DOC_ROOT=<span class="string">'/data/web/html/'</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> entrypoint.sh /bin/</span></span><br><span class="line"><span class="comment">#-g表示运行在前台，daemon off表示不使用守护进程运行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/sbin/nginx"</span>,<span class="string">"-g"</span>,<span class="string">"daemon off;"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/entrypoint.sh"</span>]</span></span><br><span class="line"><span class="comment">#上面两个组合起来相当于执行 /bin/entrypoint.sh /usr/sbin/nginx -g daemon off</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#entrypoint.sh</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cat &gt; /etc/nginx/conf.d/www.conf &lt;&lt; EOF</span><br><span class="line">server &#123;</span><br><span class="line">server_name $&#123;HOSTNAME&#125;;</span><br><span class="line">listen $&#123;IP:-<span class="number">0.0</span>.<span class="number">0.0</span>&#125;:$&#123;PORT:-<span class="number">80</span>&#125;;</span><br><span class="line">root $&#123;NGX_DOC_ROOT:-/usr/share/nginx/html&#125;;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#由于CMD定义的变成该脚本的参数，执行此命令就是将参数当作命令执行，从而使得nginx变成id为1的进程</span></span><br><span class="line">exec <span class="string">"$@"</span></span><br></pre></td></tr></table></figure><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可以自建Registry，也可以使用默认的Dockers hub</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>Sponsor Register：第三方Registry，共客户和docker社区使用</li><li>Mirror Registry：第三方Registry，只让客户使用</li><li>Vendor Registry：由发布docker镜像的供应商提供的Registry</li><li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供Registry</li></ul><h5 id="搭建私有Registry"><a href="#搭建私有Registry" class="headerlink" title="搭建私有Registry"></a>搭建私有Registry</h5><p>此处使用harbor来搭建私有Registry，它有良好的UI界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装docker-compose，这是一个用于单机管理和运行多个docker容器的工具</span></span><br><span class="line">yum install -y docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处省略harbor下载和解压缩，一般将其解压缩到/usr/local/下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置harbor.conf</span></span><br><span class="line"><span class="comment">#设置ip或主机名</span></span><br><span class="line">hostname = 192.168.163.132</span><br><span class="line"><span class="comment">#访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置on</span></span><br><span class="line">ui_url_protocol = http</span><br><span class="line"><span class="comment">#设置最大子进程数，一般小于等于cpu物理核心数</span></span><br><span class="line">max_job_workers = 3</span><br><span class="line"><span class="comment">#设置管理密码</span></span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"><span class="comment">#配置相关数据库</span></span><br><span class="line">db_password = root123</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">本地搭建的私有Registry后会不允许你上传和下载操作，因为docker默认使用https协议，即使你私建CA也无法获取docker信任，因此在此处让docker忽略https安全选项，在/etc/docker/daemon.json中定义即可</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"insecure-registries"</span>: [<span class="string">"10.0.86.193"</span>]</span><br><span class="line">&#125;</span><br><span class="line">另外，如果需要远程登录docker服务器，那么还需要指定在unit file中的ExecStart处添加 –insecure-registry</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装，实际就是根据脚本执行docker-compose命令，命令配置文件就是docker-compose.yml</span></span><br><span class="line">./install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动|停止服务</span></span><br><span class="line">docker-compose start|stop</span><br></pre></td></tr></table></figure><h4 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h4><p>默认docker不限制资源的使用，即docker可以使用物理机的所有资源。</p><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m：限制容器可用最大物理内存大小</span><br><span class="line"><span class="comment">#注意，在容器中使用free命令不是真的swap空间大小</span></span><br><span class="line">--memory-swap：容器可以与磁盘交互的大小，但算法比较特殊，它的数值不代表真的swap大小</span><br><span class="line">--oom-kill-disable：设置<span class="literal">true</span>时表示禁止被OOM机制(内存不足)杀死</span><br><span class="line">--memory-swapiness：设置使用swap的倾向性，0~100，0表示能不用就不用(不是禁用)，100表示能用就用</span><br></pre></td></tr></table></figure><table><thead><tr><th>–memory-swap</th><th>–memory/-m</th><th>功能</th></tr></thead><tbody><tr><td>正数S</td><td>整数M</td><td>总大小为S，swap为S-M，物理内存为M</td></tr><tr><td>0</td><td>整数M</td><td>相当于未设置swap</td></tr><tr><td>unset</td><td>整数M</td><td>若主机(docker host)启用了swap，则容器可用swap=2*M</td></tr><tr><td>-1</td><td>整数M</td><td>同上，容器可使用最大至主机上的所有swap空间的swap资源</td></tr></tbody></table><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cpu-shares：指定cpu分配比率</span><br><span class="line">--cpu=&lt;value&gt;：指明cpu核心数使用，可以为小数</span><br></pre></td></tr></table></figure><h5 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h5><p>压测一般使用镜像来测试，在docker hub上搜索stress找一个即可，此处不进行演示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟化&quot;&gt;&lt;a href=&quot;#虚拟化&quot; class=&quot;headerlink&quot; title=&quot;虚拟化&quot;&gt;&lt;/a&gt;虚拟化&lt;/h3&gt;&lt;p&gt;虚拟化技术可以实现将多台物理主机虚拟为一个逻辑主机或者将一台物理主机虚拟为多台逻辑主机，其中后者现在被广泛运用。虚拟化技术可以分为完全虚拟化和半虚拟化，其中完全虚拟化又分为硬件辅助虚拟化和软件辅助虚拟化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>zabbix详解</title>
    <link href="http://yoursite.com/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-26T06:03:21.000Z</published>
    <updated>2020-01-26T06:07:28.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="监控对象"><a href="#监控对象" class="headerlink" title="监控对象"></a>监控对象</h4><p>主机、交换机、路由器等</p><a id="more"></a><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>采样指的是周期性地获取某个关注指标相关的数据。</p><p>采样通道，即监控系统通过什么途径获取被监控主机的信息。一般有如下几种：</p><ul><li>ssh/telnet</li><li>agent/master，即在被监控主机上部署应用程序</li><li>IPMI，intel监控接口</li><li>SNMP，简单网络监控协议，通常用于交换机路由器等</li><li>JMX，java监控系统，主要用于JVM虚拟机的监控</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>即监控获得的数据和数据的存储方式。</p><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><ul><li>历史数据，指每次采样的结果，保存时间周期较短</li><li>趋势数据，指聚合数据结果(最大值、最小值等)，保存时间周期较长</li></ul><h5 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h5><ul><li>关系型数据库：Mysql、Oracle等</li><li>RRD：轮询数据库，类似一个环形文件系统，保存指定量或者时长的数据后就直接覆盖之前数据继续存储</li><li>非关系型数据库：redis等</li></ul><h4 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h4><p>邮件、短信、微信、电铃等。只要能通过脚本实现即可。</p><h3 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>数据采样：snmp、agent、impl、jmx</p><p>报警：支持步进式升级报警</p><p>数据存储：mysql</p><p>展示：php程序，支持绘图，滑动显示等</p><p>其他：支持监控模板定义，可适配多台主机；支持网络自动发现；支持分布式监控；支持基于API的二次开发</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/C:%5CUsers%5CFrdqy%5CDesktop%5C%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%5C%E5%B7%B2%E5%AE%8C%E6%88%90%5Cpicture%5Cjiagou.jpg" alt></p><p>Zabbix server：服务端监控程序(守护进程)，负责接收agent发送的报告信息；所有配置统计数据等均由其组织进行；监听在某个端口</p><p>Zabbix proxy：监控代理，一般用于分布式监控系统中。代理接收当前分布式环境中的数据后统一发送给server</p><p>Zabbix database：存储监控信息的数据库；也存储配置信息；常用Mysql</p><p>Zabbix web GUI：用于展示监控信息的web页面</p><p>Zabbix agentd：部署在被监控主机上的守护进程，负责收集其本地数据并发往server端或proxy端</p><p>Zabbix sender：命令行工具，用于在agent端测试能否向server端发送数据</p><p>Zabbix get：命令行工具，用于在server端向agent端拉取数据</p><h4 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h4><ul><li>Agent：客户端模式，可分为主动(active)和被动(passive)模式</li><li>SNMP：简单网络管理协议，主要有get、set、trap操作(agent向server主动通信)</li><li>IPMI：intel平台提供的智慧平台管理接口，用于监测物理特性(cpu温度等)，需要服务器提供硬件层面的接口</li><li>JMX：Java管理拓展，用于通过java自己的接口对java程序进行监控。在zabbix使用中，需要使用额外的程序包帮助实现</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/%E6%9C%AF%E8%AF%AD.png" alt></p><p>Poller：server端向agent端索要数据的动作</p><p>host：要监控的网络设备，可由IP或DNS名称指定。</p><p>host group：主机组。即host的逻辑容器。包含主机和模板，但同一个组内的主机和模板不能互相连接；主机组通常在给用户或用户组指派监控权限时使用。</p><p>item：监控项。一个特定监控指标的相关数据，这些数据来自被监控对象。每个item由”key”标识。</p><p>application：应用。即一组item的集合。</p><p>trigger：触发器。即一个表达式，用于判断监控对象某特定item内所接收到的数据是否在合理范围内，超过合理范围时，触发器状态从”OK”转化为”Problem”，反之亦然。</p><p>event：事件。由触发器触发的事件。例如触发器状态转变、新的agent上线等。</p><p>action：动作。指对于特定事件的处理方式。通常由触发器触发某事件后执行某动作。</p><p>escalation：报警升级。发送警报或执行远程命令的自定义方案，如每隔5分钟发一次警报，共发送5次。</p><p>media：媒介。发送通知的手段或通道，如Email等。</p><p>notification：通知，通过选定的媒介向用户发送的有关某事件的信息。</p><p>remote command：远程命令。即预定义的命令，可在被监控主机处于某一特定条件下时自动执行。</p><p>template：模板。用于快速定义被监控主机的预设条目集合，通常包含item、trigger、graph、screen、application以及low-level discovery rule；模板可之间连接至单个主机。</p><p>web scenario：web场景。用于检测web站点可用性的一个或多个HTTP请求。</p><p>frontend：前端。Zabbix的web接口。</p><h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><p>安装配置mysql；设置zabbix database</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装mariadb</span></span><br><span class="line">yum install mariadb-server -y</span><br><span class="line"><span class="comment">#编辑/etc/my.cnf，在[mysqld]字段下添加</span></span><br><span class="line"><span class="comment">#不进行域名反解和关闭单独表空间</span></span><br><span class="line">skip_name_resolve=ON</span><br><span class="line">innodb_file_per_table=ON</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据库</span></span><br><span class="line">create database zabbix charset <span class="string">'utf8'</span>;</span><br><span class="line"><span class="comment">#授权用户</span></span><br><span class="line">grant all on zabbix.* to <span class="string">'zbxuser'</span>@<span class="string">'%'</span> identified by <span class="string">'dqy751421'</span>;</span><br></pre></td></tr></table></figure><p>安装zabbix server程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zabbix</span><br></pre></td></tr></table></figure><p>导入zabbix数据库脚本，生成数据库文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -uzbxuser -pdqy751421 zabbix</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入/usr/share/zabbix-mysql目录下的三个文件创建数据表(上面已提前创建数据库)</span></span><br><span class="line">mysql -uzbxuser -pdqy751421 zabbix &lt; /usr/share/zabbix-mysql/schema.sql</span><br><span class="line">mysql -uzbxuser -pdqy751421 zabbix &lt; /usr/share/zabbix-mysql/images.sql</span><br><span class="line">mysql -uzbxuser -pdqy751421 zabbix &lt; /usr/share/zabbix-mysql/data.sql</span><br></pre></td></tr></table></figure><p>配置文件修改DB相关值即可启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBHost=localhost<span class="comment">#指明数据库地址</span></span><br><span class="line">DBName=zabbix<span class="comment">#指明数据库名</span></span><br><span class="line">DBUser=zbxuser<span class="comment">#指明数据库用户</span></span><br><span class="line">DBPassword=dqy751421<span class="comment">#指明数据库密码</span></span><br><span class="line">DBPort=3306<span class="comment">#指明mysql数据库端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动，监听10051端口</span></span><br><span class="line">systemctl start zabbix-server</span><br></pre></td></tr></table></figure><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>配置文件：/etc/zabbix/zabbix_server.conf</p><p>Unit File：zabbix-server.service</p><h5 id="zabbix-server配置"><a href="#zabbix-server配置" class="headerlink" title="zabbix server配置"></a>zabbix server配置</h5><p>使用192.168.163.132作为server端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/zabbix/zabbix_server.conf</span></span><br><span class="line"><span class="comment">#注意初始时数据库相关配置都没有配置，需要手动指定</span></span><br><span class="line">ListenPort=10051<span class="comment">#server默认监听10051</span></span><br><span class="line">SourceIP<span class="comment">#在客户端定义的可采样的服务端地址</span></span><br><span class="line">LogType<span class="comment">#日志格式，包括syslog、file、console</span></span><br><span class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_server.log<span class="comment">#日志文件(基于file存放)</span></span><br><span class="line">LogFileSize=0<span class="comment">#日志文件大小，超过后开始滚动(0标识禁止滚动)</span></span><br><span class="line">DebugLevel=3<span class="comment">#定义日志记录级别，默认为warnings</span></span><br><span class="line">DBHost=localhost<span class="comment">#指明数据库地址</span></span><br><span class="line">DBName=zabbix<span class="comment">#指明数据库名</span></span><br><span class="line">DBUser=zbxuser<span class="comment">#指明数据库用户</span></span><br><span class="line">DBPassword=dqy751421<span class="comment">#指明数据库密码</span></span><br><span class="line">DBPort=3306<span class="comment">#指明mysql数据库端口</span></span><br><span class="line">DBSocket=/tmp/mysql.sock<span class="comment">#指明mysql.sock路径</span></span><br></pre></td></tr></table></figure><h5 id="web配置"><a href="#web配置" class="headerlink" title="web配置"></a>web配置</h5><p>安装一些基本程序。用于测试的话可以与zabbix安装在一台主机上，不过推荐分开装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装php</span></span><br><span class="line">yum install -y httpd php php-mysql php-mbstring php-gd php-bcmath php-ldap php-xml</span><br><span class="line"><span class="comment">#安装web gui</span></span><br><span class="line">yum install -y zabbix40-web zabbix40-web-mysql</span><br><span class="line"><span class="comment">#配置时区，在/etc/httpd/conf.d/zabbix.conf设置</span></span><br><span class="line">php_value date.timezone Asia/Shanghai</span><br><span class="line"><span class="comment">#启动httpd</span></span><br><span class="line">systemctl start httpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#浏览器输入如下地址进行安装zabbix</span></span><br><span class="line">http://192.168.163.132/zabbix/setup.php</span><br><span class="line"><span class="comment">#如果安装有问题，如某个参数填错了，需要在如下文件中修改</span></span><br><span class="line">/etc/zabbix/web/maintenance.inc.php</span><br><span class="line"><span class="comment">#在浏览器中直接finish启动，默认账号密码是admin、zabbix</span></span><br></pre></td></tr></table></figure><h5 id="zabbix-agent配置"><a href="#zabbix-agent配置" class="headerlink" title="zabbix agent配置"></a>zabbix agent配置</h5><p>使用192.168.163.135作为一个agent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装agent</span></span><br><span class="line">yum install -y zabbix40-agent</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置/etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line">Server=192.168.163.132<span class="comment">#被动模式，指明允许来采样的服务器地址</span></span><br><span class="line">ListenPort=10050<span class="comment">#监听的端口</span></span><br><span class="line">ListenIP=0.0.0.0<span class="comment">#监听的地址</span></span><br><span class="line">StartAgent=3<span class="comment">#生成几个子进程来响应</span></span><br><span class="line">ServerActive=IP<span class="comment">#主动模式时将样本上交给哪个服务器</span></span><br><span class="line">Hostname=node1.dqy.com<span class="comment">#指明主机名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start zabbix-agent</span><br></pre></td></tr></table></figure><h4 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h4><p>配置顺序：host groups–&gt;host–&gt;applications–&gt;item–&gt;triggers(event)–&gt;action(conditions,operations)</p><p>通过condition定义监听哪个event，然后监听到就进行operation操作。operation包含remote command和alert</p><p>item可以生成简单的graph；多个graph构成screen；多个screen构成slide show</p><h5 id="设置host"><a href="#设置host" class="headerlink" title="设置host"></a>设置host</h5><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/new_host.png" alt></p><h5 id="设置item"><a href="#设置item" class="headerlink" title="设置item"></a>设置item</h5><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/item.png" alt></p><p>设置item时必须选择相应的key。所谓的key可以理解为一串指令的特征码。因为server想要获取agent的某些参数，肯定时agent执行某些命令的结果过滤而来的，而这个命令可能很长，因此使用key来定义一串命令。zabbix有自带的key(一般是系统运行的指标)，若需要自定义，只需在/etc/zabbix/zabbix_agentd.conf文件中的USER-DEFINED MONITORED PARAMETERS字段下添加即可。</p><p>另外，有的key可以传递参数，实际就是传给key对应的命令，类似脚本编程时用$传参。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在server端使用如下命令查看指定agent端对应的key的值，其中[]内即为参数</span></span><br><span class="line">zabbix_get -s 192.168.163.135 -k <span class="string">"net.if.in[ens33,packets]"</span></span><br></pre></td></tr></table></figure><h5 id="设置trigger"><a href="#设置trigger" class="headerlink" title="设置trigger"></a>设置trigger</h5><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/trigger1.png" alt></p><p>一个触发器由一个表达式构成，它定义了监控项所采取的数据的一个阈值，用于监控item的取值范围(表达式定义的是不合理区间，因此结果为真时说明有问题)。每一个触发器仅能关联至一个item，但可以为一个item同时使用多个触发器，从而实现不同级别的报警功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;server&gt;:&lt;key&gt;.&lt;function&gt;(&lt;parameter&gt;)&#125;&lt;operator&gt;&lt;constant</span><br><span class="line">server：主机名</span><br><span class="line">key：主机上关系的相应监控项的key</span><br><span class="line">function：评估采集到的数据是否在合理范围内所用的函数，主要有：avg、count、change、date、dayofweek、delta、diff、iregexp、last、max、min、nodata、now、sum等</span><br><span class="line">parameter：函数参数。正常表示以秒为单位的数值，如果参数前面加#作为前缀，则表示最近几次的取值。如sum(300)表示300秒内的取值；sum(#10)表示最近10次取值之和。</span><br><span class="line">另外avg、count、last、min、max还支持使用第二个参数，用于完成时间限定；例如，max(1h,7d)表示1小时检测依次且将返回一周之前的最大值。</span><br><span class="line">对于last函数来说，last(0)表示last(#1)，即最后一次</span><br></pre></td></tr></table></figure><h5 id="设置action"><a href="#设置action" class="headerlink" title="设置action"></a>设置action</h5><p>action由condition和operation组成。在Configuration标签下的Actions标签进行编辑。</p><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/action1.png" alt></p><p>如上图，在Action标签中定义Condition，指明trigger后选择对应条目即可。</p><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/action2.png" alt></p><p>在上图Operation界面定义满足condition后的操作，可以有多个操作(动作可以由多个步骤组成)，通过step来定义各个操作的执行步骤。其中Default operation step duration表示默认默认操作步骤持续时间。下面的steps：1 -1表示当前步骤为第一步持续时长为1；2-2表示第二步持续时长为1；3-4表示第三步持续时长为2步(即由3、4两小步组成)；5-7表示第四步持续时长为3步(即由5、6、7三小步组成)。这种设置可以达到警报升级的作用。</p><ul><li><p>condition：触发此动作的条件，一般通过trigger触发</p></li><li><p>operation：触发条件满足时要采取的动作。包括send message和remote command。</p><ul><li><p>remote command包括：IPMI命令、custom script(常用)、ssh、telnet、global script</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用remote command之前还需要如下设置</span></span><br><span class="line"><span class="comment">#给在agent端给zabbix定义sudo规则，/etc/sudoers</span></span><br><span class="line">zabbix ALL=(ALL) ALL</span><br><span class="line"><span class="comment">#agent主机设置支持远程命令功能</span></span><br><span class="line">EnableRemoteCommands=1</span><br></pre></td></tr></table></figure></li></ul><p>#注意<br>  不支持active模式的agent；不支持代理模式、可以使用宏、命令长度不超过255字符、zabbix-server仅执行命令而不关心命令是否执行成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ send message：发送报警信息给关联的用户(一般是server主机上定义的用户)。发信息的信道可以使用脚本来发布(实现打电话、微信等)。具体步骤如下：</span><br><span class="line"></span><br><span class="line">  + 定义Administration的meda type，指明邮件服务器及发件人</span><br><span class="line">  + 在Administration的user中的media选项定义收件人、收件时间等</span><br></pre></td></tr></table></figure></li></ul><h5 id="设置报警媒介"><a href="#设置报警媒介" class="headerlink" title="设置报警媒介"></a>设置报警媒介</h5><p>在Administration标签的Media types标签可以设置报警媒介的信息。zabbix支持的报警媒介有：</p><ul><li><p>Email：邮件。通过设置的SMTP邮件服务器向指定用户发送报警信息</p></li><li><p>Script：脚本。自动调用指定脚本进行报警(脚本位置在配置文件中的AlertScriptsPath字段定义)。在定义脚本时可以使用参数，参数在设置时可以用宏指定。具体宏的介绍在下文。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用脚本时可以定义不同的参数，调用时使用宏来作为参数调用</span></span><br><span class="line"><span class="comment">#脚本默认放在server端的/var/lib/zabbixsrv/alertscripts目录下，若有新的脚本放入必须重启服务</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">to=<span class="variable">$1</span></span><br><span class="line">subject=<span class="variable">$2</span></span><br><span class="line">context=<span class="variable">$3</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"<span class="variable">$context</span>"</span> | mail -s <span class="string">"<span class="variable">$subject</span>"</span> <span class="string">"<span class="variable">$to</span>"</span></span><br></pre></td></tr></table></figure><ul><li>SMS、Jabber、Ez Texting：都是北美服务，此处不涉及</li></ul><p>设置好报警媒介后到Administration标签下的User标签定义用户的报警媒介，此处可以设置收件人。</p><h5 id="自定义图形"><a href="#自定义图形" class="headerlink" title="自定义图形"></a>自定义图形</h5><p>通常用于将多个监控项的图像结合到一起使用。在Configuration标签下的Hosts标签下选定hosts的graphs即可设置。</p><p>定义时相关属性如下：</p><ul><li>name：图像唯一名称</li><li>width、height：宽度和高度，单位为像素</li><li>graph type：图像类型，线状图(normal)、堆积面积图(stacked)、饼图(pie)、分离型饼图(exploded)</li><li>show legend：是否显示图例，即图像数据序列说明</li><li>show working time：是否高亮显示工作时间区域，不适用pie和exploded</li><li>show triggers：是否显示触发器，不适用pie和exploded</li><li>Y axis MIN value：Y轴最小刻度<ul><li>Calculated：自动计算</li><li>Fixed：固定值，不适用pie和exploded</li><li>Item：相关item的最近一次取值为其最小刻度</li></ul></li><li>Y axis MAX value：Y轴最大刻度，相关选项同上</li><li>Items：图形展示的数据列所来自的item，一个图形中可以同时展示多个item。item相关属性如下：<ul><li>Function：展示各种聚合数据<ul><li>min：仅展示最小值</li><li>avg：仅展示平均值</li><li>max：仅展示最大值</li><li>all：展示所有，即上述三种数据</li></ul></li><li>Draw stype：绘图风格，仅用于线状图<ul><li>Line：绘制为简单线条</li><li>Filled region：区域填充图，即面积图</li><li>Bold line：加粗线条</li><li>Dot：虚线图，以稀疏点组成</li><li>Dashed line：虚线图，以破折号组成</li></ul></li><li>Y axis side：Y轴显示的位置，可以为图形左侧或右侧</li><li>Colour：图形颜色</li></ul></li></ul><h5 id="定义screen"><a href="#定义screen" class="headerlink" title="定义screen"></a>定义screen</h5><p>screen即屏幕。屏幕用于集中展示多个数据源的相关信息，可实现快速浏览关注的信息。从根本上讲，screen就是一个图标，可以在创建时指定行数列数(即每行多少个图形，共多少行)，而后在每个格子中指定要展示的内容。</p><p>在Monitoring的Screens标签下创建，根据定义显示即可。map也差不多配置，这里不多说。</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>Macro，即一种预设的文本替换模式，可以理解为文本类型的变量。主要分为两类：</p><ul><li>内建：{MACRO_NAME}</li><li>自定义：{$MACRO_NAME}</li></ul><p>可以在三个级别使用：</p><ul><li>Global：全局宏。在Administration的General右侧的Macros选项中定义</li><li>template：模板宏。直接编辑相应主机或模板属性即可</li><li>Host：主机宏。在Configuration的Hosts标签下选定某个host后选择上方的Macros标签即可定义主机宏，该宏只对此主机使用。</li></ul><p>宏定义优先级：Host&gt;Template&gt;Global</p><p>具体宏参照官方文档：</p><p>[]: <a href="https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location" target="_blank" rel="noopener">https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location</a></p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>模板是一些列配置的集合，支持模板嵌套定义，用于快速部署和重复应用(链接)。具体配置和host一样，可以指定Application、host、trigger、item、graph、screen、discovery、web。具体过程和普通定义时一样，依次添加各种item和trigger即可。模板可以导出与导入。</p><h4 id="维护时间"><a href="#维护时间" class="headerlink" title="维护时间"></a>维护时间</h4><p>用于实现将某台服务器下线管理而不引起trigger报警。定义在Configuration的Maintenance中。在设置trigger时需要指定Maintenance status not in maintenance来实现在维护时间不触发触发器。</p><h4 id="自定义监控项"><a href="#自定义监控项" class="headerlink" title="自定义监控项"></a>自定义监控项</h4><p>实现用户自定义item key，从而实现特有数据指标的监控。需要定义在agent端且定义好后需要重启agent。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法,[*]表示可以接收任意个参数，且这些参数可以在command中使用$1-&gt;$9进行引用</span></span><br><span class="line"><span class="comment">#另外，如果在命令中需要使用$符号且key中有参数时，例如awk中打印某一字段时会使用$，那么就要使用$$来保留原来的$。</span></span><br><span class="line">UserParameter=&lt;key[*]&gt;,&lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑配置文件/etc/zabbix/zabbix_agentd.d/目录下新建一个配置文件即可</span></span><br><span class="line">UserParameter=os.memory.used,free -m | awk <span class="string">"/^Mem/&#123;print <span class="variable">$3</span>&#125;"</span></span><br><span class="line"><span class="comment">#重启zabbix-agentd，之后在服务端之间使用os.memory.used作为key即可</span></span><br><span class="line">systemctl restart zabbix-agentd</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例：实现监控mysql数据库的插入、查询、删除命令的使用次数，可能需要做词尾牟定“&gt;”</span></span><br><span class="line">UserParameter=Mysql.dm[*],mysql -h<span class="variable">$1</span> -u<span class="variable">$2</span> -p<span class="variable">$3</span> -e <span class="string">'SHOW GLOBAL STATUS'</span> | awk <span class="string">'/Com_$4\&gt;/&#123;print $$2&#125;'</span></span><br><span class="line"><span class="comment">#server端执行测试，测试前在agent的数据库需要用户授权访问</span></span><br><span class="line">zabbix-get -s 192.168.163.135 -p 10050 -k <span class="string">"Mysql.dml[192.168.163.132,root,dqy751421,select]"</span></span><br></pre></td></tr></table></figure><h4 id="网络发现"><a href="#网络发现" class="headerlink" title="网络发现"></a>网络发现</h4><p>zabbix基于http、icmp、ssh、ldap、tcp、snmp、telnet等协议扫描指定网络内主机。网络发现主要分为discovery和actions两个阶段，一旦主机被发现，如果想对其进行操作，需要由action来决定。</p><h5 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h5><p>zabbix会周期的扫描事先定义在网络发现规则中的网络地址范围，扫描的频率可以根据每个规则所定义的频率来设定。一旦有主机被发现就会触发Discovery的event事件。有如下八种事件：</p><table><thead><tr><th>事件</th><th>产生原因</th></tr></thead><tbody><tr><td>Service Up</td><td>服务上线</td></tr><tr><td>Service Down</td><td>服务离线</td></tr><tr><td>Host UP</td><td>主机上线(有服务)</td></tr><tr><td>Host Down</td><td>主机下线(无服务)</td></tr><tr><td>Service Discovered</td><td>服务被发现(第一次)</td></tr><tr><td>Service Lost</td><td>服务丢失</td></tr><tr><td>Host Discovered</td><td>主机被发现</td></tr><tr><td>Host Lost</td><td>主机丢失</td></tr></tbody></table><p>在Configuration的Discovery标签下进行网络主机发现的定义，如下所示</p><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/discovery.png" alt></p><p>Name：指明发现服务名称</p><p>IP range：定义扫描的ip段</p><p>Update interval：扫描间隔(不宜过短，会严重降低zabbix性能)</p><p>Checks：基于什么协议进行扫描</p><p>Device uniqueness criteria：指明基于ip地址来唯一确定主机</p><p><strong>注意</strong>：网络发现中添加主机时会自动创建interface，哪个检测成功就会创建相应的interface。如果某服务同时相应多个interface那么就会创建多个；如果同一种发现机制返回非唯一数据(多块网卡)，则第一个接口被默认识别，其他的被识别为额外接口；即便是某主机开始时只有agent接口，后来通过SNMP又发现它，同样会为其添加SNMP接口；不同的主机如果返回相同数据，则第一个主机被添加，余下的主机被当作第一个主机的额外接口。</p><h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><p>网络发现中的事件可以触发action，从而自动执行指定的操作。action如下：</p><table><thead><tr><th>Action</th><th>解释</th></tr></thead><tbody><tr><td>Send notifications</td><td>发送通知</td></tr><tr><td>Adding/removing hosts</td><td>添加/移除主机</td></tr><tr><td>Enabling/disabling hosts</td><td>启用/禁用主机</td></tr><tr><td>Adding hosts to a group</td><td>添加主机到组</td></tr><tr><td>Removing hosts from a group</td><td>从组中移除主机</td></tr><tr><td>Linking hosts to/unlinking from a template</td><td>链接/删除链接模板到主机</td></tr><tr><td>Executing remote scripts</td><td>执行远程脚本</td></tr></tbody></table><p>在配置Action时，切换Discovery条目进行配置。</p><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/discovery_action.png" alt></p><p>首先配置Conditions：需要指定Discovery rule为上面定义的Discovery的name；定义Discovery Status为某个event状态即可。</p><p>然后配置Operations：一般设置增加到某个组并连接到某个模板实现监控项的一键设置。</p><h4 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h4><p>用于减少zabbix-server端不断扫描造成的资源浪费，且不清楚哪些网段主机可能被添加到zabbix中时使用。该功能用于active模式的agent。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置agent的/etc/zabbix-agentd.conf</span></span><br><span class="line"><span class="comment">#配置agent端active模式下监听的server地址</span></span><br><span class="line">ServerActive=192.168.163.132</span><br><span class="line"><span class="comment">#被动模式地址也配置，因为有的item设置的是被动模式的监控项</span></span><br><span class="line">Server=192.168.163.132</span><br><span class="line"><span class="comment">#设置主机名</span></span><br><span class="line">Hostname=node2.dqy.com</span><br><span class="line"><span class="comment">#设置监听地址，此处不要设置为0.0.0.0，因为该ip会被填加到server识别的host的ip地址处</span></span><br><span class="line">ListenIP=192.168.163.136</span><br><span class="line"><span class="comment">#设置主机唯一标识(只用于auto registration)</span></span><br><span class="line">HostMetadata=artest</span><br></pre></td></tr></table></figure><p>该功能同样需要配置相关Action。在Server端配置Action时，切换Auto Registration条目进行配置。具体配置项目如下：</p><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/quto.png" alt></p><p>然后配置Operations，一般配置添加至某个hostgroup以及连接模板即可。需要注意的是模板里设置的item可能都是被动监控方式的，此处需要额外配置主动监控的item。</p><h4 id="LLD"><a href="#LLD" class="headerlink" title="LLD"></a>LLD</h4><p>底层发现，server端会向agent端请求一些数据，而server端根据这些数据来填充特定的item值。常见的item有：#IFNAME(网络接口名称)，#FSNAME(文件系统名称)</p><p>它主要是用于定义模板时获取不同agent端的不同的网卡接口、文件系统等信息。这些值存放在agent端的某些key当中，key可以通过zabbix的数据库查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select key_ from items where key_ like &#39;%discovery%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/lld_discovery.png" alt></p><p>如上图所示，Name随意填写，Key要填写上面数据库命令查到的对应项(有很多，此处不一一列举)。注意，此处定义好后发现主机时会获取相应的key的值填到对应的item项中，如网卡信息填入#IFNAME中，文件系统信息填入#FSNAME中。这些变量都可以在定义host的item时使用，从而获取不同主机的不同信息。</p><h4 id="web监控"><a href="#web监控" class="headerlink" title="web监控"></a>web监控</h4><p>zabbix可以对web站点进行可用性检测，它可以检测获取的html页面中是否包含预设的字符串，也可以实现登录和点击，具体步骤如下：</p><ul><li>创建web监控需要先定义一个web scenarios(在configuration中选定host的web scenario即可定义)</li></ul><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/web1.png" alt></p><p>​    Name：唯一标识的scenario名称</p><p>​    Application：选择一个已存在的application，web scenario必须属于一个application</p><p>​    Update interval：web scenario的执行间隔</p><p>​    Agent：请求模仿的浏览器类型</p><p>​    Variables：用户自定义一些宏，如用户名密码之类</p><p>​    Attempt：执行多少次</p><ul><li>web方案包括一个或多个HTTP请求或步骤(step)，每个步骤的执行过程按照预先定义的顺序进行</li></ul><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/web_step.png" alt></p><p>​    Name：唯一的step名称</p><p>​    URL：请求的URL</p><p>​    Query fields：请求的数据库查询</p><p>​    Post fields：post请求的相关数据和值</p><p>​    Variables：定义变量</p><p>​    Required status codes：希望返回的状态码，一般为200</p><p>​    Required string：希望获取的字符串</p><p>​    TimeOut：请求的超时时长</p><ul><li>有的网站存在认证，需要手动提供</li></ul><p><img src="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/web_auth.png" alt></p><p>​    HTTP authentication：认证方式</p><p>​    SSL：剩余ssl相关证书方面如密钥文件、证书文件等</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h4 id=&quot;监控对象&quot;&gt;&lt;a href=&quot;#监控对象&quot; class=&quot;headerlink&quot; title=&quot;监控对象&quot;&gt;&lt;/a&gt;监控对象&lt;/h4&gt;&lt;p&gt;主机、交换机、路由器等&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>ansible详解</title>
    <link href="http://yoursite.com/2020/01/22/ansible%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/22/ansible%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-22T12:11:38.000Z</published>
    <updated>2020-01-22T12:15:57.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>高度模块化的自动化运维工具，基于ssh协议实现了批量系统配置、批量程序部署、批量运行命令等功能。</p><a id="more"></a><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/01/22/ansible%E8%AF%A6%E8%A7%A3/ansible.jpg" alt></p><ul><li>Host inventory：定义管理主机的清单，包括ip、账号密码(基于密钥)等</li><li>Playbooks：定义每个主机扮演不同的角色，每个角色执行不同的命令，使用YAML格式定义</li><li>Core Modules：核心模块</li><li>Custom Modules：自定义模块</li><li>Plugins：用于通知及日志插件</li><li>Connection Plugins：基于ssh的连接主机的插件</li><li>Ansible：主控进程</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul><li><p>加载自己的配置文件，默认/etc/ansible/ansible.cfg；</p></li><li><p>查找对应的主机配置文件，找到要执行的主机或者组；</p></li><li><p>加载自己对应的模块文件，如command；</p></li><li><p>通过ansible将模块或命令生成对应的临时py文件(python脚本)， 并将该文件传输至远程服务器；</p></li><li><p>对应执行用户的家目录的.ansible/tmp/XXX/XXX.py文件；</p></li><li><p>给文件 +x 执行权限；</p></li><li><p>执行并返回结果；</p></li><li><p>删除临时.ansible/tmp/XXX/XXX.py文件，sleep 0退出。</p></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>ansible自身配置文件：/etc/ansible/ansible.cfg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#各种默认选项</span></span><br><span class="line">[default]</span><br><span class="line">inventory = /etc/ansible/hosts      <span class="comment">#这个参数表示资源清单inventory文件的位置</span></span><br><span class="line">library = /usr/share/ansible        <span class="comment">#指向存放Ansible模块的目录，支持多个目录方式，只要用冒号（：）隔开就可以</span></span><br><span class="line">forks = 5       <span class="comment">#并发连接数，默认为5</span></span><br><span class="line">sudo_user = root        <span class="comment">#设置默认执行命令的用户</span></span><br><span class="line">remote_port = 22        <span class="comment">#指定连接被管节点的管理端口，默认为22端口，建议修改，能够更加安全</span></span><br><span class="line">host_key_checking = False       <span class="comment">#设置是否检查SSH主机的密钥，值为True/False。关闭后第一次连接不会提示配置实例</span></span><br><span class="line">timeout = 60        <span class="comment">#设置SSH连接的超时时间，单位为秒</span></span><br><span class="line">log_path = /var/<span class="built_in">log</span>/ansible.log     <span class="comment">#指定一个存储ansible日志的文件（默认不记录日志）</span></span><br><span class="line">module_name = <span class="built_in">command</span><span class="comment">#默认module为command</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与权限提升有关</span></span><br><span class="line">[privilege_escalation]</span><br><span class="line">become=True</span><br><span class="line">become_mothod=sudo<span class="comment">#升级方法</span></span><br><span class="line">become_user=root<span class="comment">#升级为哪个用户</span></span><br><span class="line">become_ask_pass=False<span class="comment">#升级时是否提供密码</span></span><br></pre></td></tr></table></figure><h3 id="设置ssh"><a href="#设置ssh" class="headerlink" title="设置ssh"></a>设置ssh</h3><p>因为ansible基于ssh控制各个主机，因此使用密钥验证的ssh登录会比较安全和方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次回车确认，全部默认即可。该指令会在用户家目录下生成.ssh文件夹，里面包括私钥文件id_rsa和公钥文件id_rsa.pub。</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#将公钥复制到指定主机的~/.ssh/authorized_key文件中</span></span><br><span class="line">ssh-copy-id root@192.168.163.135</span><br><span class="line">ssh-copy-id root@192.168.163.136</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install ansible –y</span><br></pre></td></tr></table></figure><h3 id="ansible命令"><a href="#ansible命令" class="headerlink" title="ansible命令"></a>ansible命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [options]</span><br><span class="line">-m MODULE_NAME：指明调用模块名</span><br><span class="line">-a MODULE_ARGS：指明模块参数</span><br><span class="line">-C：不真实运行，模拟运行结果</span><br><span class="line">-f FORKS：定义每次对多少主机进行操作(默认5个)</span><br><span class="line">--list-hosts：根据&lt;host-pattern&gt;列出符合的主机</span><br><span class="line">-i INVENTORY：指明host配置文件(默认在/etc/ansible/hosts)</span><br><span class="line">--syntax-check：检测playbook的语法是否有错误</span><br><span class="line">-t TREE：将日志输出到指定文件</span><br><span class="line">--private-key=PRIVATE_KEY_FILE：指明用于连接认证的密钥文件</span><br><span class="line">-u REMOTE_USER：指明连接用户名(默认none)</span><br><span class="line">-c CONNECTION：指明ssh连接方式(默认smart)</span><br><span class="line">-s：远程执行命令时使用sudo命令</span><br><span class="line">-S：远程执行命令时使用su命令</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取帮助</span></span><br><span class="line">ansible-doc [options]</span><br><span class="line">-l：列出可用模块</span><br><span class="line">-s MODULE_NAME：显示指定模块的可设置选项，有“=”的选项是必须设置的</span><br></pre></td></tr></table></figure><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="ping模块"><a href="#ping模块" class="headerlink" title="ping模块"></a>ping模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主要用于主机连通性测试</span></span><br><span class="line">[root@www ~] ansible all -m ping </span><br><span class="line">192.168.163.136 | SUCCESS =&gt; &#123;</span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line">    &#125;, </span><br><span class="line">    "changed": false, </span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br><span class="line">192.168.163.135 | SUCCESS =&gt; &#123;</span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line">    &#125;, </span><br><span class="line">    "changed": false, </span><br><span class="line">    "ping": "pong"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="group模块"><a href="#group模块" class="headerlink" title="group模块"></a>group模块</h4><p>用于创建用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="comment">#必选项，指定组的名称</span></span><br><span class="line">gid<span class="comment">#设置组的GID号，默认依次往后叠加</span></span><br><span class="line">state<span class="comment">#指定组的状态，默认为创建(present)，设置值absent则为删除</span></span><br><span class="line">system<span class="comment">#设置值为yes，表示创建为系统组，默认为no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加组</span></span><br><span class="line">ansible all -m group -a <span class="string">"name=mygrp"</span></span><br></pre></td></tr></table></figure><h4 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h4><p>用于管理和创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="comment">#必选项，指定用户名</span></span><br><span class="line">comment<span class="comment">#用户的描述信息</span></span><br><span class="line">createhome<span class="comment">#是否创建家目录</span></span><br><span class="line">force<span class="comment">#在使用state=absent时, 行为与userdel –force一致.</span></span><br><span class="line">group<span class="comment">#指定基本组</span></span><br><span class="line">groups<span class="comment">#指定附加组，如果指定为(groups=)表示删除所有组</span></span><br><span class="line">home<span class="comment">#指定用户家目录</span></span><br><span class="line">move_home<span class="comment">#如果设置为home=时, 试图将用户主目录移动到指定的目录</span></span><br><span class="line">non_unique<span class="comment">#该选项允许改变非唯一的用户ID值</span></span><br><span class="line">password<span class="comment">#指定用户密码</span></span><br><span class="line">remove<span class="comment">#在使用state=absent时, 行为是与userdel –remove一致</span></span><br><span class="line">shell<span class="comment">#指定默认shell</span></span><br><span class="line">state<span class="comment">#设置帐号状态，默认为present创建，指定值为absent表示删除</span></span><br><span class="line">system<span class="comment">#当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户</span></span><br><span class="line">uid<span class="comment">#指定用户的uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加用户</span></span><br><span class="line">ansible all -m user -a <span class="string">"uid=5000 name=testuser state=present groups=mygrp shell=/bin/sh"</span></span><br></pre></td></tr></table></figure><h4 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h4><p>用于将文件复制到远程主机，同时支持给定内容生成文件和修改权限等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src<span class="comment">#被复制到远程主机的本地文件。可以是绝对路径，也可以是相对路径。如果路径是一个目录，则会递归复制。</span></span><br><span class="line">content<span class="comment">#用于替换"src"，可以直接指定文件的内容，其将生成为目标文件的内容</span></span><br><span class="line">dest=<span class="comment">#必选项，将源文件复制到的远程主机的绝对路径</span></span><br><span class="line">backup<span class="comment">#当文件内容发生改变后，在覆盖之前把源文件备份，备份文件包含时间信息</span></span><br><span class="line">directory_mode　　　　<span class="comment">#递归设定目录的权限，默认为系统默认权限</span></span><br><span class="line">force<span class="comment">#当目标主机包含该文件，但内容不同时，设为"yes"，表示强制覆盖；设为"no"，表示目标主机的目标位置不存在该文件才复制。默认为"yes"</span></span><br><span class="line">others<span class="comment">#所有的 file 模块中的选项可以在这里使用</span></span><br><span class="line">group<span class="comment">#复制后目标文件的属组</span></span><br><span class="line">owner<span class="comment">#复制后目标文件的属主</span></span><br><span class="line">mode<span class="comment">#复制后目标文件的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#复制文件</span></span><br><span class="line">ansible all -m copy -a <span class="string">"src=/etc/fstab dest=/tmp/fstab.ansible mode=600"</span></span><br><span class="line"><span class="comment">#复制目录，若src的目录最后以"/"结尾，则只复制目录内的内容，而不复制目录本身</span></span><br><span class="line">ansible all -m copy -a <span class="string">"src=/etc/pam.d dest=/tmp/"</span></span><br><span class="line"><span class="comment">#使用content生成文件，默认不换行</span></span><br><span class="line">ansible all -m copy -a <span class="string">"content='hi there\n' dest=/tmp/hi.txt"</span></span><br></pre></td></tr></table></figure><h4 id="fetch模块"><a href="#fetch模块" class="headerlink" title="fetch模块"></a>fetch模块</h4><p>用于从远程主机复制文件到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dest=<span class="comment">#必选项，用来存放文件的目录</span></span><br><span class="line">src=<span class="comment">#必选项，在远程拉取的文件，并且必须是一个file，不能是目录</span></span><br></pre></td></tr></table></figure><h4 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a>command模块</h4><p>在远程主机执行命令，但是无法解析管道等shell特性的命令符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chdir</span><span class="comment">#在执行命令之前，先切换到该目录</span></span><br><span class="line">free_form=<span class="comment">#必选项，要执行的Linux指令，一般使用ansible的-a参数代替。</span></span><br><span class="line">creates<span class="comment">#一个文件名，当这个文件存在，则该命令不执行,可以用来做判断</span></span><br><span class="line">removes<span class="comment">#一个文件名，这个文件不存在，则该命令不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行ifconfig命令</span></span><br><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">"ifconfig"</span></span><br><span class="line"><span class="comment">#切换目录后创建目录</span></span><br><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">"chdir=/var/tmp mkdir hi.dir"</span></span><br></pre></td></tr></table></figure><h4 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h4><p>在远程主机调用shell来执行命令(具体用法与command一样)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chdir</span><span class="comment">#在执行命令之前，先切换到该目录</span></span><br><span class="line">free_form=<span class="comment">#必选项，要执行的Linux指令，一般使用ansible的-a参数代替。</span></span><br><span class="line">creates<span class="comment">#一个文件名，当这个文件存在，则该命令不执行,可以用来做判断</span></span><br><span class="line">removes<span class="comment">#一个文件名，这个文件不存在，则该命令不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改密码</span></span><br><span class="line">ansible all -m shell -a <span class="string">"echo dqy751421 | passwd --stdin testuser"</span></span><br></pre></td></tr></table></figure><h4 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h4><p>主要用于设置文件属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">path=<span class="comment">#必选项，设置操作对象路径</span></span><br><span class="line">force<span class="comment">#需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no</span></span><br><span class="line">group<span class="comment">#定义文件或目录的属组</span></span><br><span class="line">owner<span class="comment">#定义文件或目录的属主</span></span><br><span class="line">mode<span class="comment">#定义文件或目录的权限</span></span><br><span class="line">src<span class="comment">#当state=link时指明需要连接的源文件</span></span><br><span class="line">recurse<span class="comment">#递归设置文件的属性，只对目录有效，后面跟上src：被链接的源文件路径，只应用于state=link的情况</span></span><br><span class="line">dest<span class="comment">#被链接到的路径，只应用于state=link的情况</span></span><br><span class="line">state<span class="comment">#状态，有以下选项：</span></span><br><span class="line">directory：如果目录不存在，就创建目录</span><br><span class="line">file：即使文件不存在，也不会被创建</span><br><span class="line">link：创建软链接</span><br><span class="line">hard：创建硬链接</span><br><span class="line">touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</span><br><span class="line">absent：删除目录、文件或者取消链接文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line">ansible all -m file -a <span class="string">"path=/var/tmp/hello.dir state=directory"</span></span><br><span class="line"><span class="comment">#创建符号链接，将src的文件，创建成path指向的link文件</span></span><br><span class="line">ansible all -m file -a <span class="string">"src=/var/tmp/fstab.ansible path=/var/tmp/fstab.link state=link"</span></span><br></pre></td></tr></table></figure><h4 id="cron模块"><a href="#cron模块" class="headerlink" title="cron模块"></a>cron模块</h4><p>该模块适用于管理cron定时计划</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">day<span class="comment">#每天应该运行的工作( 1-31, *, */2, etc )</span></span><br><span class="line">hour<span class="comment">#小时 ( 0-23, , /2, )</span></span><br><span class="line">minute<span class="comment">#分钟( 0-59, , /2, )</span></span><br><span class="line">month<span class="comment">#月( 1-12, *, /2, )</span></span><br><span class="line">weekday<span class="comment">#周 ( 0-6 for Sunday-Saturday,, )</span></span><br><span class="line">job<span class="comment">#指明运行的命令是什么</span></span><br><span class="line">name<span class="comment">#定时任务描述</span></span><br><span class="line">reboot<span class="comment">#任务在重启时运行，不建议使用，建议使用special_time</span></span><br><span class="line">special_time<span class="comment">#特殊的时间范围，参数：reboot（重启时），annually（每年），monthly（每月），weekly（每周），daily（每天），hourly（每小时）</span></span><br><span class="line">state<span class="comment">#指定状态，present表示添加定时任务，也是默认设置，absent表示删除定时任务</span></span><br><span class="line">user<span class="comment">#以哪个用户的身份执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#每3分钟同步一下时间</span></span><br><span class="line">ansible all -m cron -a <span class="string">"minute=*/3 job='/usr/sbin/ntpdate ntp1.aliyun.com' name=sync_time"</span></span><br></pre></td></tr></table></figure><h4 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h4><p>用于程序包安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="comment">#必选项，所安装的包的名称</span></span><br><span class="line">state<span class="comment">#present或者installed表示安装，latest表示安装最新的, absent或removed表示卸载软件。</span></span><br><span class="line">update_cache<span class="comment">#强制更新yum的缓存</span></span><br><span class="line">conf_file<span class="comment">#指定远程yum安装时所依赖的配置文件（安装本地已有的包）。</span></span><br><span class="line">disable_gpg_check<span class="comment">#是否禁止GPG checking，只用于presentor latest。</span></span><br><span class="line">disablerepo<span class="comment">#临时禁止使用yum库。只用于安装或更新时。</span></span><br><span class="line">enablerepo<span class="comment">#临时使用的yum库。只用于安装或更新时。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装nginx</span></span><br><span class="line">ansible all -m yum -a <span class="string">"name=nginx state=installed"</span></span><br></pre></td></tr></table></figure><h4 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h4><p>用于各种服务进程的管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="comment">#服务名称</span></span><br><span class="line">arguments<span class="comment">#命令行提供额外的参数</span></span><br><span class="line">enabled<span class="comment">#设置开机启动。</span></span><br><span class="line">runlevel<span class="comment">#开机启动的级别，一般不用指定。</span></span><br><span class="line">sleep<span class="comment">#在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。(定义在剧本中。)</span></span><br><span class="line">state<span class="comment">#有四种状态，分别为：started表示启动服务， stopped表示停止服务， restarted表示重启服务，reloaded表示重载配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nginx</span></span><br><span class="line">ansible all -m service -a <span class="string">"name=nginx state=started enabled=yes"</span></span><br></pre></td></tr></table></figure><h4 id="script模块"><a href="#script模块" class="headerlink" title="script模块"></a>script模块</h4><p>将本地脚本复制到远端服务器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free_form=<span class="comment">#必选项，要运行的脚本本地路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本实例</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ansible script"</span> &gt; /tmp/ansible.txt</span><br><span class="line">ansible all -m script -a <span class="string">"/tmp/test.sh"</span></span><br></pre></td></tr></table></figure><h4 id="setup模块"><a href="#setup模块" class="headerlink" title="setup模块"></a>setup模块</h4><p>可以获取系统变量，也就是facts。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible 192.168.163.135 -m setup | less</span><br></pre></td></tr></table></figure><h4 id="template模块"><a href="#template模块" class="headerlink" title="template模块"></a>template模块</h4><p>基于模板方式生成一个文件复制到远程主机，主要用于生成模块化的配置文件。注意文件根据习惯一般以.j2结尾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="comment">#指明模板文件</span></span><br><span class="line">dest=<span class="comment">#指明各主机上基于模板生成的文件</span></span><br><span class="line">owner<span class="comment">#定义属主</span></span><br><span class="line">group<span class="comment">#定义属组</span></span><br><span class="line">mode<span class="comment">#定义权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ansible all -m template -a <span class="string">"src=/etc/httpd/httpd.conf.j2 dest=/etc/httpd/httpd.conf"</span></span><br><span class="line"><span class="comment">#j2文件</span></span><br><span class="line">listen &#123;&#123; http_port &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><p>是基于YAML设计的用于ansible管理远端主机的配置文件。根据其描述可以执行一些列任务，从而达到连续配置的效果。</p><h4 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h4><p>host：关联到的主机</p><p>task：任务列表，即host需要执行的动作</p><p>variables：执行任务时需要的变量</p><p>templates：包含了模板语法的文本文件</p><p>handlers：由特定条件触发的任务(通过notify触发)</p><h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><ul><li><p>Hosts：运行指定任务的目标主机</p></li><li><p>remoute_user：在远程主机上执行任务的用户</p></li><li><p>task：任务列表(模块+模块参数)</p><ul><li>action：module arguments</li><li>module：arguments</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tasks：</span></span><br><span class="line">　　<span class="string">–</span> <span class="attr">name:</span> <span class="string">TASK_NAME</span></span><br><span class="line">　　　<span class="attr">module:</span> <span class="string">arguments</span></span><br><span class="line">　　　<span class="attr">notify:</span> <span class="string">HANDLERS_NAME</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">　　<span class="string">–</span> <span class="attr">name:</span> <span class="string">HANDLER_NAME</span></span><br><span class="line">　　　<span class="attr">module:</span> <span class="string">arguments</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>可以通过对不同的task定义不同的tag来实现只执行指定tag的任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行定义在first.yaml文件中拥有指定TAG_NAME的task</span></span><br><span class="line">ansible-playbook -t TAG_NAME first.yaml</span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>可以使用系统自带变量和自定义变量。</p><ul><li>facts：可以直接使用的变量，需要在playbook中使用”“来引用变量。因为只有playbook会gather facts，这些facts通过setup模块可以查看。</li><li>自定义变量。在playbook中自定义变量后，通过命令行传参</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义配置文件forth.yaml</span></span><br><span class="line">- hosts: 192.168.163.135</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install package &#123;&#123;pkgname&#125;&#125;</span><br><span class="line">    yum: name=&#123;&#123;pkgname&#125;&#125; state=installed</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用安装varnish</span></span><br><span class="line">ansible-playbook -e pkgname=varnish</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过vars标签定义，执行复制操作</span></span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">  - pbvar: playbook variable</span><br><span class="line">  tasks:</span><br><span class="line">  - name: copy</span><br><span class="line">    copy: content=&#123;&#123; pbvar &#125;&#125; dest=/var/tmp/vars.txt</span><br></pre></td></tr></table></figure><ul><li><p>host inventory变量。可以在host主机清单文件中直接引用</p><ul><li><p>inventory自带的参数，用于host文件中定义连接目标主机时使用</p><ul><li>ansible_ssh_host</li><li>ansible_ssh_port</li><li>ansible_ssh_user</li><li>ansible_ssh_pass</li><li>ansible_sudo_pass</li></ul></li><li><p>向不同的主机传递不同的变量，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP/HOSTNAMEvar1=value1 var2=value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例，表示向135这台主机可以传递http_port变量，其值为80</span></span><br><span class="line">192.168.163.135 http_port=80</span><br></pre></td></tr></table></figure></li><li><p>向组中的主机传递相同的变量，即一个组的主机共享变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[group:vars]</span><br><span class="line">var1=value1</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例，表示websrvs组拥有自定义变量http_port</span></span><br><span class="line">[websrvs:vars]</span><br><span class="line">http_port=8080</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>文本文件，基于Jinja2语法，使用template模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install nginx</span><br><span class="line">    yum: name=nginx stata=installed</span><br><span class="line">  - name: install core file</span><br><span class="line">    template: src=files/nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">    notify: restart nginx</span><br><span class="line">  - name: start nginx service</span><br><span class="line">    service: name=nginx state=started</span><br><span class="line">  handlers:</span><br><span class="line">  - name: restart nginx</span><br><span class="line">    service: name=nginx state=restarted</span><br><span class="line">    </span><br><span class="line"><span class="comment">#模板配置文件nginx.conf.j2</span></span><br><span class="line"><span class="comment">#facts内置变量</span></span><br><span class="line">worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;</span><br><span class="line"><span class="comment">#host清单定义的变量</span></span><br><span class="line">listen &#123;&#123; http_port &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><p>在task中使用，jinja2语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">- name: install conf file to centos7</span><br><span class="line">  template: src=/files/nginx.c7.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  when: ansible_distribution_major_version == <span class="string">"7"</span></span><br><span class="line">- name: install conf file to centos6</span><br><span class="line">  template: src=/files/nginx.c6.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  when: ansible_distribution_major_version == <span class="string">"6"</span></span><br></pre></td></tr></table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>在tasks中使用。对迭代项的引用，固定变量名为item，且要在task中使用with_items给定要迭代的元素列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表</span></span><br><span class="line">tasks:</span><br><span class="line">- name: install some packages</span><br><span class="line">  yum: name=&#123;&#123; item &#125;&#125; state=installed</span><br><span class="line">  with_items:</span><br><span class="line">  - httpd</span><br><span class="line">  - php</span><br><span class="line">  - nginx</span><br><span class="line">  </span><br><span class="line"><span class="comment">#元组</span></span><br><span class="line">- name: add some users</span><br><span class="line">  user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present</span><br><span class="line">  with_items:</span><br><span class="line">    - &#123; name: <span class="string">'user11'</span>, group: <span class="string">'group11'</span> &#125;</span><br><span class="line">    - &#123; name: <span class="string">'user12'</span>, group: <span class="string">'group12'</span> &#125;</span><br><span class="line">    - &#123; name: <span class="string">'user13'</span>, group: <span class="string">'group13'</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>自包含的目录结构。role文件定义于/etc/ansible/roles/问价夹下。它将playbook原本的设置进行分片，即tasks只定义在tasks文件夹下，其他以此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时，nginx就是一个角色，即一个role</span></span><br><span class="line">mkdir /etc/ansible/roles/nginx/&#123;tasks,vars,templates,files&#125; -pv</span><br><span class="line"></span><br><span class="line">nginx/</span><br><span class="line">tasks/：至少包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含</span><br><span class="line">vars/：至少包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含</span><br><span class="line">templates/：所有模板文件</span><br><span class="line">files/：存放由copy或script模块等调用的文件</span><br><span class="line">handlers/：至少应该包含一个名为main.yml的文件；其他文件需要在此文件中通过include进行包含</span><br><span class="line">meta/：至少应该包含一个名为main.yml的文件；定义当前角色的特殊设定及其依赖关系；其他文件需要在此文件中通过include进行包含</span><br><span class="line">defaul/：设定默认变量时使用此目录的main.yml文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在playbook中传递变量给角色</span></span><br><span class="line">- hosts:</span><br><span class="line">  remote_user:</span><br><span class="line">  roles:</span><br><span class="line">  - &#123; role: nginx, username: nginx &#125;<span class="comment">#调用角色nginx，传递变量username=nginx</span></span><br><span class="line">  - &#123; role: nginx, when: <span class="string">"ansible_distribution_major_version == '7'"</span> &#125; <span class="comment">#when条件判断</span></span><br></pre></td></tr></table></figure><h4 id="运行与测试"><a href="#运行与测试" class="headerlink" title="运行与测试"></a>运行与测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试，只检测可能发生的改变，不真正执行操作</span></span><br><span class="line">ansible-playbook --check</span><br><span class="line"><span class="comment">#列出运行任务的主机</span></span><br><span class="line">ansible-playbook --list-hosts</span><br><span class="line"><span class="comment">#语法检测</span></span><br><span class="line">ansible-playbook --syntax-check first.yaml</span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line">ansible-playbook all first.yaml</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以role定义一个playbook。此处以配置nginx为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时，nginx就是一个角色，即一个role</span></span><br><span class="line">mkdir /etc/ansible/roles/nginx/&#123;tasks,vars,templates,handles,files,meta,default&#125; -pv</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义tasks，直接在tasks目录下新建main.yml文件，内容直接写-name即可，不需要指明tasks标签</span></span><br><span class="line">- name: install nginx</span><br><span class="line">  yum: name=nginx state=installed</span><br><span class="line">  when: ansible_os_family == <span class="string">"RedHat"</span></span><br><span class="line">- name: install conf</span><br><span class="line">  template: src=vhost1.conf.j2 dest=/etc/nginx/conf.d/vhost1.conf</span><br><span class="line">  tags: conf</span><br><span class="line">  notify: restart nginx</span><br><span class="line">- name: start nginx</span><br><span class="line">  service: name=nginx state=started</span><br><span class="line">- name: install site home directory</span><br><span class="line">  file: path=&#123;&#123; ngxroot &#125;&#125; state=directory</span><br><span class="line">- name: install index page</span><br><span class="line">  copy: src=index.html dest=&#123;&#123; ngxroot &#125;&#125;/</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义template文件，以.j2结尾，此处为vhost1.conf.j2</span></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server-name &#123;&#123; ansible_fqdn &#125;&#125;;</span><br><span class="line">location / &#123;</span><br><span class="line">root <span class="string">"/ngxdata/vhost1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义handlers的main.yml文件</span></span><br><span class="line">- name: restart nginx</span><br><span class="line">  service: name=nginx state=restarted</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义变量于vars/目录下的main.yml文件中，格式为字典格式</span></span><br><span class="line">ngxroot: /ngxdata/vhost1</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义index.html于files/目录下</span></span><br><span class="line">&lt;h1&gt;vhost1&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在playbook中直接定义roles标签指明即可，此处命名为nginx.yaml</span></span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">  - nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line">ansible-playbook all nginx.yaml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;高度模块化的自动化运维工具，基于ssh协议实现了批量系统配置、批量程序部署、批量运行命令等功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="anxible" scheme="http://yoursite.com/tags/anxible/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>dhcp、pxe、cobbler</title>
    <link href="http://yoursite.com/2020/01/21/hcp%E3%80%81pxe%E3%80%81cobbler/"/>
    <id>http://yoursite.com/2020/01/21/hcp%E3%80%81pxe%E3%80%81cobbler/</id>
    <published>2020-01-21T11:49:33.000Z</published>
    <updated>2020-01-22T12:13:39.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>基于RARP协议实现动态申请IP地址。监听服务端的udp67，客户端的udp68。</p><a id="more"></a><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>客户端：dhcp discover，广播报文，发送自己的MAC地址</li><li>服务端：dhcp offer，广播报文，提供本地地址池的空闲的IP地址、掩码、网关等</li><li>客户端：dhcp request，广播报文，对第一个到达的dhcp offer报文予以回答，申请使用</li><li>服务端：dhcp ack，广播报文，同意客户端使用该报文，并通知局域网内所有主机</li></ul><h4 id="续租"><a href="#续租" class="headerlink" title="续租"></a>续租</h4><p>dhcp获得的ip地址有时间限制，因此每当有效时间到达一半时都要进行续租操作。</p><p>续租成功</p><ul><li>dhcp request</li><li>dhcp ack</li></ul><p>续租失败。失败后要继续广播discover发现报文请求新的IP地址。</p><ul><li>dhcp request</li><li>dhcp nak</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>/etc/dncp/dhcp.conf、/usr/share/doc/dhcp-4.2.5/dhcpd.conf.exampl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主机名</span></span><br><span class="line">option domain-name <span class="string">"example"</span>;</span><br><span class="line"><span class="comment">#dns服务器地址</span></span><br><span class="line">option domain-name-servers ns1.example.org;</span><br><span class="line"><span class="comment">#默认租约期限，单位为秒</span></span><br><span class="line">default-lease-time 43200;</span><br><span class="line"><span class="comment">#最长租约期限，单位为秒</span></span><br><span class="line">max-lease-time 86400;</span><br><span class="line"><span class="comment">#rsyslog相关的日志</span></span><br><span class="line"><span class="built_in">log</span>-facility local7;</span><br><span class="line"><span class="comment">#不同主机动态生成ip地址和网关等信息</span></span><br><span class="line">subnet 10.152.187.0 mask 255.255.255.0 &#123;</span><br><span class="line"><span class="comment">#定义地址范围</span></span><br><span class="line">range ip1~ip2;</span><br><span class="line"><span class="comment">#定义默认网关</span></span><br><span class="line">option routers 10.5.5.1;</span><br><span class="line"><span class="comment">#定义广播域地址</span></span><br><span class="line">option broadcast-address 10.5.5.31;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#不同主机固定设置不同选项。hostname只用来区别不同主机，命名随意</span></span><br><span class="line">host host_name &#123;</span><br><span class="line"><span class="comment">#指明主机的mac地址</span></span><br><span class="line">hardware ethernet mac_addr;</span><br><span class="line"><span class="comment">#固定所指明主机分配的ip地址，一般不为</span></span><br><span class="line">fixed-address ip_addr;</span><br><span class="line"><span class="comment">#指明当该主机请求dhcp时到server-name去加载filename指定的引导文件</span></span><br><span class="line">filename <span class="string">"pxelinux.0"</span>;</span><br><span class="line">server-name <span class="string">"FQDN"</span>;</span><br><span class="line"><span class="comment">#为tftp服务器地址</span></span><br><span class="line">next-server 192.168.163.131;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若host和subnet同时生效那么以host为准(作用域越小越准确)</span><br></pre></td></tr></table></figure><h4 id="分配信息库"><a href="#分配信息库" class="headerlink" title="分配信息库"></a>分配信息库</h4><p>/var/lib/dhcp/dhcpd.leases</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#监控dhcp过程</span></span><br><span class="line">dhclient -d</span><br></pre></td></tr></table></figure><h3 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h3><p>preboot excution environment。主要依赖于dhcp、tftp、yum仓库实现。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>首先根据dhcp服务器获取IP地址、掩码、网关等信息，然后根据dhcp所指向的next-server和filename连接指定tftp服务器；向tftp服务器加载bootloader、kernel、initrd等文件；然后向与内核相关yum仓库(ftp、http、nfs等)获取rpm包。最后根据kickstart文件实现自定义安装。</p><h4 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h4><p>tftp用于被dhcp指向，它主要存储bootloader、kernel、initrd等信息。默认tftp服务器共享文件保存在/var/lib/tftpboot。此处使用192.168.163.131作tftp服务器。tftp默认工作在udp69端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装服务端和客户端，安装在地址为192.168.163.131的服务器上</span></span><br><span class="line">yum -y install tftp-server tftp</span><br></pre></td></tr></table></figure><h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p>修改/etc/dhcp/dhcpd.conf文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#网关指向安装tftp的服务器地址</span></span><br><span class="line">option routers 192.168.163.2;</span><br><span class="line"><span class="comment">#指明dns服务器</span></span><br><span class="line">optino domain-name-servers 192.168.163.2;</span><br><span class="line"><span class="comment">#默认租约期限，单位为秒</span></span><br><span class="line">default-lease-time 43200;</span><br><span class="line"><span class="comment">#最长租约期限，单位为秒</span></span><br><span class="line">max-lease-time 86400;</span><br><span class="line"><span class="comment">#指明网段地址和子网掩码</span></span><br><span class="line">subnet 192.168.163.0 netmask 255.255.255.0 &#123;</span><br><span class="line">range 192.168.163.100 192.168.163.200;</span><br><span class="line">filename <span class="string">"pexlinux.0"</span>;</span><br><span class="line"><span class="comment">#指向tftp服务器，且文件放在tftp服务器的/var/lib/tftpboot目录下</span></span><br><span class="line">next-server 192.168.163.131;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置yum仓库"><a href="#配置yum仓库" class="headerlink" title="配置yum仓库"></a>配置yum仓库</h4><p>yum仓库主要用于安装时解决各种依赖问题。yum仓库可以使用ftp协议指向，也可以使用http协议指向。这里使用http协议，将yum仓库搭建在http服务器上，目录为/centos/7/x86_64/。</p><h4 id="配置kickstart文件"><a href="#配置kickstart文件" class="headerlink" title="配置kickstart文件"></a>配置kickstart文件</h4><p>该文件用于自动配置装机流程，例如分区，装载网络文件系统等。此处复制一份本机的anaconda-ks.cfg文件即可，将其放在http服务器上(和yum仓库一起)的/var/www/html/kickstarts/目录下，其中要修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指向指定yum源</span></span><br><span class="line">url --url=<span class="string">"http://192.168.163.131/centos/7/x86_64/"</span></span><br></pre></td></tr></table></figure><h4 id="安装syslinux"><a href="#安装syslinux" class="headerlink" title="安装syslinux"></a>安装syslinux</h4><p>syslinux是一个小型的Linux操作系统，也可以看作是一个linux的引导器，可以简化安装Linux的过程。我们需要/usr/share/syslinux/目录下的几个文件来辅助安装linux。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y syslinux</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要copy的文件</span></span><br><span class="line"><span class="comment">#PXE启动引导程序(NBP)</span></span><br><span class="line">prelinux.0</span><br><span class="line"><span class="comment">#指定分区启动  如：chain.c32 hd0,1</span></span><br><span class="line">chain.c32</span><br><span class="line"><span class="comment">#图像基础框架</span></span><br><span class="line">vesamenu.32</span><br><span class="line"><span class="comment">#目录界面框架</span></span><br><span class="line">menu.c32</span><br><span class="line"><span class="comment">#内存作为磁盘用(initrd)，用于引导IMG镜像的文件</span></span><br><span class="line">memdisk</span><br></pre></td></tr></table></figure><h4 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h4><p>需要复制如下文件到tftp服务器的/var/lib/tftpboot/下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/syslinux/&#123;chain.c32,mboot.c32,menu.c32,prelinux.0&#125; /var/lib/tftpboot/</span><br><span class="line">cp /boot/&#123;initramfs-3.10.0-1062.el7.x86_64.img,vmlinuz-3.10.0-1062.el7.x86_64&#125; /var/lib/tftpboot/</span><br><span class="line">mkdir prelinux.cfg</span><br><span class="line"><span class="comment">#在prelinux.cfg目录下新建并编辑default文件，该文件为用户所看到的菜单选项</span></span><br><span class="line"><span class="comment">#启动读取tftp服务器文件时会首先执行pxelinux.0这个文件</span></span><br><span class="line"><span class="comment">#定义使用命令字符界面</span></span><br><span class="line">default menu.c32</span><br><span class="line"><span class="comment">#用户选择时间</span></span><br><span class="line">prompt 5</span><br><span class="line"><span class="comment">#超时时间</span></span><br><span class="line">timeout 30</span><br><span class="line"><span class="comment">#菜单项(全局菜单)</span></span><br><span class="line">MENU TITLE CentOS 7 PXE Menu</span><br><span class="line"><span class="comment">#标签</span></span><br><span class="line">LABEL linux</span><br><span class="line"><span class="comment">#可选择的菜单项</span></span><br><span class="line">MENU LABEL Install Centos7 x86_64</span><br><span class="line"><span class="comment">#指明内核</span></span><br><span class="line">KERNEL vmlinuz-3.10.0-1062.el7.x86_64</span><br><span class="line"><span class="comment">#添加参数，其中安装源需要手动指定自己或者网上配置的repo，也要指定kickstart文件</span></span><br><span class="line"><span class="comment">#另外此处需要手动指定一个ip地址，虽然安装之前执行了dhcp，但那个ip是网卡的ip，对于内核来说还没有ip</span></span><br><span class="line">APPEND initrd=initramfs-3.10.0-1062.el7.x86_64.img ip=192.168.163.16 netmask=255.255.255.0 inst.repo=http://192.168.163.131/centos/7/x86_64 ks=http://192.168.163.131/kickstarts/centos7.cfg</span><br></pre></td></tr></table></figure><h3 id="Cobbler"><a href="#Cobbler" class="headerlink" title="Cobbler"></a>Cobbler</h3><p>pxe的二次封装。将多种系统的PXE安装通过软件结合起来，用户可以选择安装哪个。</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="/2020/01/21/hcp%E3%80%81pxe%E3%80%81cobbler/cobbler.jpg" alt></p><p>distribution(distro)：不同的发行版，包括内核、initrd等</p><p>profile：多个不同的kickstart配置文件</p><p>system：同一profile可以安装不同的系统(ip,掩码不同)</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装cobbler</span></span><br><span class="line">yum -y install cobbler</span><br><span class="line"><span class="comment">#安装dnsmasq，他是一个轻量化的dns和dhcp配置工具</span></span><br><span class="line">yum install -y dnsmasq</span><br><span class="line"><span class="comment">#启动tftp</span></span><br><span class="line">systemctl start tftp</span><br><span class="line"><span class="comment">#启动httpd</span></span><br><span class="line">systemctl start httpd</span><br><span class="line"><span class="comment">#启动cobblerd服务</span></span><br><span class="line">systemctl start cobblerd</span><br></pre></td></tr></table></figure><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置文件目录"><a href="#配置文件目录" class="headerlink" title="配置文件目录"></a>配置文件目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/etc/cobbler/settings    <span class="comment">#cobbler主配置文件</span></span><br><span class="line">/etc/cobbler/dhcp.template    <span class="comment">#DHCP服务的配置模板</span></span><br><span class="line">/etc/cobbler/tftpd.template   <span class="comment">#tftp服务的配置模板</span></span><br><span class="line">/etc/cobbler/rsync.template   <span class="comment">#rsync服务的配置模板</span></span><br><span class="line">/etc/cobbler/iso    <span class="comment">#iso模板配置文件目录</span></span><br><span class="line">/etc/cobbler/pxe    <span class="comment">#pxe模板文件目录</span></span><br><span class="line">/etc/cobbler/power   <span class="comment">#电源的配置文件目录</span></span><br><span class="line">/etc/cobbler/users.conf   <span class="comment">#web服务授权配置文件</span></span><br><span class="line">/etc/cobbler/users.digest   <span class="comment">#web访问的用户名密码配置文件</span></span><br><span class="line">/etc/cobbler/dnsmasq.template   <span class="comment">#DNS服务的配置模板</span></span><br><span class="line">/etc/cobbler/modules.conf   <span class="comment">#Cobbler模块配置文件</span></span><br></pre></td></tr></table></figure><h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/cobbler/config    <span class="comment">#配置文件</span></span><br><span class="line">/var/lib/cobbler/kickstarts    <span class="comment">#默认存放kickstart文件</span></span><br><span class="line">/var/lib/cobbler/loaders    <span class="comment">#存放的各种引导程序</span></span><br><span class="line">/var/www/cobbler     <span class="comment">#系统安装镜像目录</span></span><br><span class="line">/var/www/cobbler/ks_mirror    <span class="comment">#导入的系统镜像列表,cobbler distro文件目录</span></span><br><span class="line">/var/www/cobbler/images    <span class="comment">#导入的系统镜像启动文件</span></span><br><span class="line">/var/www/cobbler/repo_mirror    <span class="comment">#yum源存储目录</span></span><br></pre></td></tr></table></figure><h5 id="日志目录"><a href="#日志目录" class="headerlink" title="日志目录"></a>日志目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/cobbler/install.log    <span class="comment">#客户端系统安装日志</span></span><br><span class="line">/var/<span class="built_in">log</span>/cobbler/cobbler.log    <span class="comment">#cobbler日志</span></span><br></pre></td></tr></table></figure><h4 id="检查问题"><a href="#检查问题" class="headerlink" title="检查问题"></a>检查问题</h4><p>cobbler运行前需要检查各种配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cobbler check</span><br></pre></td></tr></table></figure><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>解决每个问题都需要重启服务来检测是否正确解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置server的值为本机可以连接外网的值，在/etc/cobbler/setting中</span></span><br><span class="line">server：192.168.163.131</span><br><span class="line"><span class="comment">#指明pxe的IP地址，一般为tftp的地址</span></span><br><span class="line">next_server：192.168.163.131</span><br><span class="line"><span class="comment">#在该/var/lib/cobbler/loaders目录下放引导文件，就是pxe的pxelinux.0，.32文件等；也可以联网下载</span></span><br><span class="line"><span class="comment">#也可以像pxe一样从syslinux中复制过来</span></span><br><span class="line">cobbler get-loaders</span><br><span class="line"><span class="comment">#安装rsync服务，主要用于同步各种rpm包</span></span><br><span class="line">yum install -y rsync</span><br><span class="line">systemctl start rsyncd</span><br><span class="line"><span class="comment">#安装pykickstart</span></span><br><span class="line">yum -y install pykickstart</span><br><span class="line"><span class="comment">#生成新的超级用户密码放在/etc/cobbler/setting文件中的default_password_crypted字段</span></span><br><span class="line"><span class="comment">#将下列命令生成的密码放到default_password_crypted字段</span></span><br><span class="line">openssl passwd -1 -salt <span class="string">'123456'</span> <span class="string">'frdqy'</span></span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cobbler sync</span><br></pre></td></tr></table></figure><h5 id="创建distro"><a href="#创建distro" class="headerlink" title="创建distro"></a>创建distro</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于定义发行版</span></span><br><span class="line">cobbler distro add [option]</span><br><span class="line">--kernel：内核</span><br><span class="line">--initrd：ramdisk</span><br><span class="line">--arch：平台</span><br><span class="line">--name：指定发行版名称</span><br><span class="line"><span class="comment">#导入光盘文件自动生成distro，path指明挂载路径，生成distro文件默认保存在/var/www/cobbler/下</span></span><br><span class="line"><span class="comment">#导入完成后会自动生成一个distro和profile文件，其中profile文件不能使用</span></span><br><span class="line">cobbler import --name=<span class="string">"Centos7"</span> --path=/media/cdrom</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成后可以使用如下命令查看</span></span><br><span class="line">cobbler distro list</span><br><span class="line">cobbler profile list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看distro或者profile配置信息</span></span><br><span class="line">cobbler profile report --name=Centos7</span><br></pre></td></tr></table></figure><h5 id="修改ks文件"><a href="#修改ks文件" class="headerlink" title="修改ks文件"></a>修改ks文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kickstart文件默认保存在/var/lib/cobbler/kickstarts/sample_end.ks中</span></span><br><span class="line"><span class="comment">#需要修改如下信息</span></span><br><span class="line"><span class="comment">#指定repo仓库，是导入自动生成的</span></span><br><span class="line">url=<span class="string">"http://192.168.163.131/cobbler/ks_mirror/centos7/"</span></span><br></pre></td></tr></table></figure><h5 id="添加profile"><a href="#添加profile" class="headerlink" title="添加profile"></a>添加profile</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据kickstart配置指定distro的profile</span></span><br><span class="line">cobbler profile add --name=Centos7 --distro=Centos7 --kickstart=/var/lib/cobbler/kickstarts/sample_end.ks</span><br></pre></td></tr></table></figure><h5 id="修改default"><a href="#修改default" class="headerlink" title="修改default"></a>修改default</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录界面默认设置保存在/var/lib/tftpboot/pxelinux.cfg/default文件下</span></span><br><span class="line">DEFAULT vesamenu.c32</span><br><span class="line">PROMPT 0</span><br><span class="line">MENU TITLE Cobbler | http://cobbler.github.io/</span><br><span class="line">TIMEOUT 20</span><br><span class="line">TOTALTIMEOUT 6000</span><br><span class="line">ONTIMEOUT centos7-x86_64</span><br><span class="line"></span><br><span class="line">LABEL <span class="built_in">local</span></span><br><span class="line">MENU LABEL (<span class="built_in">local</span>)</span><br><span class="line">MENU DEFAULT</span><br><span class="line">LOCALBOOT -1</span><br><span class="line"></span><br><span class="line">LABEL centos7-Everything-x86_64</span><br><span class="line">kernel /images/centos7-Everything-x86_64/vmlinuz</span><br><span class="line">MENU LABEL centos7-Everything-x86_64</span><br><span class="line">append initrd=/images/centos7-Everything-x86_64/initrd.img ksdevice=bootif lang=  kssendmac text  ks=http://192.168.163.131/cblr/svc/op/ks/profile/centos7-Everything-x86_64</span><br><span class="line">ipappend 2</span><br><span class="line">LABEL centos7-x86_64</span><br><span class="line">kernel /images/centos7-x86_64/vmlinuz</span><br><span class="line">MENU LABEL centos7-x86_64</span><br><span class="line">append initrd=/images/centos7-x86_64/initrd.img ksdevice=bootif lang=  text net.ifnames=0 biosdevname=0 kssendmac  ks=http://192.168.163.131/cblr/svc/op/ks/profile/centos7-x86_64</span><br><span class="line">ipappend 2</span><br><span class="line">MENU end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DHCP&quot;&gt;&lt;a href=&quot;#DHCP&quot; class=&quot;headerlink&quot; title=&quot;DHCP&quot;&gt;&lt;/a&gt;DHCP&lt;/h3&gt;&lt;p&gt;基于RARP协议实现动态申请IP地址。监听服务端的udp67，客户端的udp68。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="dhcp" scheme="http://yoursite.com/tags/dhcp/"/>
    
      <category term="pxe" scheme="http://yoursite.com/tags/pxe/"/>
    
      <category term="cobbler" scheme="http://yoursite.com/tags/cobbler/"/>
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>varnish详解</title>
    <link href="http://yoursite.com/2020/01/20/varnish%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/20/varnish%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-20T10:56:28.000Z</published>
    <updated>2020-01-20T11:01:12.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="有效性机制"><a href="#有效性机制" class="headerlink" title="有效性机制"></a>有效性机制</h4><h5 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h5><ul><li><p>expires：定义过期的绝对时间</p></li><li><p>Cache-Control：maxage=number，表示缓存number秒时间，是相对时长</p></li><li><p>Cache-Control：s-maxage=number，同上</p><a id="more"></a><h5 id="条件式请求"><a href="#条件式请求" class="headerlink" title="条件式请求"></a>条件式请求</h5></li><li><p>Last-Modified/If-Modified-Since，不基于固定时间来缓存，而是每次缓存客户端向上级服务器请求该资源的时间戳，如果没有改变，上级服务器返回304响应码即可。</p></li><li><p>Etag/If-None-Match，基于文件内容的校验码机制，其余同上</p></li></ul><p>通常将上述两种请求方式结合起来使用。第一次访问时客户端缓存在本地，同时设置过期时间，然后后续的请求都根据过期时间来判断是否需要向后端服务器请求。如果没有过期则直接本地缓存响应，如果过期了就使用条件式请求，如果服务器返回304则表示缓存仍未过期，此时重新设置过期时间；如果服务器返回200则表示缓存过期，同时将新的响应缓存下来，也同时设置过期时间。</p><h4 id="缓存相关报文首部"><a href="#缓存相关报文首部" class="headerlink" title="缓存相关报文首部"></a>缓存相关报文首部</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#请求报文</span></span><br><span class="line">cache-request-directive：</span><br><span class="line">no-cache：不用缓存内容响应</span><br><span class="line"></span><br><span class="line"><span class="comment">#响应报文，由缓存服务器发送给客户端的报文</span></span><br><span class="line">cache-response-directive：</span><br><span class="line">public：公共缓存可缓存(私有也可以)</span><br><span class="line">private：仅私有缓存可缓存</span><br><span class="line">no-cache：可缓存，但是响应给客户端之前要强制使用条件式请求判断</span><br><span class="line">no-store：不能存储响应于缓存中</span><br><span class="line">maxage：设置缓存相对时长</span><br></pre></td></tr></table></figure><h3 id="Varnish"><a href="#Varnish" class="headerlink" title="Varnish"></a>Varnish</h3><h4 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h4><p><img src="/2020/01/20/varnish%E8%AF%A6%E8%A7%A3/%E6%9E%B6%E6%9E%84.jpg" alt></p><p>主要由varnishd守护进程组成，它包含如下几个部分</p><ul><li>Manager process进程，即管理进程</li><li>Cache process进程，包含多种类型的线程如accept、worker、expiry、log/stats、storage</li></ul><p>shared memory log，用于统计缓存命中数据和记录日志的进程，有相关进程varnishlog、varnishncsa、varnishstat等</p><p>配置接口：VCL，即定义管理缓存相关设置时需要通过vcl complier编译成c语言，然后把c编译成共享模块，以供Cache进程调用。</p><h4 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h4><p>/etc/varnish/varnish.params：配置varnish服务进程的工作特性，例如监听的地址和端口，缓存机制</p><p>/etc/varnish/default.vcl：配置各Child/Cache线程的缓存工作策略</p><p>/usr/bin/varnishd：主程序</p><p>/usr/bin/varnishadm：命令行接口</p><p>/usr/bin/varnishhist等属于统计命中数据和记录日志的程序</p><p>/usr/bin/varnishtest：测试工具</p><p>/usr/sbin/varnish_reload_vcl：vcl配置文件重载程序</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>varnish可以使用基于内存的缓存和磁盘文件缓存</p><ul><li>malloc[,size]：缓存保存在内存中，指明内存大小</li><li>file[,path[,size]]：缓存保存在文件中，指明文件路径和大小</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>varnish自身启动的配置文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/varnish/varnish.params</span></span><br><span class="line"><span class="comment">#启动服务时是否重载VCL配置文件</span></span><br><span class="line">RELOAD_VCL=1</span><br><span class="line"><span class="comment">#默认VCL配置文件</span></span><br><span class="line">VARNISH_VCL_CONF=/etc/varnish/default.vcl</span><br><span class="line"><span class="comment">#Varnish服务的监听端口，一般改为80</span></span><br><span class="line">VARNISH_LISTEN_PORT=80</span><br><span class="line"><span class="comment">#定义远程管理端口和地址</span></span><br><span class="line">VARNISH_ADMIN_LISTEN_ADDRESS=127.0.0.1</span><br><span class="line">VARNISH_ADMIN_LISTEN_PORT=6082</span><br><span class="line"><span class="comment">#上述管理接口远程连接时候需要的密钥文件(客户端和服务端必须一样才可以连接)</span></span><br><span class="line">VARNISH_SECRET_FILE=/etc/varnish/secret</span><br><span class="line"><span class="comment">#使用缓存类型，此处为内存缓存，大小为256M</span></span><br><span class="line">VARNISH_STORAGE=<span class="string">"malloc,256M"</span></span><br><span class="line"><span class="comment">#设置varnish进程的属主和属组</span></span><br><span class="line">VARNISH_USER=varnish</span><br><span class="line">VARNISH_GROUP=varnish</span><br><span class="line"><span class="comment">#运行时修改的参数(和缓存相关的参数都支持运行时修改，否则重启会导致缓存失效)，此处定义的是线程池</span></span><br><span class="line">DAEMON_OPTS=<span class="string">"-p thread_pool_min=5 -p thread_pool_max=500 -p thread_pool_timeout=300"</span></span><br><span class="line">thread_pool：线程池数量(不超过cpu物理核心数)</span><br><span class="line">thread_pool_min：每个线程池的最小线程数</span><br><span class="line">thread_pool_max：每个线程池的最大线程数</span><br><span class="line">thread_pool_timeout：空闲进程被销毁的超时时长</span><br><span class="line">thread_queue_limit：每个线程池的后援队列长度</span><br><span class="line">thread_pool_add_delay：创建线程时的等待时间(一般为0)</span><br><span class="line">thread_pool_destroy_delay：销毁线程时的等待时间(防止突然有大量请求)</span><br><span class="line">thread_pool_fail_delay：创建线程失败时隔多久再重试</span><br><span class="line">send_timeout：varnish发送给客户端的超时时长</span><br><span class="line">timeout_idle：varnish与客户端保持连接时长</span><br></pre></td></tr></table></figure><p>需要缓存的后端服务器相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/varnish/default.vcl</span></span><br><span class="line">backend default &#123;</span><br><span class="line"><span class="comment">#指明后端主机ip和端口</span></span><br><span class="line">.host = <span class="string">"ip_addr"</span>;</span><br><span class="line">.port = <span class="string">"80"</span>;</span><br><span class="line"><span class="comment">#设置连接超时时长</span></span><br><span class="line">.connect_timeout = 0.5s</span><br><span class="line"><span class="comment">#设置最大连接数</span></span><br><span class="line">.max_connections = 50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="varnishadm"><a href="#varnishadm" class="headerlink" title="varnishadm"></a>varnishadm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过定义在/etc/varnish/varnish.params的管理员ip和端口来进入命令行模式，需要指明密钥文件</span></span><br><span class="line">varnishadm -T 127.0.0.1:6082 -S /etc/varnish/secret</span><br><span class="line">vcl.load &lt;configname&gt; &lt;filename&gt;：将filename编译成配置文件configname</span><br><span class="line">vcl.use &lt;configname&gt;：使用configname配置文件</span><br><span class="line">param.show &lt;param&gt;：显示指定参数</span><br><span class="line">backend.list：列出反向代理的主机</span><br></pre></td></tr></table></figure><h4 id="VCL配置"><a href="#VCL配置" class="headerlink" title="VCL配置"></a>VCL配置</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>varnish的缓存管理策略。</p><p>vcl是“域”专有类型的配置语言(类似于iptables的hook)。所谓的“域”可以理解为：当用户请求达到缓存服务器时，缓存服务器会有很多的功能模块来对请求进行判断，比如是否需要缓存等；且每个模块都会指明该模块结束后下一个模块是什么，这些模块就叫做”域”，也叫做状态引擎。</p><p>VCL有多个状态引擎，状态之间存在相关性，但状态引擎彼此之间互相隔离；每个状态引擎可使用return(x)指明关联至哪一个下一级引擎；每个状态引擎对应vcl配置文件的一个配置段，以sub定义。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>首先收到用户请求，在查本地缓存前先执行vcl_recv，可以执行一些预处理操作(很多规则在此处定义)。之后执行vcl_hash判断是否本地有缓存，此时有多种情况。如果缓存命中，则可以执行vcl_response，也可以执行vcl_pass到后端处理；如果缓存没命中，可以执行vcl_miss，然后可以直接后端处理或者调用vcl_pass后再到后端处理；如果不是可识别的协议，那么调用vcl_pipe直接传输给后端服务器进行响应。如果需要手动更改缓存项生效或者失效则使用vcl_purge之后会调用vcl_synth并构成响应报文执行vcl_deliver。</p><p>注意，有两个特殊的引擎：</p><ul><li>vcl_init：在所有请求处理之前都要执行的vcl代码；主要用于初始化VMODs</li><li>vcl_finl：所有请求都已经结束，在vcl配置被丢弃时调用；主要用于清理VMODs</li></ul><h5 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h5><ul><li><p>req.*：引用由客户端发给varnish的请求报文首部。</p><ul><li>req.http.Cookie：客户端的请求报文中Cookie的值</li><li>req.http.User-Agent：客户端浏览器信息</li><li>req.url：客户端请求的资源</li></ul></li><li><p>bereq.*：引用由varnish发给后端服务器的请求报文的首部。</p><ul><li>bereq.http.HEADERS(User-Agent、Referer等)</li><li>bereq.request：请求方法</li><li>bereq.url：请求的资源</li><li>bereq.proto：请求的协议版本</li><li>bereq.backend：指明要调用的后端主机</li></ul></li><li><p>beresp.*：引用由后端主机响应给varnish的响应报文的首部。</p><ul><li>beresp.http.HEADERS(User-Agent、Referer等)</li><li>beresp.status：响应的状态码</li><li>beresp.backend.name：后端服务器的主机名</li><li>beresp.ttl：后端服务器响应的内容跟的余下可缓存时长</li></ul></li><li><p>resp.*：引用由varnish响应给client的响应报文的首部。</p><ul><li>resp.proto：协议版本</li></ul></li><li><p>obj.*：引用存储在缓存空间中的缓存对象的属性；只读。</p><ul><li>obj.hits：此对象从缓存中命中的次数</li><li>obj.ttl：对象的ttl值</li><li>obj.grace：表示可以接受缓存过期多久，即过期在规定时间内仍然可用</li></ul></li><li><p>server.*：指明后端服务器的ip主机名</p><ul><li>server.ip</li><li>server.hostname</li></ul></li><li><p>client.*：指明客户端的ip</p><ul><li>client.ip</li></ul></li></ul><h5 id="变量定义域"><a href="#变量定义域" class="headerlink" title="变量定义域"></a>变量定义域</h5><p><img src="/2020/01/20/varnish%E8%AF%A6%E8%A7%A3/TIM%E5%9B%BE%E7%89%8720200120154142.png" alt></p><h5 id="缓存实例"><a href="#缓存实例" class="headerlink" title="缓存实例"></a>缓存实例</h5><p>强制对某类资源请求不检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义在vcl_recv中</span></span><br><span class="line"><span class="comment">#?i表示不区分大小写</span></span><br><span class="line">vcl_recv &#123;</span><br><span class="line"><span class="keyword">if</span> (req.url ~ <span class="string">"(?i)^/(login|admin)"</span>)&#123;</span><br><span class="line"><span class="built_in">return</span>(pass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于特定类型的资源，例如公共的图片，取消其私有标识，并强行设定其可以由varnish缓存的时长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义于fetch中</span></span><br><span class="line">vcl_fetch &#123;</span><br><span class="line"><span class="comment">#判断是否是可公共缓存，一般有s-maxage标识则表示可公共缓存</span></span><br><span class="line"><span class="keyword">if</span> (beresp.http.Cache-Control !~ <span class="string">"s-maxage"</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (bereq.url ~ <span class="string">"(?i)\.(jpg|png|gif|css|js|jpeg)$"</span>) &#123;</span><br><span class="line"><span class="built_in">unset</span> beresp.http.Set-Cookie;</span><br><span class="line"><span class="built_in">set</span> beresp.ttl=3600s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将真实的客户端ip传给后端服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原则放在任何地方都行，但由于要传客户端ip地址，需要放在recv下</span></span><br><span class="line">vcl_recv &#123;</span><br><span class="line"><span class="keyword">if</span> (req.restart == 0) &#123;</span><br><span class="line"><span class="keyword">if</span> (req.http.X-Fowarded-For) &#123;</span><br><span class="line"><span class="built_in">set</span> req.http.X-Forwarded-For = req.http.X-Forwarded-For + <span class="string">","</span> + client.ip;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">set</span> req.http.X-Forwarded-For = client.ip;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>purge实现缓存修剪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义访问控制</span></span><br><span class="line">acl purgers &#123;</span><br><span class="line"><span class="comment">#表示只允许下列规定的ip或网段执行purge</span></span><br><span class="line"><span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="string">"192.168.0.0"</span>/24;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#定义在recv中，且放在最前面</span></span><br><span class="line">vcl_recv &#123;</span><br><span class="line"><span class="keyword">if</span> (req.method == <span class="string">"PURGE"</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!client.ip ~ purgers) &#123;</span><br><span class="line"><span class="built_in">return</span>(synth(403,<span class="string">"Purging not allowed for "</span> + client.ip));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span>(purge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#使用curl的-X选项请求页面即可使其缓存失效，用-I查看</span></span><br><span class="line">curl -X PURGE http://192.168.163.131/index.html</span><br><span class="line">curl -I PURGE http://192.168.163.131/index.html</span><br></pre></td></tr></table></figure><p>ban实现多文件缓存修剪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义访问控制</span></span><br><span class="line">acl baners &#123;</span><br><span class="line"><span class="comment">#表示只允许下列规定的ip或网段执行ban</span></span><br><span class="line"><span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="string">"192.168.0.0"</span>/24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#手动在varnishadm命令行下执行</span></span><br><span class="line"><span class="comment">#禁止对所有.js结尾的文件的缓存</span></span><br><span class="line">ban req.url ~ .js$</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义在vcl_recv中</span></span><br><span class="line"><span class="keyword">if</span> (req.method == <span class="string">"BAN"</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!client.ip ~ baners) &#123;</span><br><span class="line"><span class="built_in">return</span>(synth(403,<span class="string">"baning not allowed for "</span> + client.ip));</span><br><span class="line">&#125;</span><br><span class="line">ban(<span class="string">"req.http.host == "</span> + req.http.host + <span class="string">"&amp;&amp; req.url == "</span> + req.url);</span><br><span class="line"><span class="built_in">return</span>(synth(200,<span class="string">"Ban added"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代理实例"><a href="#代理实例" class="headerlink" title="代理实例"></a>代理实例</h5><p>代理多台后端主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入directors模块</span></span><br><span class="line">import directors;</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义多台主机</span></span><br><span class="line">backend one &#123;</span><br><span class="line">.host = <span class="string">"localhost"</span>;</span><br><span class="line">.port = <span class="string">"80"</span>;</span><br><span class="line">&#125;</span><br><span class="line">backend two &#123;</span><br><span class="line">.host = <span class="string">"192.168.163.131"</span>;</span><br><span class="line">.port = <span class="string">"80"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在vcl_init中初始化多个主机为一组</span></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">new varnish = directors.round_robin();</span><br><span class="line">varnish.add_backend(one);</span><br><span class="line">varnish.add_backend(two);</span><br><span class="line"><span class="comment">#可以基于权重定义</span></span><br><span class="line">new varnish1 = directors.random();</span><br><span class="line">varnish1.add_backend(one,10);</span><br><span class="line">varnish1.add_backend(two,5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在vcl_recv中调用定义的组</span></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line"><span class="built_in">set</span> req.backend hint = varnish.backend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于cookie绑定不同的主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以hash定义组</span></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">new h = directors.hash();</span><br><span class="line">h.add_backend(one,1);</span><br><span class="line">h.add_backend(two,1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#hash键设定为客户端的cookie</span></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line"><span class="built_in">set</span> req.backend_hint = h.backend(req.http.cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="健康检测实例"><a href="#健康检测实例" class="headerlink" title="健康检测实例"></a>健康检测实例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义probe</span></span><br><span class="line">probe www_probe &#123;</span><br><span class="line"><span class="comment">#用于健康检测的页面，默认为“/”</span></span><br><span class="line">.url = <span class="string">"/index.html"</span>;</span><br><span class="line"><span class="comment">#定义多久检测一次</span></span><br><span class="line">.interval = 1s;</span><br><span class="line"><span class="comment">#定义响应超时时长</span></span><br><span class="line">.timeout = 1s;</span><br><span class="line"><span class="comment">#定义检测几次</span></span><br><span class="line">.window = 8;</span><br><span class="line"><span class="comment">#在定义的检测次数中检测需要成功多少次，即8此探测中成功5次则说明健康</span></span><br><span class="line">.threshold = 5;</span><br><span class="line"><span class="comment">#期望得到的响应码，默认为200</span></span><br><span class="line">.expected_response 200;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在backend中调用</span></span><br><span class="line">backend one &#123;</span><br><span class="line">...</span><br><span class="line">.probe = www_probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>varnishstat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varnishstat</span><br><span class="line">-1：只显示1次</span><br><span class="line">-l：列出可以显示的所有字段列表</span><br><span class="line">-f filed：指定只显示哪个字段</span><br><span class="line"><span class="comment">#常用字段</span></span><br><span class="line">MAIN.cache_hit：缓存命中次数</span><br><span class="line">MAIN.client_req：收到的客户端请求数</span><br></pre></td></tr></table></figure><p>varnishtop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">varnishtop</span><br><span class="line">-1：只显示一次</span><br><span class="line">-i taglist：只显示有限个标签内容</span><br><span class="line">-x taglist：排除有限个标签的内容</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;有效性机制&quot;&gt;&lt;a href=&quot;#有效性机制&quot; class=&quot;headerlink&quot; title=&quot;有效性机制&quot;&gt;&lt;/a&gt;有效性机制&lt;/h4&gt;&lt;h5 id=&quot;过期时间&quot;&gt;&lt;a href=&quot;#过期时间&quot; class=&quot;headerlink&quot; title=&quot;过期时间&quot;&gt;&lt;/a&gt;过期时间&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;expires：定义过期的绝对时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache-Control：maxage=number，表示缓存number秒时间，是相对时长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache-Control：s-maxage=number，同上&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="varnish" scheme="http://yoursite.com/tags/varnish/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>keepalived高可用集群</title>
    <link href="http://yoursite.com/2020/01/19/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2020/01/19/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</id>
    <published>2020-01-19T10:00:42.000Z</published>
    <updated>2020-01-20T11:12:35.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h4><p>keepalived是高可用集群，可以结合nginx和lvs实现如健康检测、为集群所有节点生成ipvs规则(在配置文件中预先定义)、基于脚本调用接口进行脚本执行等功能。另外，在结合vrrp协议后，通过定义虚拟路由，可以实现冗余负载均衡器的功能，从而解决负载均衡器的单点故障问题。</p><a id="more"></a><h4 id="VRRP"><a href="#VRRP" class="headerlink" title="VRRP"></a>VRRP</h4><p>路由器使用VRRP功能后，会根据优先级确定自己在备份组中的角色。优先级高的路由器成为Master路由器，优先级低的成为Backup路由器。Master拥有对外服务的虚拟IP，提供各种网络功能，并定期发送VRRP报文(通过配置文件中指定的多播域发送)，通知备份组内的其他设备自己工作正常；Backup路由器只接收Master发来的报文信息，用来监控Master的运行状态。当Master失效时，Backup路由器进行选举，优先级高的Backup将成为新的Master。</p><p>在抢占方式下，当Backup路由器收到VRRP报文后，会将自己的优先级与报文中的优先级进行比较。如果大于通告报文中的优先级，则成为Master 路由器；否则将保持Backup状态。抢占后的路由会发送ARP请求自己的MAC地址并回答自己，由于ARP是广播类型，因此局域网内的所有主机都能收到新的路由的MAC地址，从而更新各自的信息。</p><p>在非抢占方式下，只要Master路由器没有出现故障，备份组中的路由器始终保持Master或Backup状态，Backup路由器即使随后被配置了更高的优先级也不会成为Master路由器。</p><p>如果Backup路由器的定时器超时后仍未收到Master路由器发送来的VRRP报文，则认为Master路由器已经无法正常工作，此时Backup路由器会认为自己是Master路由器，并对外发送VRRP报文。备份组内的路由器根据优先级选举出Master路由器，承担报文的转发功能。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/01/19/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/keepalived.jpg" alt></p><p>核心组件：vrrp stack、ipvs wrapper、checkers</p><p>控制组件：配置文件分析器</p><p>其他组件：IO复用器、内存管理组件</p><h3 id="配置前提"><a href="#配置前提" class="headerlink" title="配置前提"></a>配置前提</h3><ul><li>各节点时间必须同步</li><li>确保iptables及selinux清空与关闭</li><li>各节点之间可通过主机名互相通信(使用/etc/host实现)</li><li>各节点之间的root用户可以基于密钥认证的ssh服务完成互相通信</li><li>配置额各节点支持multicast多播通信</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> multicast on dev ens33</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install keepalived</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>主配置文件：/etc/keepalived/keepalived.conf</p><p>主程序文件：/usr/sbin/keepalived</p><p>Unit File：keepalived.service</p><p>Unit File环境配置文件：/etc/sysconfig/keepalived</p><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li>GLOBAL CONFIGURATION<ul><li>Global definitions</li><li>static routes</li></ul></li><li>VRRPD CONFIGURATION<ul><li>VRRP synchronization group：vrrp同步组</li><li>VRRP instance：vrrp服务器</li></ul></li><li>LVS CONFIGURATION<ul><li>Virtual server groups</li><li>Virtual servers：ipvs集群的vs和rs</li></ul></li></ul><h4 id="地址转换配置"><a href="#地址转换配置" class="headerlink" title="地址转换配置"></a>地址转换配置</h4><p>主要实现负载均衡器的冗余配置，一台挂了可以启动另一台(实现ip地址的转换)从而避免单点故障问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line"><span class="comment">#配置邮件提醒</span></span><br><span class="line">   notification_email &#123;</span><br><span class="line">   root@localhost</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">#邮件发件人</span></span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   <span class="comment">#邮件服务器地址</span></span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   <span class="comment">#定义虚拟主机名</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   <span class="comment">#定义vrrp协议的多播地址，用于定义虚拟主机的广播域</span></span><br><span class="line">   vrrp_mcast_group4 224.0.100.33</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置虚拟路由器</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"><span class="comment">#定义该虚拟主机是主(MASTER)还是备(BACKUP)，主只能有一个，其余都是备</span></span><br><span class="line">    state MASTER</span><br><span class="line">    <span class="comment">#定义网卡设备</span></span><br><span class="line">    interface eth0</span><br><span class="line">    <span class="comment">#定义虚拟路由器唯一标识</span></span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    <span class="comment">#该虚拟主机优先级</span></span><br><span class="line">    priority 100</span><br><span class="line">    <span class="comment">#vrrp通告间隔1s</span></span><br><span class="line">    advert_int 1</span><br><span class="line">    <span class="comment">#认证，同一组内认证要一样</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#定义虚拟主机ip，用于与外部通信。可以指明设备和网卡别名，不设置则默认设置为网卡的辅助地址</span></span><br><span class="line">    <span class="comment">#IPADDR/MASK dev STRING label LABEL</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.16</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#定义工作模式为非抢占式</span></span><br><span class="line">    nopreempt</span><br><span class="line">    <span class="comment">#工作在抢占式，节点上线后出发新选举操作的延迟时长</span></span><br><span class="line">    preempt_delay 300</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lvs配置"><a href="#lvs配置" class="headerlink" title="lvs配置"></a>lvs配置</h4><p>使用DR模型。Director地址为172.16.0.99，两个RS地址为172.16.0.6、172.16.0.7(各自还需要设置别名172.16.0.99)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不需要使用ipvsadm生成规则，直接配置virtual_server字段即可</span></span><br><span class="line">virtual_server 172.16.0.99 80 &#123;</span><br><span class="line"><span class="comment">#每隔几秒检测一次</span></span><br><span class="line">delay_loop 1</span><br><span class="line"><span class="comment">#调度算法</span></span><br><span class="line">lb_algo wrr</span><br><span class="line"><span class="comment">#集群类型</span></span><br><span class="line">lb_kind DR</span><br><span class="line"><span class="comment">#协议</span></span><br><span class="line">protocol TCP</span><br><span class="line"><span class="comment">#错误页面服务器</span></span><br><span class="line">sorry_server ip:port</span><br><span class="line"><span class="comment">#定义RS</span></span><br><span class="line">read_server 172.16.0.6 80 &#123;</span><br><span class="line"><span class="comment">#定义权重</span></span><br><span class="line">weight 1</span><br><span class="line"><span class="comment">#定义健康检测方式</span></span><br><span class="line">HTTP_GET &#123;</span><br><span class="line"><span class="comment">#对指定url检测，根据path指定</span></span><br><span class="line">url &#123;</span><br><span class="line">path /</span><br><span class="line"><span class="comment">#只有响应码为200才正常</span></span><br><span class="line">status_code 200</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#重复检测几次</span></span><br><span class="line">nb_get_retry 3</span><br><span class="line"><span class="comment">#重试前延迟多久</span></span><br><span class="line">delay_before_retry 2</span><br><span class="line"><span class="comment">#连接超时时长</span></span><br><span class="line">connect_timeout 3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">read_server 172.16.0.7 80 &#123;</span><br><span class="line"><span class="comment">#定义权重</span></span><br><span class="line">weight 1</span><br><span class="line"><span class="comment">#定义健康检测方式</span></span><br><span class="line">HTTP_GET &#123;</span><br><span class="line"><span class="comment">#对指定url检测，根据path指定</span></span><br><span class="line">url &#123;</span><br><span class="line">path /</span><br><span class="line"><span class="comment">#只有响应码为200才正常</span></span><br><span class="line">status_code 200</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#重复检测几次</span></span><br><span class="line">nb_get_retry 3</span><br><span class="line"><span class="comment">#重试前延迟多久</span></span><br><span class="line">delay_before_retry 2</span><br><span class="line"><span class="comment">#连接超时时长</span></span><br><span class="line">connect_timeout 3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>nginx和keepalived实现单主高可用故障转移。</p><p>使用三台虚拟主机模拟三个RS，其ip地址分别为192.168.10.11、192.168.10.12、192.168.10.13；两台主机模拟两个冗余nginx反带服务器，使用keepalived实现单点故障冗余以及RS健康检测。</p><p>后端3个RS运行httpd，用虚拟主机实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/httpd/conf.d目录下新建配置文件vhost.conf</span></span><br><span class="line">&lt;VirtualHost 192.168.10.11:80&gt;</span><br><span class="line">ServerName 192.168.10.11</span><br><span class="line">DocumentRoot <span class="string">"/data/web/vhost1"</span></span><br><span class="line">&lt;Directory <span class="string">"/data/web/vhost1"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;VirtualHost 192.168.10.12:80&gt;</span><br><span class="line">ServerName 192.168.10.12</span><br><span class="line">DocumentRoot <span class="string">"/data/web/vhost2"</span></span><br><span class="line">&lt;Directory <span class="string">"/data/web/vhost1"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;VirtualHost 192.168.10.13:80&gt;</span><br><span class="line">ServerName 192.168.10.13</span><br><span class="line">DocumentRoot <span class="string">"/data/web/vhost3"</span></span><br><span class="line">&lt;Directory <span class="string">"/data/web/vhost1"</span>&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>接着，为了使keepalived结合nginx，用于检测nginx服务是否挂了，如果挂了就开启nginx，如果开启不了nginx就降低优先级让另一台nginx来抢占即可。这里需要使用脚本来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#脚本一般定义在实例之外，方便调用</span></span><br><span class="line">vrrp_script &lt;SCRIPT_NAME&gt; &#123;</span><br><span class="line"><span class="comment">#脚本命令，脚本执行失败会执行下述命令</span></span><br><span class="line">script <span class="string">""</span></span><br><span class="line"><span class="comment">#间隔多久检测</span></span><br><span class="line">interval INT</span><br><span class="line"><span class="comment">#失败了，即上述命令返回值为1时权重减少多少</span></span><br><span class="line">weight -INT</span><br><span class="line"><span class="comment">#失败多少此后降低优先级</span></span><br><span class="line">fall INT</span><br><span class="line"><span class="comment">#成功多少次后恢复优先级</span></span><br><span class="line">rise INT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在vrrp_instance的track_script中根据脚本名调用脚本</span></span><br><span class="line">track_script &#123;</span><br><span class="line">SCRIPT_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测nginx是否正常工作的脚本</span></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line"><span class="comment">#killall -0表示查看nginx是否可以杀死，但不动手，从而检测nginx是否在运行(可以杀死说明在运行)</span></span><br><span class="line">script <span class="string">"killall -0 nginx &amp;&amp; exit 0 || exit 1"</span></span><br><span class="line">interval 1</span><br><span class="line">weight 5</span><br><span class="line">fall 2</span><br><span class="line">rise 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#根据/etc/keepalived/down文件是否存在来修改优先级，可以实现对某个主机下线做修复操作</span></span><br><span class="line">vrrp_script chk_down &#123;</span><br><span class="line"><span class="comment">#如果文件存在就降低优先级</span></span><br><span class="line">script <span class="string">"[[ -f /etc/keepalived/down ]] &amp;&amp; exit 1 || exit 0"</span></span><br><span class="line">interval 1</span><br><span class="line">weight -5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在两台nginx主机上配置nginx负载均衡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upstream websrvs &#123;</span><br><span class="line">server 192.168.10.11:80;</span><br><span class="line">server 192.168.10.12:80;</span><br><span class="line">server 192.168.10.13:80;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在server的location中定义</span></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://websrvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写通知脚本，实现keepalived状态发生变化时进行邮件通知以及启动nginx服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">contact=<span class="string">'root@localhost'</span></span><br><span class="line"><span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line"><span class="built_in">local</span> mailsubject=<span class="string">"`hostname` to be <span class="variable">$1</span>, vip floating"</span></span><br><span class="line"><span class="built_in">local</span> maibody=<span class="string">"`date +%F %T`: vrrp tansition, `hostname` changed to be <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$mailbody</span>"</span> | mail -s <span class="string">"<span class="variable">$mailsubject</span>"</span> <span class="variable">$contact</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">master)</span><br><span class="line">systemctl start nginx</span><br><span class="line">notify master</span><br><span class="line">;;</span><br><span class="line">backup)</span><br><span class="line">systemctl start nginx</span><br><span class="line">notify backup</span><br><span class="line">;;</span><br><span class="line">fault)</span><br><span class="line">systemctl stop nginx</span><br><span class="line">notify fault</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>` &#123;master|backup|fault&#125;"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>上述脚本定义在vrrp_instance中执行，当keepalived的状态改变时会执行对应的脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notify_master &#39;&#x2F;etc&#x2F;keeplived&#x2F;notify.sh master&#39;</span><br><span class="line">notify_backup&#39;&#x2F;etc&#x2F;keeplived&#x2F;notify.sh backup&#39;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上使用的是单主机的keepalived和nginx的调度，在整个调度中都会有一个主机处于空闲状态，浪费资源，因此可以使用双主调度。只需要再配置一个vrrp_instance即可，要注意两个主机唯一标识、认证以及优先级的设计，可以设计第一台的两个虚拟主机优先级一个是100，另一个是90；同理第二台主机分别是90和100(注意两台主机的100和对应的90是一组)，这样就可以实现没有空闲主机的情况，增加利用率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h4 id=&quot;keepalived&quot;&gt;&lt;a href=&quot;#keepalived&quot; class=&quot;headerlink&quot; title=&quot;keepalived&quot;&gt;&lt;/a&gt;keepalived&lt;/h4&gt;&lt;p&gt;keepalived是高可用集群，可以结合nginx和lvs实现如健康检测、为集群所有节点生成ipvs规则(在配置文件中预先定义)、基于脚本调用接口进行脚本执行等功能。另外，在结合vrrp协议后，通过定义虚拟路由，可以实现冗余负载均衡器的功能，从而解决负载均衡器的单点故障问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="keepalived" scheme="http://yoursite.com/tags/keepalived/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>LVS四层负载均衡</title>
    <link href="http://yoursite.com/2020/01/17/LVS%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2020/01/17/LVS%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-01-17T10:12:13.000Z</published>
    <updated>2020-01-17T10:12:57.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Cluster：计算机集合，为解决某个特定问题组合起来形成的单个系统</p><a id="more"></a><h4 id="系统扩展方式"><a href="#系统扩展方式" class="headerlink" title="系统扩展方式"></a>系统扩展方式</h4><p>Scale UP：向上扩展，即增加单个服务器容量</p><p>Scale OUT：向外扩展，即增加服务器数量(Cluster)</p><h4 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h4><p>由于使用负载均衡后，用户的请求会被负载均衡器分配到不同的后端服务器中，那么如何记录用户的会话身份就显得很重要。主要有如下三种方式：</p><ul><li>session sticky：每个用户绑定固定的后端服务器，可以根据源ip或者cookie来绑定</li><li>session replication：即将每个后端主机的session信息互相同步</li><li>session server：采用一个固定的session服务器专门保存会话信息</li></ul><h4 id="Linux-Cluster类型"><a href="#Linux-Cluster类型" class="headerlink" title="Linux Cluster类型"></a>Linux Cluster类型</h4><p>LB：Load Balanceing，负载均衡</p><p>HA：High Availability，高可用；A=MTBF/(MTBF+MTTR)。(平均无故障时间)/(平均无故障时间+平均修复时间)</p><p>HP：High performance，高性能</p><p>分布式存储：类似于集群概念。将客户端请求通过一个服务器分发给多个服务器，其中起分发功能的服务器叫做元数据服务器，它保存各个数据在数据服务器的位置，即只存储数据的元信息。数据服务器负责真正存储数据，且为了安全一份数据通常在两个不同的数据服务器之间做冗余。另外，如果用户请求一个大文件，且请求量很大，可以将该大文件切片并放在不同的数据服务器上，一次发给用户即可。该结构模型类似文件系统模型。</p><p>分布式计算：将一个单一大问题分隔成数个小问题来解决。例如处理100亿条日志，需要提取访问量前10的日志信息，则可以根据服务器数量，将总体分隔成多个部分进行分开计算，再整合，再计算，这就叫分布式计算。</p><h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><p>F5的Big-ip；Citrix的Netscaler；A10的A10</p><h5 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h5><p>传输层(DPORT)：</p><ul><li>lvs(Linux Virtual Server)</li><li>nginx(stream模块)</li><li>haproxy(mode tcp)</li></ul><p>应用层(自定义请求模型)：</p><ul><li>http：nginx、httpd、haproxy</li><li>fastcgi：nginx、httpd</li></ul><h3 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h3><p>Linux virtual server</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>它是工作在传输层的内核软件，也叫四层路由器。它根据请求报文的目标IP和目标协议及端口将其转发至某RealServer(RS)，根据调度算法来挑选RS。</p><p>VS：虚拟主机也叫Director，即用于调度分发客户端请求的服务器，也叫负载均衡器</p><p>RS：真实服务器，即用于处理客户端请求的服务器</p><p>ipvsadm：lvs的用户空间命令行工具，规则管理工具，用于管理集群服务及RS</p><p>ipvs：lvs工作于内核空间的INPUT上的一个框架</p><p>CIP：客户端的IP</p><p>VIP：VS用于响应客户端请求的IP</p><p>DIP：VS用于响应RS的IP</p><p>RIP：RS的IP</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="lvs-nat"><a href="#lvs-nat" class="headerlink" title="lvs-nat"></a>lvs-nat</h5><p>修改请求报文的目标IP和端口，适用于多目标的DNAT</p><ul><li>RIP和DIP必须处于同一IP网络，且应该使用私网地址；RS网关指向DIP</li><li>请求报文和响应报文都必须经由Director转发；Director可能成为系统瓶颈</li><li>支持端口映射，可修改请求报文的目标PORT</li><li>VS即Director必须是Linux系统，RS可以是任何系统</li></ul><h5 id="lvs-dr"><a href="#lvs-dr" class="headerlink" title="lvs-dr"></a>lvs-dr</h5><p>不修改IP和端口，而修改MAC地址。即为请求报文重新生成一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是挑出的RS的RIP所在接口的MAC地址。</p><ul><li>确保前端路由器将目标IP为VIP的请求报文发往Director<ul><li>法一：在前端网关做静态绑定，但不灵活。</li><li>法二：在RS上使用arptables做MAC访问控制</li><li>法三：在RS上修改内核参数以限制arp通告及应答级别(arp_announce、arp_ignore)<ul><li>arp_announce：默认0，表示在接入网络时把本机所有接口的所有信息向每个接口上的网络进行通告；1表示尽量避免向非直连网络进行通告；2表示避免向非本网络通告。</li><li>arp_ignore：默认0，表示可使用本地任意接口上配置的任意地址进行响应；1表示尽在请求的目标ip配置在本地主机的接收请求报文的接口上时才给予响应。</li></ul></li></ul></li><li>RS的RIP可以使用私网地址，也可使用公网地址；RIP与DIP在同一IP网络；RIP网关不能指向DIP，以确保响应报文不经由Director</li><li>RS跟Director在同一物理网络(同一交换机，不能隔路由器)</li><li>请求报文要经由Director，但响应报文不能经由Director，而是经由RS直接发往client</li><li>不支持端口映射</li></ul><h5 id="lvs-tun"><a href="#lvs-tun" class="headerlink" title="lvs-tun"></a>lvs-tun</h5><p>隧道概念，不修改请求报文的IP首部(源IP为CIP，目标IP为VIP)，而是在原有请求的IP报文之外新加一个IP首部(源IP为DIP，目标IP为RIP)，之后将报文发往挑选出的RS，最后RS直接响应给客户端(源IP为VIP，目标IP为CIP)。但会引起超出MTU的问题。</p><ul><li>DIP、VIP、RIP都是公网地址</li><li>RS的网关不能指向DIP</li><li>请求报文要经由Director，但响应报文不能经由Director</li><li>不支持端口映射</li><li>RS的OS得支持隧道功能</li></ul><h5 id="lvs-fullnat"><a href="#lvs-fullnat" class="headerlink" title="lvs-fullnat"></a>lvs-fullnat</h5><p>不同于nat，它修改目标IP和源IP(CIP修改为DIP，VIP修改为RIP)</p><ul><li>VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关不会指向DIP</li><li>RS收到的请求报文源IP是DIP，因此只需响应给DIP；但Director还要将其发往Client</li><li>请求和响应报文都经由Director</li><li>支持端口映射</li><li>此模型默认不支持</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>lvs-nat、lvs-fullnat的请求都经过Director，区别在于nat模型中，RIP的网关要指向DIP；而fullnat的RIP和DIP未必在同一IP网络，但他们要能通信。且nat进修改请求报文的目标ip，而fullnat修改请求报文的源ip和目标ip。</p><p>lvs-dr、lvs-tun的请求报文都经过Director，响应报文都由RS直接发往Client。区别在于dr模型通过封装新的MAC首部实现，通过MAC转发；而tun模型通过在原有的IP报文之外再封装新的IP实现转发，支持远距离通信。</p><h4 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h4><p>根据调度时是否考虑各RS当前的负载状态，可分为静态方法和动态方法两种。</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>仅根据算法本身进行调度。</p><ul><li>RR：roundrobin，轮询</li><li>WRR：weighted RR，加权轮询，即将RS虚拟出多个，把个数作为权重</li><li>SH：Source Hashing，实现session sticky，源ip地址hash；在Director内存中维护一张hash表，客户端IP和RS的IP一一对应。(第一次请求时使用WRR并记录源地址hash和对应RS的IP)。缺点是当RS挂掉时对应的客户端的session也会丢失。</li><li>DH：Destination Hashing，目标地址hash，将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡。</li></ul><h5 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h5><p>主要根据每个RS当前的负载状态进行调度，负载一样再考虑算法本身。负载值(overhead)</p><ul><li>LC：least connection，最少连接<ul><li>overhead=activeconns*256+inactiveconns</li></ul></li><li>WLC：weighted LC，加权最少连接<ul><li>overhead=(activeconns*256+inactiveconns)/weight</li></ul></li><li>SED：shortest Expection Delay，最短期望延迟<ul><li>overhead=(activeconns+1)*256/weight</li></ul></li><li>NQ：Never Queue</li><li>LBLC：Locality-Based LC，动态DH算法</li><li>LBLCR：LBLC with Replication，带复制功能的LBLC</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Director安装</span></span><br><span class="line">yum install ipvsadm -y</span><br></pre></td></tr></table></figure><h4 id="管理集群"><a href="#管理集群" class="headerlink" title="管理集群"></a>管理集群</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增、改</span></span><br><span class="line">ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]</span><br><span class="line"><span class="comment">#删</span></span><br><span class="line">ipvsadm -D -t|u|f service-address</span><br><span class="line">service-address：</span><br><span class="line">-t：TCP协议端口，VIP:TCP_PORT</span><br><span class="line">-u：UDP协议端口，VIP:UDP_PORT</span><br><span class="line">-f：firewall MARK，是一个数字</span><br><span class="line">[-s scheduler]：指定集群调度算法，默认为WLC</span><br></pre></td></tr></table></figure><h4 id="管理集群的RS"><a href="#管理集群的RS" class="headerlink" title="管理集群的RS"></a>管理集群的RS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增、改</span></span><br><span class="line">ipvsadm -a|e -t|u|f service-address [-g|i|m] [-w weight]</span><br><span class="line"><span class="comment">#删</span></span><br><span class="line">ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line">server-address：</span><br><span class="line">rip[:port]</span><br><span class="line">-g：gateway，dr类型</span><br><span class="line">-i：ipip，tun类型</span><br><span class="line">-m：masquerade，nat类型</span><br></pre></td></tr></table></figure><h4 id="删除和查看"><a href="#删除和查看" class="headerlink" title="删除和查看"></a>删除和查看</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除</span></span><br><span class="line">ipvsadm -C</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">ipvsadm -L|l [options]</span><br><span class="line">--numeric,-n：数字格式ip地址和端口</span><br><span class="line">--exact；精确显示</span><br><span class="line">--connection,-c：查看具体连接信息，即哪些请求被转发到哪些RS</span><br><span class="line">--stats：统计数据</span><br><span class="line">conns：连接数</span><br><span class="line">InPkts：入栈报文数量</span><br><span class="line">OutPkts：出栈报文数量</span><br><span class="line">InBytes：入栈字节数</span><br><span class="line">OutBytes：出栈字节数</span><br><span class="line">--rate：速率数据</span><br><span class="line">CPS：每秒建立的连接数</span><br><span class="line">InPPS：每秒入栈报文数</span><br><span class="line">OutPPS：每秒出栈报文数</span><br><span class="line">InBPS：每秒入栈字节数</span><br><span class="line">OutBPS：每秒出栈字节数</span><br></pre></td></tr></table></figure><h4 id="保存和重载"><a href="#保存和重载" class="headerlink" title="保存和重载"></a>保存和重载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#保存</span></span><br><span class="line">ipvsadm -S &gt; /etc/sysconfig/ipvsadm</span><br><span class="line">ipvsadm-save &gt; /etc/sysconfig/ipvsadm</span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line">ipvsadm -R &lt; /etc/sysconfig/ipvsadm</span><br><span class="line">ipvsadm-restore &lt; /etc/sysconfig/ipvsadm</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="NAT集群"><a href="#NAT集群" class="headerlink" title="NAT集群"></a>NAT集群</h5><p>使用nat模型实现集群。一台Director(两块网卡，一个VIP，一个DIP)，两台RS。</p><p>首先配置RS1、RS2，他们ip地址分别为192.168.163.11、192.168.163.12，网关地址为192.168.163.254，该网关地址也是Director的DIP。Director的VIP为一个外网地址(注意Director必须开启核心转发功能)。由此外网主机就可以通过Director的VIP地址访问两台RS.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建集群</span></span><br><span class="line">ipvsadm -A -t VIP_address:port -s rr</span><br><span class="line"><span class="comment">#创建集群上的rule</span></span><br><span class="line">ipvsadm -a -t VIP_address:port -r 192.168.163.11 -m</span><br><span class="line">ipvsadm -a -t VIP_address:port -r 192.168.163.12 -m</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改集群调度算法为wrr(加权rr)</span></span><br><span class="line">ipvsadm -E -t VIP_address:port -s wrr</span><br><span class="line"><span class="comment">#修改rule权重</span></span><br><span class="line">ipvsadm -e -t VIP_address:port -r 192.168.163.11 -m -w 2</span><br><span class="line">ipvsadm -e -t VIP_address:port -r 192.168.163.12 -m -w 3</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除一条rule</span></span><br><span class="line">ipvsadm -d -t VIP_address:port -r 192.168.163.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，port根据具体服务选择，比如web服务一般是80端口，telnet就设置23端口即可。不同的端口相互隔离。</span></span><br></pre></td></tr></table></figure><h5 id="DR集群"><a href="#DR集群" class="headerlink" title="DR集群"></a>DR集群</h5><p>使用dr模型实现集群。一台Director(一块网卡，只要VIP)，两台RS。RS和Director在同一网段(网关一样)。</p><p>Directory地址设置为172.16.0.99(VIP)，不需要DIP地址。</p><p>两台RS地址设置分别为172.168.0.7(RIP)、172.168.0.8(RIP)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置内核参数，/proc/sys/net/ipv4/conf/</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置RS的另一个ip地址，设置在lo的别名上</span></span><br><span class="line">ifconfig lo:0 172.16.0.99 netmask 255.255.255.255 broadcast 172.16.0.99 up</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置RS的路由条目</span></span><br><span class="line"><span class="comment">#因为需要由RS直接将结果反回给Client，所以设置路由条目，将目的ip为VIP的全部转发经由lo:0来转发，这样发送给Clent的源ip就是VIP，与用户请求的目的IP一样</span></span><br><span class="line">route add -host 172.168.0.99 dev lo:0</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置Director的ip别名</span></span><br><span class="line"><span class="comment">#因为我们设置的VIP是172.16.0.99，即外网Client通过VIP访问，我们需要在与外界通信的物理网卡上配置别名，ip地址改为VIP。</span></span><br><span class="line"><span class="comment">#此处broadcast只是将本网段的广播全都转发给172.16.0.99，正常的ARP仍可以响应</span></span><br><span class="line">ifconfig ens33:0 172.16.0.99 netmask 255.255.255.255 broadcast 172.16.0.99 up</span><br><span class="line"></span><br><span class="line"><span class="comment">#Director添加集群</span></span><br><span class="line">ipvsadm -A -t 172.168.0.99:80 -s rr</span><br><span class="line"><span class="comment">#创建集群上的rule</span></span><br><span class="line">ipvsadm -a -t 172.168.0.99:80 -r 172.168.0.7 -m</span><br><span class="line">ipvsadm -a -t 172.168.0.99:80 -r 172.168.0.8 -m</span><br></pre></td></tr></table></figure><h5 id="防火墙标记"><a href="#防火墙标记" class="headerlink" title="防火墙标记"></a>防火墙标记</h5><p>使用iptables在请求进入Director的Prerouting时加不同的防火墙标记，当请求经由input链时按照lvs根据防火墙标记设计的规则就可以实现对不同的端口的访问全部绑定一起进行调度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将80和443端口进行iptables打包</span></span><br><span class="line">iptables -t mangle -A PREROUTING -d 172.16.0.99 -p tcp -m multiport --dports 80,443 -j MARK --<span class="built_in">set</span>-mark 3</span><br><span class="line"><span class="comment">#根据mark添加集群</span></span><br><span class="line">ipvsadm -A -f 3 -s rr</span><br><span class="line"><span class="comment">#添加RS</span></span><br><span class="line">ipvsadm -a -f 3 -r 172.16.0.7 -g</span><br><span class="line">ipvsadm -a -f 3 -r 172.16.0.8 -g</span><br></pre></td></tr></table></figure><h5 id="会话保持-1"><a href="#会话保持-1" class="headerlink" title="会话保持"></a>会话保持</h5><p>使用ipvsadm的-p选项实现调度算法之上的会话绑定。即客户端第一次访问时仍然按照选定的算法来调度，但是同一客户端之后的访问都会被绑定到第一次调度的主机上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在上面基础上修改集群，默认360s</span></span><br><span class="line">ipvsadm -E -f 3 -s rr -p</span><br></pre></td></tr></table></figure><h5 id="全端口绑定"><a href="#全端口绑定" class="headerlink" title="全端口绑定"></a>全端口绑定</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口设0表示全端口转发，且此时必须设置-p选项</span></span><br><span class="line">ipvsadm -A -t 172.16.0.99:0 -s rr -p</span><br><span class="line">ipvsadm -a -t 172.16.0.99:0 -r 172.16.0.7 -g</span><br><span class="line">ipvsadm -a -t 172.16.0.99:0 -r 172.16.0.8 -g</span><br></pre></td></tr></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul><li>Director存在单点故障问题(SPoF)，解决方法使用高可用集群实现。<ul><li>keepalived，它既可以冗余Director也可以检测RS的生命状态</li><li>heartbeat/corosync</li></ul></li><li>某RS不可用，Director仍然会调度请求该RS，可以通过网络层(ping)、传输层(端口探测)、应用层检测(请求某关键资源)<ul><li>keeplived</li><li>ldirectord</li></ul></li></ul><h4 id="Idirectord"><a href="#Idirectord" class="headerlink" title="Idirectord"></a>Idirectord</h4><p>工作在Director主机上，对后端主机进行健康检测并修改Director的规则。启用ldirectord后，会根据配置文件需要检测的RS自动添加Director的规则条目，对无法访问的将自动删除。</p><p>由于ldirectord不在官方仓库和epel仓库中，因此要使用rpm安装。</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#超时时长</span></span><br><span class="line">checktimeout=time</span><br><span class="line"><span class="comment">#每隔多久检测一次</span></span><br><span class="line">checkinterval=time</span><br><span class="line"><span class="comment">#所有RS全挂使用什么来处理请求</span></span><br><span class="line">fallback=127.0.0.1:80</span><br><span class="line"><span class="comment">#是否自动重载配置文件</span></span><br><span class="line">autoreload=yes</span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line">logfile=<span class="string">""</span></span><br><span class="line"><span class="comment">#通知邮箱</span></span><br><span class="line">emailalert=<span class="string">""</span></span><br><span class="line"><span class="comment">#通知频率</span></span><br><span class="line">emailalertfreq=<span class="string">""</span></span><br><span class="line"><span class="comment">#定义VIP，也可以根据防火墙标签定义</span></span><br><span class="line">virtual VIP_ADDRESS:PORT</span><br><span class="line"><span class="comment">#定义RIP</span></span><br><span class="line"><span class="built_in">read</span>=RIP:PORT gate(dr模型)</span><br><span class="line"><span class="comment">#指明该集群应用层协议</span></span><br><span class="line">service=http</span><br><span class="line"><span class="comment">#指明检测主页</span></span><br><span class="line">request=<span class="string">"index.html"</span></span><br><span class="line"><span class="comment">#请求主页包含关键字</span></span><br><span class="line">receive=<span class="string">"Test Page"</span></span><br><span class="line"><span class="comment">#向指定虚拟主机发送请求</span></span><br><span class="line">virtualhost=www.x.y.z</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;Cluster：计算机集合，为解决某个特定问题组合起来形成的单个系统&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="lvs" scheme="http://yoursite.com/tags/lvs/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>nginx详解</title>
    <link href="http://yoursite.com/2020/01/15/nginx%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/15/nginx%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-15T11:16:04.000Z</published>
    <updated>2020-02-11T15:58:32.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>事件驱动指当用户进程发起磁盘io时，该进程告诉内核一个回调接口，即内核加载磁盘数据到内核空间后会通知发起该动作的进程。随后，进程接收到回调信号后，参与数据从内核空间到进程空间的过程。在Linux中，事件驱动的系统调用叫做epoll，由libevent包提供。</p><a id="more"></a><h3 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h3><p><img src="/2020/01/15/nginx%E8%AF%A6%E8%A7%A3/nginx.jpg" alt></p><p>nginx基于master-worker模型，即一个主控进程master生成多个子进程worker来处理用户请求。其中master负责加载和分析配置文件、管理worker进程和平滑升级。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>异步、事件驱动、非阻塞</p><p>并发请求：epoll</p><p>文件io：sendfile，mmap</p><p>模块化：支持动态装载和卸载，包括core module、http modules、mail modules和stream modules(传输层代理，即4层代理)</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>静态web服务器资源</li><li>结合FastCGI协议实现反代动态资源请求</li><li>http/https协议的反向代理</li><li>imap4/pop3协议的反向代理</li><li>tcp/udp的反向代理</li></ul><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>主程序文件：/usr/sbin/nginx</p><p>unit file：nginx.service</p><p>配置文件：/etc/nginx/nginx.conf、/etc/nginx/conf.d/*.conf、fastcgi、mimetypes等</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum makecache</span><br><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件后使用如下命令检查和重载配置文件</span></span><br><span class="line">nginx -t</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="运行必备"><a href="#运行必备" class="headerlink" title="运行必备"></a>运行必备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以用用户名，也可用组名</span></span><br><span class="line">user user [group];</span><br><span class="line"><span class="comment">#指定nginx进程路径</span></span><br><span class="line">pid /path;</span><br><span class="line"><span class="comment">#指明包含其他配置文件路径</span></span><br><span class="line">include file | mask;</span><br><span class="line"><span class="comment">#指明动态装载的模块</span></span><br><span class="line">load_module file;</span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#worker进程数量，通常小于等于cpu的物理核心数</span></span><br><span class="line">worker_process number | auto;</span><br><span class="line"><span class="comment">#将cpu与nginx进程绑定，主要用于专机专用</span></span><br><span class="line">worker_cpu_affinity cpumask | auto;</span><br><span class="line"><span class="comment">#指定worker进程的nice值[-20,19]</span></span><br><span class="line">worker_priority number;</span><br><span class="line"><span class="comment">#所有的worker进程所能打开的文件数量上限</span></span><br><span class="line">worker_rlimit_nofile</span><br></pre></td></tr></table></figure><h4 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否以守护进程的方式运行nginx，通常设置在centos6上，因为7已经编程systemd管理</span></span><br><span class="line">daemon on | off;</span><br><span class="line"><span class="comment">#是否以master/worker模型运行nginx；默认为on</span></span><br><span class="line">master_process on | off;</span><br><span class="line"><span class="comment">#错误日志路径和日志级别，自我管理，不使用rsyslog</span></span><br><span class="line">error_log file [level];</span><br></pre></td></tr></table></figure><h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">放在events段中</span><br><span class="line"><span class="comment">#每个worker进程能够打开的最大进程并发数</span></span><br><span class="line">worker_connections number;</span><br><span class="line"><span class="comment">#指明并发连接请求的处理方法</span></span><br><span class="line">use method;</span><br><span class="line"><span class="comment">#处理连接请求的方法；on表示各worker轮流处理，off表示各个请求到达会通知所有worker</span></span><br><span class="line">accept_mutex on | off;</span><br></pre></td></tr></table></figure><h4 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h4><h5 id="套接字配置"><a href="#套接字配置" class="headerlink" title="套接字配置"></a>套接字配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置虚拟主机</span></span><br><span class="line">server&#123;</span><br><span class="line">listen address[:port]|port;</span><br><span class="line">default_server：设定为默认主机</span><br><span class="line">ssl：限制只能通过ssl连接提供服务，即通过https</span><br><span class="line">backlog=number：后援队列长度</span><br><span class="line">rcvbuf=size：接收缓冲区大小</span><br><span class="line">sndbuf=size：发送缓冲区大小</span><br><span class="line">server_name SERVER_NAME;</span><br><span class="line">指明虚拟主机的名称，可以跟多个由空白字符分隔的字符串</span><br><span class="line">支持*通配任意字符长度、支持~起始的字符做正则表达式模式匹配</span><br><span class="line">匹配机制：首先是字符串精确匹配，然后是左侧匹配，然后是右侧匹配，最后是正则匹配</span><br><span class="line"><span class="comment">#设置root就说明是正向服务器</span></span><br><span class="line">root /path;</span><br><span class="line"><span class="comment">#设置proxy_pass说明是反向代理服务器，此时root无效</span></span><br><span class="line">proxy_pass http://ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在keep_alive模式下是否启用nodelay选项，用于处理用户请求资源过小时是否组合多个资源发送</span></span><br><span class="line">tcp_nodelay on | off;</span><br><span class="line"><span class="comment">#在sendfile模式下是否启用nopush选项。用于一次性将整个file(包括头部)放在一个packet中发送过去。</span></span><br><span class="line">tcp_nopush on | off;</span><br><span class="line"><span class="comment">#动态资源是否直接在内存空间发送而不经过用户空间</span></span><br><span class="line">sendfile on | off;</span><br></pre></td></tr></table></figure><h5 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置web路径映射，用于指定本地文件系统上的资源路径；可以用在http、server、location、if in location</span></span><br><span class="line">root</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据不同的url进行更详细的设置。nginx会根据用户请求的url来检查定义的所有location，并找出最佳匹配应用。</span></span><br><span class="line">location [ = | ~ | ~* |^~ ] url &#123;...&#125;</span><br><span class="line">=：对url精确匹配</span><br><span class="line">~：对url正则匹配，区分字符大小写</span><br><span class="line">~*：对url正则匹配，不区分字符大小写</span><br><span class="line">^~：对url左半部分做匹配检查，不区分字符大小写</span><br><span class="line">不带符号：匹配起始于此url的所有url</span><br><span class="line">优先级：=、^~、~、~/~*、不带符号</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义路径别名，仅用于location</span></span><br><span class="line"><span class="built_in">alias</span> path;</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">location中使用root指令和<span class="built_in">alias</span>指令的意义不同，root给定的路径相当于location中url左侧的/；而<span class="built_in">alias</span>相当于右侧/。</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置默认资源，定义于http、server、location</span></span><br><span class="line">index file...;</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义特定错误码的错误页</span></span><br><span class="line">error_page code... [=[response]] url;</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">try_files file... url;</span><br></pre></td></tr></table></figure><h5 id="客户端请求配置"><a href="#客户端请求配置" class="headerlink" title="客户端请求配置"></a>客户端请求配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设定保持连接的超时时长，0表示禁止长连接，默认为75s</span></span><br><span class="line">keepalive_timeout time;</span><br><span class="line"><span class="comment">#一次长连接上所允许请求的最大资源数，默认为100</span></span><br><span class="line">keepalive_requests number;</span><br><span class="line"><span class="comment">#对哪种浏览器禁用长连接</span></span><br><span class="line">keepalive_disable none | browser...;</span><br><span class="line"><span class="comment">#向客户端发送响应报文的超时时长，当客户端突然断线时，服务器会重复写，这就是两次重复写的间隔时长</span></span><br><span class="line">send_timeout time</span><br><span class="line"><span class="comment">#用于接收客户端请求报文的body部分的缓冲区大小；默认为16k，超出此大小时将其暂存到client_body_temp_path指令所定义的位置</span></span><br><span class="line">client_body_buffer_size size;</span><br><span class="line"><span class="comment">#设定用于存储客户端请求报文的body部分的临时存储路径及其子目录结构和数量</span></span><br><span class="line">client_body_temp_path [level1 [level2 [level3]]];</span><br><span class="line">client_body_temp_path path /var/tmp/client_body 2 1 1</span><br><span class="line">1：表示用一位16进制数表示一级子目录</span><br><span class="line">2：表示用2位16进制文件表示二级子目录</span><br><span class="line">2：表示用2位16进制文件表示三级子目录</span><br></pre></td></tr></table></figure><h5 id="客户端限制配置"><a href="#客户端限制配置" class="headerlink" title="客户端限制配置"></a>客户端限制配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#限制响应给客户端的传输速率，0表示无限制，单位bytes/second</span></span><br><span class="line">limit_rate rate;</span><br><span class="line"><span class="comment">#限制对指定的请求方法之外的其他方法</span></span><br><span class="line">limit_except method...&#123;...&#125;</span><br></pre></td></tr></table></figure><h5 id="文件操作优化"><a href="#文件操作优化" class="headerlink" title="文件操作优化"></a>文件操作优化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否启用异步io功能</span></span><br><span class="line">aio on | off | threads[=pool];</span><br><span class="line"><span class="comment">#是否启用O_DIRECT标记</span></span><br><span class="line">directio size | off;</span><br><span class="line"><span class="comment">#是否打开nginx缓存功能，可以缓存文件描述符、文件大小、最后一次修改时间、打开的目录结构、没有找到或者没有权限访问的文件的相关信息</span></span><br><span class="line">open_file_cache off | max=N [inactive=time];</span><br><span class="line">max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现缓存管理</span><br><span class="line">inactive=time：缓存项的非活动时长，小于此处时间未被命中或者命中次数少于open_file_cache_min_use指定的次数的缓存项即为非活动项。</span><br><span class="line"><span class="comment">#缓存有效性检查频率，默认60s</span></span><br><span class="line">open_file_cache_valid time;</span><br><span class="line"><span class="comment">#在open_file_cache指令的inactive指定时长内，至少被命中多少次的可以被归为活动项</span></span><br><span class="line">open_file_cache_min_uses number;</span><br><span class="line"><span class="comment">#是否缓存查找时发生错误的文件信息</span></span><br><span class="line">open_file_cache_errors on | off;</span><br></pre></td></tr></table></figure><h3 id="重要模块"><a href="#重要模块" class="headerlink" title="重要模块"></a>重要模块</h3><h4 id="访问控制模块"><a href="#访问控制模块" class="headerlink" title="访问控制模块"></a>访问控制模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现基于ip的访问控制</span></span><br><span class="line">ngx_http_access_module</span><br><span class="line">allow address | CIDR | unix | all;</span><br><span class="line">deny address | CIDR | unix | all;</span><br><span class="line"></span><br><span class="line"><span class="comment">#实现基于用户的访问控制，使用basic机制进行用户认证</span></span><br><span class="line">ngx_http_auth_basic_module模块</span><br><span class="line">auth_basic string | off;</span><br><span class="line">auth_basic_user_file file;</span><br><span class="line">location /admin/ &#123;</span><br><span class="line"><span class="built_in">alias</span> /webapps/app1/data;</span><br><span class="line">auth_basic <span class="string">"Admin Area"</span>;</span><br><span class="line">auth_basic_user_file /etc/nginx/.ngxpasswd;</span><br><span class="line"><span class="comment">#密码使用htpasswd命令实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态输出模块"><a href="#状态输出模块" class="headerlink" title="状态输出模块"></a>状态输出模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于输出nginx的基本状态信息</span></span><br><span class="line">ngx_http_stub_status_module</span><br><span class="line">location /basic_status&#123;</span><br><span class="line">stub_satus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#用于输出日志</span></span><br><span class="line">ngx_http_log_module</span><br><span class="line">log_format name string...</span><br><span class="line">access_log path [format [buffer=size] [gzip[=level]] [flush=time] [<span class="keyword">if</span>=condition]];</span><br><span class="line"><span class="comment">#可以在location中设置不记录指定页面的日志</span></span><br><span class="line">access_log off;</span><br><span class="line">open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</span><br><span class="line">open_log_file_cache off;</span><br><span class="line">max：缓存的最大文件描述符数量</span><br><span class="line">min_uses：在inactive指定的时长内访问大于等于此值被当作活动想</span><br><span class="line">inactive：非活动时长</span><br><span class="line">valid：验证是否为活动项的时间间隔</span><br></pre></td></tr></table></figure><h4 id="压缩模块"><a href="#压缩模块" class="headerlink" title="压缩模块"></a>压缩模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gzip压缩</span></span><br><span class="line">ngx_http_gzip_module</span><br><span class="line">gzip on | off;</span><br><span class="line"><span class="comment">#压缩比</span></span><br><span class="line">gzip_comp_level level;</span><br><span class="line"><span class="comment">#哪些浏览器不压缩，需要禁止</span></span><br><span class="line">gzip_disable regex...;</span><br><span class="line"><span class="comment">#允许压缩的最小长度</span></span><br><span class="line">gzip_min_length length;</span><br><span class="line"><span class="comment">#支持实现压缩功能时为其配置的缓冲区数量和每个缓冲区的大小</span></span><br><span class="line">gzip_buffers number size;</span><br><span class="line"><span class="comment">#作为代理服务器接收到被代理服务器的响应报文时，在何种条件下启用压缩功能</span></span><br><span class="line">gzip_proxied off | expired | no-cache | no-store</span><br><span class="line">off：不启用</span><br><span class="line"><span class="comment">#压缩过滤器，只对指定mime压缩</span></span><br><span class="line">gzip_types mime-type;</span><br></pre></td></tr></table></figure><h4 id="https模块"><a href="#https模块" class="headerlink" title="https模块"></a>https模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https配置，只能配置在一个ip上，监听tcp/443端口</span></span><br><span class="line">ngx_http_ssl_module</span><br><span class="line">ssl on | off;</span><br><span class="line"><span class="comment">#当前虚拟主机使用的PEM格式证书</span></span><br><span class="line">ssl_certificate file;</span><br><span class="line"><span class="comment">#当前主机上与其证书相匹配的私钥</span></span><br><span class="line">ssl_certificate_key file;</span><br><span class="line"><span class="comment">#ssl协议版本</span></span><br><span class="line">ssl_protocols [TLSv1.2];</span><br><span class="line"><span class="comment">#ssl会话缓存</span></span><br><span class="line">ssl_session_cache off | nono | [<span class="built_in">builtin</span>[:size]] [shared:name:size];</span><br><span class="line"><span class="built_in">builtin</span>[:size]：使用openssl内建的缓存，此缓存为每worker进程私有</span><br><span class="line">[shared:name:size]：在各worker之间使用一个共享的缓存</span><br><span class="line"><span class="comment">#客户端一侧连接可以服用ssl cache中缓存的ssl有效时长</span></span><br><span class="line">ssl_session_timeout time;</span><br></pre></td></tr></table></figure><h4 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rewrite模块，主要是对请求的url进行替换</span></span><br><span class="line">ngx_http_rewrite_module</span><br><span class="line"><span class="comment">#将客户端请求根据regex匹配后进行修改/重定向</span></span><br><span class="line">rewrite regex replacement [flag]</span><br><span class="line">flag：</span><br><span class="line">last：在服务器端实现，匹配修改后再从头开始匹配所有的rewrite</span><br><span class="line"><span class="built_in">break</span>：在服务器端实现，匹配修改后直接跳到rewrite后开始执行</span><br><span class="line">redirect：在客户端实现，服务器收到请求后匹配到将修改后的url发给客户端的浏览器，由其再次访问，返回的是302状态码</span><br><span class="line">permanent：同上，但是返回的是301状态码</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="comment">#将对png的请求全部换为jpg请求</span></span><br><span class="line">rewrite /(.*)\.png$ /<span class="variable">$1</span>.jpg</span><br><span class="line"><span class="comment">#所有请求改成https请求</span></span><br><span class="line">rewrite /(.*)$ https://www.dqy.io/<span class="variable">$1</span></span><br><span class="line"><span class="comment">#不处理，直接返回状态码或URL给客户端</span></span><br><span class="line"><span class="built_in">return</span> code [text];</span><br><span class="line"><span class="built_in">return</span> code URL;</span><br><span class="line"><span class="built_in">return</span> URL;</span><br><span class="line"><span class="comment">#是否将重写记录日志中</span></span><br><span class="line">rewrite_log on | off;</span><br><span class="line"><span class="comment">#引入一个新的配置，条件满足时执行，server、location中定义</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;...&#125;</span><br><span class="line">比较操作符：</span><br><span class="line">==</span><br><span class="line">!=</span><br><span class="line">~：正则匹配，区分大小写</span><br><span class="line">~*：不区分大小写的正则匹配</span><br><span class="line">!~：不匹配，区分大小写</span><br><span class="line">!~*：不匹配，不区分大小写</span><br><span class="line">-e,!-e：文件是否存在</span><br><span class="line">-f,!-f：是否是文件</span><br><span class="line">-d,!-d：是否是目录</span><br><span class="line">-x,!-x：是否可执行</span><br></pre></td></tr></table></figure><h4 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引用相关模块，可以防盗链</span></span><br><span class="line">ngx_http_referer_module</span><br><span class="line">valid_referers none | blocked | server_name | string...</span><br><span class="line">none：请求报文没有首部</span><br><span class="line">blocked：请求报文的referer首部没有值，可能被防火墙删除</span><br><span class="line">server_names：可以指定主机名</span><br><span class="line">arbitrary_string：直接字符串，可以使用*通配</span><br><span class="line">regular expression：正则表达式匹配，使用~开头</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">valid_referers none block server_names *.dqy.com *.frdqy.com ~\.dqy\.;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line"><span class="built_in">return</span> 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="proxy模块"><a href="#proxy模块" class="headerlink" title="proxy模块"></a>proxy模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#proxy_pass URL</span></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">server_name HOSTNAME;</span><br><span class="line">location /url&#123;</span><br><span class="line"><span class="comment">#此处路径不带url，即指明ip地址和端口后不加额外的路径符号时，将location的url附加在路径后</span></span><br><span class="line">proxy_pass http://host[:port];</span><br><span class="line"><span class="comment">#此处指明了URL，那么会将下面的url替换为location的url</span></span><br><span class="line">porxy_pass http://host[:port]/url</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#若location的url是正则匹配或者在if语句中使用proxy，那么proxy不能指定到具体的url</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#proxy_set_header field value</span></span><br><span class="line">设定发往后端主机的请求报文的请求首部的值，可以实现将客户端真正IP作为首部值发给后端服务器</span><br><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="comment">#上下实现同样功能，通常使用下文的方式</span></span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#缓存相关</span></span><br><span class="line"><span class="comment">#定义缓存路径</span></span><br><span class="line">proxy_cache_path /data/nginx/cache levels=1:1:1 keys_zone=pcache:10m max_size=2g</span><br><span class="line">levels：子目录分层，<span class="string">"1代表一个子目录"</span></span><br><span class="line">keys_zone：定义缓冲区名称</span><br><span class="line">max_size：定义缓冲区大小</span><br><span class="line"><span class="comment">#在server中调用缓存</span></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">#指明使用的缓冲区名称</span></span><br><span class="line">proxy_cache pcache;</span><br><span class="line"><span class="comment">#指明请求的哪些当作hash的键</span></span><br><span class="line">proxy_cache_key <span class="variable">$request_uri</span>;</span><br><span class="line"><span class="comment">#指明对哪些请求方法进行缓存</span></span><br><span class="line">proxy_cache_methods GET HEAD;</span><br><span class="line"><span class="comment">#指明缓存内容在规定时间内(默认10min)被访问多少次不会被剔除缓存</span></span><br><span class="line">proxy_cache_min_uses 1;</span><br><span class="line"><span class="comment">#指定状态码的网页缓存多少时间</span></span><br><span class="line">proxy_cache_valid 200 302 10m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#定义连接超时时长，默认60s，最长75s</span></span><br><span class="line">proxy_connect_timeout time;</span><br><span class="line"><span class="comment">#定义从后端服务器传送数据到代理服务器的超时时长</span></span><br><span class="line">proxy_read_timeout time;</span><br><span class="line"><span class="comment">#代理服务器向后端服务器发请求的超时时长(后端太忙不回应)</span></span><br><span class="line">proxy_send_timeout time;</span><br></pre></td></tr></table></figure><h4 id="fastcgi模块"><a href="#fastcgi模块" class="headerlink" title="fastcgi模块"></a>fastcgi模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主要用于fastcgi协议的反代，和proxy相似</span></span><br><span class="line">fastcgi_pass ip:port;</span><br><span class="line"><span class="comment">#指明默认主页</span></span><br><span class="line">fastcgi_index index.php;</span><br><span class="line"><span class="comment">#指明nginx反带给后端服务器的参数，其中SCRIPT_FILENAME要指明后端的Docunmentroot地址，使得url能够拼在路径后找到真正的资源位置</span></span><br><span class="line">fastcgi_param SCRIPT_FILENAME /date/apps/<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">include fastcgi_params;</span><br><span class="line"><span class="comment">#缓存内容与proxy相似，只是名字换成fastcgi</span></span><br><span class="line"><span class="comment">#保持连接，默认nginx反带fpm服务器后会自动断开</span></span><br><span class="line">fastcgi_keep_conn on | off;</span><br></pre></td></tr></table></figure><h4 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于定义一组服务器，即将多个相同功能的服务器定义成一个组，从而实现负载均衡。</span></span><br><span class="line"><span class="comment">#定义在http上下文中</span></span><br><span class="line"><span class="comment">#不加weight默认为1，为轮询，修改后自动为加权轮询</span></span><br><span class="line">upstream websrvs &#123;</span><br><span class="line">server 192.168.10.11:80 weight=2;</span><br><span class="line">server 192.168.10.12:80;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在server中的location中定义，其中反代时使用定义的upstream定义的名称</span></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://websrvs</span><br><span class="line">&#125;</span><br><span class="line">server参数：</span><br><span class="line"><span class="comment">#最大失败次数，为0不检测</span></span><br><span class="line">max_fails=number;</span><br><span class="line"><span class="comment">#多长时间后端主机不响应认为后端主机挂了</span></span><br><span class="line">fail_timeout=time;</span><br><span class="line"><span class="comment">#最大并发连接数</span></span><br><span class="line">max_conns=number;</span><br><span class="line"><span class="comment">#后端服务器全挂后使用backup标记的server响应</span></span><br><span class="line">backup;</span><br><span class="line"><span class="comment">#将某台服务器停止，用于灰度发布(更新)</span></span><br><span class="line">down;</span><br><span class="line"><span class="comment">#基于用户ip地址绑定后端服务器，类似于lvs的SH算法</span></span><br><span class="line">ip_hash;</span><br><span class="line"><span class="comment">#同上</span></span><br><span class="line"><span class="built_in">hash</span> <span class="variable">$remote</span>;</span><br><span class="line"><span class="comment">#将客户端请求的url当作键来绑定某个后端服务器</span></span><br><span class="line"><span class="built_in">hash</span> <span class="variable">$request_uri</span></span><br><span class="line"><span class="comment">#注意，这里hash算法可以采用一致性hash算法，即hash key [consistent]。首先根据权重将后端主机分为多个虚拟主机，然后用后端虚拟主机的ip对2^32取模，结果将会是后端主机分散在一个圆上(0~2^32-1)。然后将请求的url的hash值对2^32取模，这样它也会落在之前的圆上，然后顺时针取离其取模值最近的一台虚拟主机进行处理，这就是一致性hash算法。</span></span><br><span class="line"><span class="comment">#指明nginx的每个worker保持多少个连接</span></span><br><span class="line">keepalive 32;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事件驱动模型&quot;&gt;&lt;a href=&quot;#事件驱动模型&quot; class=&quot;headerlink&quot; title=&quot;事件驱动模型&quot;&gt;&lt;/a&gt;事件驱动模型&lt;/h3&gt;&lt;p&gt;事件驱动指当用户进程发起磁盘io时，该进程告诉内核一个回调接口，即内核加载磁盘数据到内核空间后会通知发起该动作的进程。随后，进程接收到回调信号后，参与数据从内核空间到进程空间的过程。在Linux中，事件驱动的系统调用叫做epoll，由libevent包提供。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
</feed>
