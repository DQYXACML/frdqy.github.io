<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frdqy的博客</title>
  
  <subtitle>记录默默到无闻的学习路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-22T11:21:53.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Frdqy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mariadb-存储引擎、事务</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-02-22T11:19:25.000Z</published>
    <updated>2020-02-22T11:21:53.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>存储引擎是表类型级别的概念，每张表都可以指定使用什么存储引擎。</p><a id="more"></a><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li><p>用于处理大量短期事务</p></li><li><p>支持行级锁</p></li><li><p>能够实现崩溃后自动恢复</p></li><li><p>数据存储于”表空间”，可以理解为一个建立在文件系统之上的另一个InnoDB专用的文件系统。另外，即使使用一个空的磁盘，且该磁盘不创建文件系统，InnoDB也可以在其上创建表空间进行工作。</p><ul><li>可以将所有的InnoDB表和索引放置于同一个表空间中，但是这样不利于备份且数据混乱。存放于/var/lib/mysql/ibdata1文件中。</li><li>可以每个表单独使用一个表空间存储表的数据和索引，在配置文件的mysqld字段开启：innodb_file_per_table=ON。此时数据文件存放在该表目录下名为tbl_name.idb，表格式文件存放在tbl_name.frm文件中</li></ul></li><li><p>支持MVCC来实现高并发，支持所有的四个隔离级别，默认为REPEATABLE READ；支持间隙锁防止幻读出现</p></li><li><p>使用聚集索引</p></li><li><p>支持“自适应hash索引”、预读操作、插入缓冲区来提高性能</p></li><li><p>支持热备</p></li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li>支持全文索引、压缩表</li><li>不支持事务，不支持行级锁，支持表级锁(容易出现竞争态)</li><li>崩溃后无法正常恢复</li><li>适用于只读(写操作较少)、表较小的数据库</li><li>支持延迟更新索引键</li></ul><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><p>tbl_name.frm：表格式定义文件</p><p>tbl_name.MYD：数据文件</p><p>tbl_name.MYI：索引文件</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看存储引擎</span><br><span class="line">show engines;</span><br><span class="line">#查看表状态，可以查看使用什么存储引擎</span><br><span class="line">show table status;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>一组原子性的SQL查询，或者说是一个独立的工作单元，必须满足ACID测试。他们要么全部执行(失败全部回滚)，要么全部不执行，它需要依赖事务日志文件实现崩溃后恢复。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>A：atomicity，原子性。整个事务中的所有操作要么全部执行，要么全部失败后回滚。</p><p>C：consistency，一致性。数据库总是从一个一致性状态转换为另一个一致性状态。</p><p>I：isolation，隔离性。一个事务所作出的操作在提交之前，是不能为其他所见；隔离有多种级别。</p><p>D：durability，持久性。一旦事务提交，其所做的修改会永久保存于数据库中。</p><h4 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h4><p>如果有一系列比较长的操作，但是执行到某一点时执行错了想要回滚，但是如果这时候执行了ROLLBACK那么前面一系列的指令都会全部回滚，效率十分低下。鉴于这种情况，在某条指令后使用savepoint命令创建保存点，那么下次回滚时会回滚到指定保存点的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建保存点</span><br><span class="line">SAVEPOINT point_name;</span><br><span class="line"></span><br><span class="line">#回滚指定保存点</span><br><span class="line">ROLLBACK To point_name;</span><br><span class="line"></span><br><span class="line">#清除保存点</span><br><span class="line">RELEASE SAVEPOINT point_name;</span><br></pre></td></tr></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>启动事务：START TRANSACTION</p><p>结束事务：有两种情况；COMMIT提交和ROLLBACK回滚</p><p>注意，默认情况下mysql启动autocommit来实现每个命令自动当作事务进行提交，因此建议关闭autocommit，手动显示请求和提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看是否开启自动提交</span><br><span class="line">show global variables like &#39;%auto%&#39;;</span><br><span class="line">#设置为0，即禁用自动提交</span><br><span class="line">set global autocommit&#x3D;0;</span><br></pre></td></tr></table></figure><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离级别过高可能会导致阻塞其他事务访问，因此提出隔离级别的概念</p><p>具有四个隔离级别：</p><p>READ-UNCOMMITTED：读未提交，具有脏读、不可重复读、幻读问题</p><p>READ-COMMITTED：读提交，具有不可重复读、幻读问题</p><p>REPEATABLE READ：可重读，默认innodb采用此隔离级别，具有幻读问题</p><p>SERIALIZABILE：可串行化，当前有事务执行时会阻塞其他事务(安全性高，但是几乎无法并行)</p><p>可能存在问题：</p><p>脏读：读到别人没提交的数据，即数据被回滚</p><p>不可重复读：在一次事务中读到不同的数据，即在一次事务中其他人进行了修改</p><p>幻读：为了保证可重读，即使读的数据已被其他人修改，但是在自己的一次事务中仍然认为是原来的样子(即使已经发现被修改，但是为了可重复读必须当作未修改)</p><p>加锁读：要读的数据加锁，别人无法读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看访问mysql的进程</span><br><span class="line">show processlist;</span><br><span class="line">#查看隔离相关参数tx_isolation</span><br><span class="line">show global varibles like &#39;%isolat%&#39;</span><br><span class="line">#修改参数tx_isolation为最低等级，可能会出现脏读、幻读、不可重复读</span><br><span class="line">set tx_isolation&#x3D;&#39;READ-UNCOMMITTED&#39;;</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源的状态。</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>保证事务能够回滚、持久。每个写操作都先写到事务日志中 (磁盘上的连续空间)，而不是写到数据文件中，因此避免了大量的随机IO。写操作为追加方式，因此其操作为顺序IO。这种日志被称为预写日志。通常该日志在磁盘上有两个，一个写满后写另一个，同时将写满的事务日志进行执行(默认为ib_logfile0|1，大小为5MB)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询日志相关参数，可以修改事务日志文件大小</span><br><span class="line">show global variables like inno%log%&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;存储引擎是表类型级别的概念，每张表都可以指定使用什么存储引擎。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
      <category term="存储引擎" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-索引</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E7%B4%A2%E5%BC%95/</id>
    <published>2020-02-22T06:12:35.000Z</published>
    <updated>2020-02-22T11:22:03.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h3><p>索引应该被构建在经常被用作查询条件的字段上。</p><a id="more"></a><h3 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法];</span><br><span class="line">#或者</span><br><span class="line">ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看指定表的索引</span><br><span class="line">show index from 表名;</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX 索引名 ON 表名</span><br><span class="line">#或者</span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名</span><br></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h4><p>顺序存储。由于B+树是一颗平衡二叉树，因此每个叶子节点到根节点的距离是相同的。查询时先查找根节点，然后依次往下直到叶子节点，叶子节点存储的是指向数据的指针。并且叶子节点也是顺序存储的，每个叶子节点都指向同级的其他叶子节点，因此找到一个叶子节点后就可以顺序查找到其他的叶子节点，从而也可以顺序存储其他叶子节点的数据。</p><p>由于B+树索引是左前缀索引，因此适合查询范围类的数据：如全键值数据、键值范围或键前缀查找数据等。</p><ul><li>全键值匹配：精确某个值，即完全匹配。</li><li>匹配最左前缀：只精确匹配起头部分。</li><li>匹配范围值：排序后的一个范围的值，只关心<strong>最左列</strong></li><li>精确匹配某一列，并范围匹配另一列：用于多键值匹配</li></ul><p>不适合B+树索引类型：</p><ul><li>不从最左列开始，索引无效。即如果索引是(Age,Name)而查询语句查询的顺序为Name、Age则无法使用索引</li><li>不能跳过索引中的某个列。即如果索引为(StuID,Name,Age)，而查询语句查询的是(StuID,Age)则无法使用索引</li><li>如果查询中某个列是为范围查询，那么其右侧的列都无法再使用索引。即如果索引为(StuID,Name)，此时查询StuID大于10，Name为D开头的。这种情况下即使满足最左侧查询也无法使用索引。</li></ul><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>将需要索引的列作hash运算，并将其hash结果进行分组存放，即hash结果为1的放在一个hash桶中，以此类推。这种索引方式适合进行精确匹配的查询，不能进行范围匹配。</p><p>该索引方式只在Memory存储引擎中可以使用。</p><h3 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h3><ul><li><p>索引可以降低服务需要扫描的数据量，减少IO次数；</p></li><li><p>索引可以帮助服务器避免排序和使用临时表；</p></li><li><p>索引可以帮助将随机IO转为顺序IO</p></li></ul><h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>不要让索引列字段参与计算</p><p>左前缀索引，尽量少的使用相同项，即基于左侧多少字符来进行索引创建</p><p>多列索引，通常用于and操作时使用</p><h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>可以使用explain语句来分析索引的有效性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#获取查询执行的计划信息，用来查看查询优化器如何执行查询</span><br><span class="line">explain select clause;</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">id：当前查询语句中，每个select语句的编号</span><br><span class="line">select_type：查询类型。</span><br><span class="line">simple：简单查询</span><br><span class="line">复杂查询：</span><br><span class="line">SUBQUERY：简单子查询</span><br><span class="line">DERIVED：用于FROM中的子查询</span><br><span class="line">UNION：UNION语句的第一个之后的SELECT语句</span><br><span class="line">UNION RESULT：UNION语句中的匿名表</span><br><span class="line">table：Select语句关联到的表</span><br><span class="line">type：关联类型，即mysql决定的如何去查询表中的行的方式</span><br><span class="line">ALL：全表扫描</span><br><span class="line">index：根据索引的次序进行全表扫描，可能会产生随机IO</span><br><span class="line">range：有范围限制的根据索引实现的范围扫描</span><br><span class="line">ref：根据索引返回表中匹配某单个值的所有行</span><br><span class="line">eq_ref：仅返回一个行，需要与某个参考值作比较</span><br><span class="line">const，system：直接返回单个行</span><br><span class="line">NULL：没有使用索引</span><br><span class="line">possible_keys：查询可能会用到的索引</span><br><span class="line">key：查询中使用了的索引</span><br><span class="line">key_len：在索引中使用的字节数</span><br><span class="line">ref：在利用key字段所表示的索引完成查询时所用的列或常量值</span><br><span class="line">rows：mysql为找到所有目标而读取的行数</span><br><span class="line">extra：额外信息</span><br><span class="line">Using index：mysql使用覆盖索引，以避免访问表</span><br><span class="line">Using where：mysql将在存储引擎层检索后再进行过滤，即过滤where条件</span><br><span class="line">Using temporary：mysql对结果排序时会使用临时表</span><br><span class="line">Using filesort：mysql对结果使用外部索引排序</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本法则&quot;&gt;&lt;a href=&quot;#基本法则&quot; class=&quot;headerlink&quot; title=&quot;基本法则&quot;&gt;&lt;/a&gt;基本法则&lt;/h3&gt;&lt;p&gt;索引应该被构建在经常被用作查询条件的字段上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>mariadb-用户权限、缓存</title>
    <link href="http://yoursite.com/2020/02/22/mariadb-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/22/mariadb-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E3%80%81%E7%BC%93%E5%AD%98/</id>
    <published>2020-02-22T06:12:02.000Z</published>
    <updated>2020-02-22T11:21:59.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="权限类别"><a href="#权限类别" class="headerlink" title="权限类别"></a>权限类别</h3><p>mysql数据库的权限主要分为库、表、字段、管理、程序等类别。</p><a id="more"></a><h4 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h4><ul><li>create temporary tables：创建临时表，一般为16mb，存储在内存中</li><li>create user：创建用户</li><li>file：将当前数据库保存到文件中，或者从文件中导入数据库</li><li>super：高级管理类权限，如授权等</li><li>show databases：查看数据库，一般所有用户都有</li><li>reload：重新装载授权表</li><li>shutdown：进程级别关闭数据库</li><li>replication slave：是否能够实现复制功能</li><li>replication client：是否能向主服务器请求复制</li><li>lock tables：锁表</li><li>process：与mysql进程相关</li></ul><h4 id="程序类"><a href="#程序类" class="headerlink" title="程序类"></a>程序类</h4><ul><li>function：创建、修改、删除、执行函数</li><li>procedure：创建、修改、删除、执行函数</li><li>trigger：创建、修改、删除、执行触发器</li></ul><h4 id="库和表类"><a href="#库和表类" class="headerlink" title="库和表类"></a>库和表类</h4><ul><li>alter：修改</li><li>create：创建</li><li>create view：创建视图</li><li>drop：删除</li><li>index：创建或删除索引</li><li>show view：查看视图</li><li>grant option：能把自己获得权限赠给其他用户一个副本</li></ul><h4 id="数据字段类"><a href="#数据字段类" class="headerlink" title="数据字段类"></a>数据字段类</h4><ul><li>select：查询字段</li><li>insert：修改字段</li><li>delete：删除字段</li><li>update：更新字段</li></ul><h4 id="所有权限类"><a href="#所有权限类" class="headerlink" title="所有权限类"></a>所有权限类</h4><ul><li>all privileges：表示所有有限权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#以上信息都存放在mysql元数据表中</span><br><span class="line">use mysql;</span><br><span class="line">show tabels;</span><br><span class="line"></span><br><span class="line">db、host、user：用于实现用户授权，即用户登录等限制信息</span><br><span class="line">columns_priv, tables_priv, procs_priv, proxies_priv：表、程序、代理级别的权限</span><br></pre></td></tr></table></figure><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create user &#39;username&#39;@&#39;host&#39; [identified by &#39;password&#39;];</span><br><span class="line">username：用户名</span><br><span class="line">host：允许用户登录的网段，可使用%通配</span><br><span class="line">password：用户密码</span><br></pre></td></tr></table></figure><h4 id="查看用户授权"><a href="#查看用户授权" class="headerlink" title="查看用户授权"></a>查看用户授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><h4 id="重命名用户"><a href="#重命名用户" class="headerlink" title="重命名用户"></a>重命名用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename user old_user_name to new_user_name;</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第一种</span><br><span class="line">set password for</span><br><span class="line">#第二种，不自动更新授权表，需要执行flush privileges</span><br><span class="line">update mysql.user set password&#x3D;PASSWORD(&#39;your_password&#39;) where clause;</span><br><span class="line">#第三种</span><br><span class="line">mysqladm password</span><br></pre></td></tr></table></figure><h4 id="忘记管理员密码"><a href="#忘记管理员密码" class="headerlink" title="忘记管理员密码"></a>忘记管理员密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、启动mysqld进程时，使用--skip-grant-tables --skip-networking来跳过授权以及网络连接，centos7需要修改对应service文件</span><br><span class="line">2、使用update命令修改管理员密码</span><br><span class="line">3、重启mysqld进程</span><br></pre></td></tr></table></figure><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type[,...] ON [&#123;table|function|procedure&#125;] db.&#123;table|routine&#125; TO &#39;USERNAME&#39;@&#39;HOST&#39; [IDENTIFIED BY &#39;password&#39;] [REQUIRE SSL] [WITH with_option]</span><br><span class="line">with_option：</span><br><span class="line">MAX_QUERIES_PER_HOUR count：每小时最多查询数</span><br><span class="line">MAX_UPDATES_PER_HOUR count：每小时最多更新数</span><br><span class="line">MAX_CONNECTIONS_PER_HOUR count：每小时最大连接数</span><br><span class="line">MAX_USER_CONNECTIONS count：每个用户最大连接数</span><br></pre></td></tr></table></figure><h4 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE priv_type [(column_list)] [,priv_type [(column_list)]] ... ON [object_type] priv_level FROM user [,user]...</span><br></pre></td></tr></table></figure><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h4 id="判断是否命中"><a href="#判断是否命中" class="headerlink" title="判断是否命中"></a>判断是否命中</h4><p>通过查询语句的hash值判断，需要考虑几个因素：</p><ul><li>查询语句本身，查询语句任何字符上的不同都会导致缓存不能命中；若查询语句中包含用户自定义函数、存储函数、用户自定义变量、临时表、mysql系统表、列级权限表、不确定值的函数等都不会被缓存</li><li>要查询的数据库</li><li>客户端使用的协议版本</li></ul><h4 id="缓存效率"><a href="#缓存效率" class="headerlink" title="缓存效率"></a>缓存效率</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#查看mysql查询缓存相关变量</span><br><span class="line">show global variables like &#39;%query%&#39;</span><br><span class="line">#查询相关缓存状态变量</span><br><span class="line">show global status like &#39;Qcache%&#39;</span><br><span class="line"></span><br><span class="line">#命中率</span><br><span class="line">Qcache_hits&#x2F;(Qcache_hits+Com_select)</span><br><span class="line"></span><br><span class="line">#有关变量</span><br><span class="line">query_cache_min_res_unit：查询缓存的内存分配最小单位；值减少会减少浪费，但会导致更频繁的内存分配；值较大时会导致碎片过多，可以使用FLUSH QUERY CACHE来减少碎片</span><br><span class="line">query_cache_limit：mysql能够缓存的最大查询结果；对于有着较大结果的查询语句，建议在select中使用SQL_NO_CACHE来显示指定不缓存</span><br><span class="line">query_cache_size：查询缓存可用的内存空间，必须是1024整数倍，单位为字节</span><br><span class="line">query_cache_type：缓存类型，ON、OFF、DEMAND，DEMAND表示只有查询语句显示指定SQL_CACHE时才缓存</span><br><span class="line">query_cache_wlock_invalidate：如果某表被其他连接锁定，是否仍从查询返回结果，默认为OFF</span><br><span class="line"></span><br><span class="line">#常见问题及修改</span><br><span class="line">查询结果过大导致不能缓存，需要提高query_cache_limit值</span><br><span class="line">内存碎片化，需要减少query_cache_min_res_unit值</span><br><span class="line">如果缓存空间太小，导致缓存不断换入换出，需要提高query_cache_size值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;权限类别&quot;&gt;&lt;a href=&quot;#权限类别&quot; class=&quot;headerlink&quot; title=&quot;权限类别&quot;&gt;&lt;/a&gt;权限类别&lt;/h3&gt;&lt;p&gt;mysql数据库的权限主要分为库、表、字段、管理、程序等类别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mariadb" scheme="http://yoursite.com/categories/mariadb/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mariadb" scheme="http://yoursite.com/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>10矩阵中的路径</title>
    <link href="http://yoursite.com/2020/02/19/10%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/02/19/10%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-02-19T11:27:38.000Z</published>
    <updated>2020-02-19T11:30:20.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><a id="more"></a><p>[ [ “a”,”<strong>b</strong>“,”c”,”e” ],<br>[ “s”,”<strong>f</strong>“,”<strong>c</strong>“,”s” ],<br>[ “a”,”d”,”<strong>e</strong>“,”e” ] ]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.backtrace(board, word, <span class="number">0</span>, i, j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrace</span><span class="params">(self, board, word, index, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != word[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        tmp = board[i][j]</span><br><span class="line">        board[i][j] = <span class="number">0</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.backtrace(board, word, index, i - <span class="number">1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">                j &gt; <span class="number">0</span> <span class="keyword">and</span> self.backtrace(board, word, index, i, j - <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                i &lt; len(board) - <span class="number">1</span> <span class="keyword">and</span> self.backtrace(board, word, index, i + <span class="number">1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">                j &lt; len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> self.backtrace(board, word, index, i, j + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思路是回溯，从第一位开始匹配，需要记录待匹配的字符串的下标用于比较是否匹配结束</span></span><br><span class="line"><span class="comment">//进入回溯后判断当前待匹配下标和矩阵的值是否相等，相等就继续上下左右回溯(注意区间)</span></span><br><span class="line"><span class="comment">//上下左右均未找到则恢复矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>** board, <span class="keyword">int</span> boardSize, <span class="keyword">int</span>* boardColSize, <span class="keyword">char</span>* <span class="keyword">word</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] != <span class="keyword">word</span>[index])<span class="comment">//当前字母不相等</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (index + <span class="number">1</span> == <span class="built_in">strlen</span>(<span class="keyword">word</span>))<span class="comment">//最后一个字母相等，路径正确</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">char</span> tmp = board[i][j];<span class="comment">//暂存当前</span></span><br><span class="line">board[i][j] = <span class="number">0</span>;<span class="comment">//避免重复使用</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">(i &gt; <span class="number">0</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i - <span class="number">1</span>, j))</span><br><span class="line">|| (j &gt; <span class="number">0</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i, j - <span class="number">1</span>))</span><br><span class="line">|| (i &lt; boardSize - <span class="number">1</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i + <span class="number">1</span>, j))</span><br><span class="line">|| (j &lt; *boardColSize - <span class="number">1</span> &amp;&amp; backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, index, i, j + <span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">board[i][j] = tmp;<span class="comment">//没找到，进行恢复</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>** board, <span class="keyword">int</span> boardSize, <span class="keyword">int</span>* boardColSize, <span class="keyword">char</span>* <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boardSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *boardColSize; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (backtrack(board, boardSize, boardColSize, <span class="keyword">word</span>, <span class="number">0</span>, i, j))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>09旋转数组的最小数字</title>
    <link href="http://yoursite.com/2020/02/19/09%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/19/09%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-19T11:24:33.000Z</published>
    <updated>2020-02-19T11:30:15.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,2,2,0,1]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low=<span class="number">0</span></span><br><span class="line">        high=len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;high:</span><br><span class="line">            mid=(low+high)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &lt; numbers[high]:</span><br><span class="line">                high=mid</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &gt; numbers[high]:</span><br><span class="line">                low=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若中间的数比最后一个数大，最小值在右边</span></span><br><span class="line"><span class="comment">//若中间的数比最后一个数小，最小值在左边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> numbersSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = numbersSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (numbers[mid]&lt;numbers[high])</span><br><span class="line">&#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&gt;numbers[high])</span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numbers[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>08青蛙跳台阶</title>
    <link href="http://yoursite.com/2020/02/19/08%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2020/02/19/08%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-19T11:22:56.000Z</published>
    <updated>2020-02-19T11:30:12.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 7</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同斐波拉契一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            a.append((a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>])%<span class="number">1000000007</span>)</span><br><span class="line">        <span class="keyword">return</span> a[n]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与斐波拉契一样</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>07斐波拉契数列</title>
    <link href="http://yoursite.com/2020/02/19/07%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/19/07%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2020-02-19T11:21:12.000Z</published>
    <updated>2020-02-19T11:30:09.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><a id="more"></a><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 5</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不能递归，复杂度太高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        fb=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            fb.append((fb[i<span class="number">-1</span>]+fb[i<span class="number">-2</span>])%<span class="number">1000000007</span>)</span><br><span class="line">        <span class="keyword">return</span> fb[n]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归 斐波拉契</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">1000000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;p&gt;F(0) = 0,   F(1) = 1&lt;br&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;br&gt;斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>06两个栈实现队列</title>
    <link href="http://yoursite.com/2020/02/19/06%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/19/06%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-02-19T11:19:33.000Z</published>
    <updated>2020-02-19T11:30:07.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个栈用于入队，另一个栈将前一个栈倒序后再pop即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack=[]</span><br><span class="line">        self.outstack=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.instack.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一次删除时执行栈倒转，后面不用再执行了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br><span class="line">        <span class="keyword">if</span> self.outstack:</span><br><span class="line">            <span class="keyword">return</span> self.outstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>* inStack;</span><br><span class="line"><span class="keyword">int</span> intop;</span><br><span class="line"><span class="keyword">int</span>* outStack;</span><br><span class="line"><span class="keyword">int</span> outtop;</span><br><span class="line">&#125;CQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">CQueue* <span class="title">cQueueCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CQueue* obj = (CQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CQueue));</span><br><span class="line">obj-&gt;inStack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">obj-&gt;intop = <span class="number">-1</span>;</span><br><span class="line">obj-&gt;outStack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">obj-&gt;outtop = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueAppendTail</span><span class="params">(CQueue* obj, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">obj-&gt;inStack[++obj-&gt;intop] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cQueueDeleteHead</span><span class="params">(CQueue* obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj-&gt;intop == <span class="number">-1</span> &amp;&amp; obj-&gt;outtop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;outtop == <span class="number">-1</span>)<span class="comment">//第一次删除时执行栈倒转，后面不用再执行了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (obj-&gt;intop &gt; <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">obj-&gt;outStack[++obj-&gt;outtop] = obj-&gt;inStack[obj-&gt;intop--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj-&gt;outStack[obj-&gt;outtop--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueFree</span><span class="params">(CQueue* obj)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(obj-&gt;inStack);</span><br><span class="line">obj-&gt;inStack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(obj-&gt;outStack);</span><br><span class="line">obj-&gt;outStack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>05重建二叉树</title>
    <link href="http://yoursite.com/2020/02/18/05%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/02/18/05%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-18T10:03:45.000Z</published>
    <updated>2020-02-19T11:17:13.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">      &#x2F;  \</span><br><span class="line">    15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 节点个数 &lt;= 5000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据前序和中序建树，首先前序第一个元素为根，按这个根找到中序的索引，根据索引将中序切分成两个，前序就依次往后进行递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 找中序根节点索引下标，将树拆开</span></span><br><span class="line">        idx = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:idx+<span class="number">1</span>], inorder[:idx])</span><br><span class="line">        <span class="comment"># 右子树</span></span><br><span class="line">        root.right = self.buildTree(preorder[idx+<span class="number">1</span>:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span> preorderSize, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> inorderSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (preorder == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> = (<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">root-&gt;val = preorder[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//找中序下标</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; inorderSize&amp;&amp;inorder[index] != preorder[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆分左右子树进行递归</span></span><br><span class="line">root-&gt;left = buildTree(preorder + <span class="number">1</span>, index, inorder, index);</span><br><span class="line">root-&gt;right = buildTree(preorder + <span class="number">1</span> + index, preorderSize - (index + <span class="number">1</span>), inorder + index + <span class="number">1</span>, inorderSize - (index + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>04从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/02/18/04%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/18/04%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-18T10:03:02.000Z</published>
    <updated>2020-02-19T11:16:29.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head &#x3D; [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 链表长度 &lt;= 10000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将链表放到列表中，列表从后往前放到新的列表中。尽量不使用reverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head:ListNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sc=[]</span><br><span class="line">        result=[]</span><br><span class="line">        hd=head</span><br><span class="line">        <span class="keyword">while</span> hd:</span><br><span class="line">            sc.append(hd.val)</span><br><span class="line">            hd=hd.next</span><br><span class="line">        <span class="keyword">while</span> sc:</span><br><span class="line">            result.append(sc.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">hd</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">int</span>* ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//将链表转为数组</span></span><br><span class="line"><span class="keyword">while</span> (hd)</span><br><span class="line">&#123;</span><br><span class="line">ret[index++] = hd-&gt;val;</span><br><span class="line">hd = hd-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//数组前后调换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ceil</span>(index/<span class="number">2</span>) ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = ret[i];</span><br><span class="line">ret[i] = ret[index - i - <span class="number">1</span>];</span><br><span class="line">ret[index - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">*returnSize = index;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>03替换空格</title>
    <link href="http://yoursite.com/2020/02/18/03%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/02/18/03%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2020-02-18T10:02:24.000Z</published>
    <updated>2020-02-19T11:15:15.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;We are happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= s 的长度 &lt;= 10000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串转列表判断完再拼成字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lst = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">            <span class="keyword">if</span> lst[i] == <span class="string">' '</span>:</span><br><span class="line">                lst[i] = <span class="string">'%20'</span></span><br><span class="line">        s = <span class="string">''</span>.join(lst)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span>* s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j++] = <span class="string">'%'</span>;</span><br><span class="line">str[j++] = <span class="string">'2'</span>;</span><br><span class="line">str[j++] = <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">str[j++] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    str[j]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请实现一个函数，把字符串 s 中的每个空格替换成”%20”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>02二维数组中的查找</title>
    <link href="http://yoursite.com/2020/02/18/02%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/02/18/02%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-18T10:01:43.000Z</published>
    <updated>2020-02-19T11:15:24.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><p><code>0 &lt;= n &lt;= 1000</code></p></li><li><p><code>0 &lt;= m &lt;= 1000</code></p></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上下都有序，可以从第一排的最后一个开始比较，如果大于它说明大于整个第一排的元素，行指针加1，直到比较到一个小于的，再列指针减少，到最小仍未匹配说明不存在</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> matrix==[]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i,j=[<span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; matrix[i][j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#测试用例有一个[]和[[]]，需要特殊化处理；或者先判断长度</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = *matrixColSize;</span><br><span class="line"><span class="keyword">if</span> (matrixSize==<span class="number">0</span>||matrix==<span class="literal">NULL</span>||matrixColSize==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;matrixSize&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j]=target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>01数组中重复的数字</title>
    <link href="http://yoursite.com/2020/02/18/01%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/18/01%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-18T09:59:43.000Z</published>
    <updated>2020-02-19T11:15:38.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出数组中重复的数字。</p><a id="more"></a><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 或 3</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= n &lt;= 100000</code></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标记已出现的数字个数，并同时判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums:List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr=[<span class="number">0</span>]*len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            arr[nums[i]]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[nums[i]]&gt;<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment">#优化：使用字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums:List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        repeatDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> repeatDict:</span><br><span class="line">                repeatDict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        </span><br><span class="line"><span class="comment">#优化：原地hash</span></span><br><span class="line"><span class="comment">#如果num[i]的值和以num[i]为下标的值相等，那么就出现过，如果不相等就元素互换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> i != nums[i]:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[nums[i]]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地hash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize ; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[temp] = temp;<span class="comment">//此处是坑点，第一次没发现nums[i]已经变了，不能正常交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;找出数组中重复的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis(6)-集群</title>
    <link href="http://yoursite.com/2020/02/14/Redis-6-%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2020/02/14/Redis-6-%E9%9B%86%E7%BE%A4/</id>
    <published>2020-02-14T08:27:10.000Z</published>
    <updated>2020-02-19T02:12:36.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><p>考虑一种场景：现在后端有多个redis服务器提供<strong>缓存</strong>功能，客户端向redis写时想要实现在不同的redis服务器中写，从而使得redis服务器的压力减少，这里就需要算法来将数据映射到某个redis服务器上，从而引出一致性hash算法。</p><a id="more"></a><p>一致性hash是在0~2^32次方之间进行映射，将每个物理节点按照该算法映射到一个逻辑圆上，有数据到达时将数据也hash，然后也会映射到逻辑圆上，然后顺时针找一个最近的物理节点，将数据存储到该物理节点。</p><p>但是这样会引起一个新的问题，即数据倾斜问题，例如一批数据总是映射到一个分段上，因此会存储到同一个物理节点上，这样该物理节点会有很大的存储压力。为了解决该问题提出了虚拟节点的概念，即将一个物理节点逻辑上分成多份，映射到逻辑圆的其他地方，这样就一定程度上减少数据倾斜现象的出现。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>redis集群就是一个分布式数据库，通过分片机制进行数据分布，集群内的每个节点仅拥有数据库的一部分数据。redis集群是去中心化集群，即客户端访问该集群的任意一个节点都可以获取全部数据。这是因为集群内的每个节点都拥有全局键的元数据表，即如果当前节点没有客户端访问的键时，会将真正的键的位置告诉客户端，客户端程序会自动去真正的节点寻找。</p><p>分片机制就是上面说的hash计算，不过不是一致性hash，采用的是取模运算，只不过这个模数很大(16384)可以方便后续增加。每个数据经过取模运算后会得到一个数，这个数叫做槽位，每个redis服务器存放不同的槽位的数据，并且当有新的redis服务器加入时会将现有的每个redis服务器的一部分槽位进行迁移，当然槽位对应的数据也会迁移。</p><p>集群内部中也需要配置主从，并且内部也是采用哨兵模式，如果有半数节点发现某个异常节点，共同决定更改异常节点的状态，如果改节点是主节点，则对应的从节点自动顶替为主节点，当原先的主节点上线后，则会变为从节点。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="twemproxy"><a href="#twemproxy" class="headerlink" title="twemproxy"></a>twemproxy</h4><h5 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译安装twemproxy</span></span><br><span class="line"><span class="comment">#https://github.com/twitter/twemproxy</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/twitter/twemproxy.git</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">src/nutcracker -h</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建配置文件目录</span></span><br><span class="line">mkdir /etc/nutcracker</span><br><span class="line"><span class="comment">#移动配置文件到该目录下</span></span><br><span class="line">mv ~/soft/twemproxy/twemproxy/conf/nutcracker.* .</span><br><span class="line"><span class="comment">#移动可执行文件</span></span><br><span class="line">mv nutcracker /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建twemproxy.service</span></span><br><span class="line"><span class="comment">#vim /lib/systemd/system/twemproxy.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=twemproxy Service</span><br><span class="line">After=syslog.target network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/nutcracker -d -c /etc/nutcracker/nutcracker.yml</span><br><span class="line">ExecStop=<span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/&amp;&amp;pkill nutcracker</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#创建软连接</span></span><br><span class="line">ln -s /lib/systemd/system/twemproxy.Service /etc/systemd/system/multi-user.target.wants/twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> twemproxy</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alpha:<span class="comment">#随便一个名字</span></span><br><span class="line">  listen: 0.0.0.0:22121<span class="comment">#监听端口</span></span><br><span class="line">  <span class="built_in">hash</span>: crc16<span class="comment">#hash算法</span></span><br><span class="line">  distribution: ketama<span class="comment">#一致性hash</span></span><br><span class="line">  auto_eject_hosts: <span class="literal">true</span><span class="comment">#用于控制twemproxy是否应该根据server的连接状态重建群集 </span></span><br><span class="line">  backlog: 2048<span class="comment">#TCP的backlog长度</span></span><br><span class="line">  redis: <span class="literal">true</span><span class="comment">#默认代理memcache，设置为true代理redis</span></span><br><span class="line">  server_retry_timeout: 200<span class="comment">#控制服务器连接的时间间隔</span></span><br><span class="line">  server_failure_limit: 1<span class="comment">#控制连接服务器的次数</span></span><br><span class="line">  servers:<span class="comment">#代理的后端服务器ip和端口，1为权重</span></span><br><span class="line">  -127.0.0.1:6379:1</span><br><span class="line">  -127.0.0.1:6380:1</span><br><span class="line">  </span><br><span class="line"><span class="comment">#配置好后重启并使用redis-cli进入22121端口，之后对22121访问即可访问后端主机</span></span><br><span class="line">systemctl restart twemproxy</span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure><h4 id="predixy"><a href="#predixy" class="headerlink" title="predixy"></a>predixy</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://github.com/joyieldInc/predixy</span></span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#详情见https://github.com/joyieldInc/predixy/blob/master/doc/config_CN.md</span></span><br><span class="line"><span class="comment">#通用</span></span><br><span class="line">Name<span class="comment">#定义名称</span></span><br><span class="line">Bind 0.0.0.0:7617<span class="comment">#定义端口和地址，也可以使用socket</span></span><br><span class="line">WorkerThreads<span class="comment">#线程数</span></span><br><span class="line">MaxMemory<span class="comment">#最大可使用内存</span></span><br><span class="line">ClientTimeout<span class="comment">#客户端连接超时</span></span><br><span class="line">BufSize<span class="comment">#用于实现零拷贝</span></span><br><span class="line">Log<span class="comment">#日志</span></span><br><span class="line">LogRotate<span class="comment">#日志切分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sentinel实例</span></span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">"&#123;&#125;"</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 10.2.2.2:7500</span><br><span class="line">        + 10.2.2.3:7500</span><br><span class="line">        + 10.2.2.4:7500</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#定义一个redis组，Group的名字应该和redis sentinel里面的名字一致；有几个主从设置几个group</span></span><br><span class="line">    Group shard001 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Group shard002 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">多个主从时不能使用事务，只有一个主从时才能使用事务</span><br></pre></td></tr></table></figure><h4 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis-cluster"></a>redis-cluster</h4><p>redis自身的集群已经在源码包里编译过了，实际就是一个脚本命令。该集群去中心化，原理在上面讲过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/root/soft/redis-5.0.7/utils/create-cluster目录下create-cluster脚本，实际是调用redis-cli --cluster</span></span><br><span class="line"><span class="comment">#启动集群</span></span><br><span class="line">create-cluster start</span><br><span class="line"><span class="comment">#分配槽点，可以手动redis-cli --cluster设置</span></span><br><span class="line">create-cluster create</span><br><span class="line"><span class="comment">#redis-cli --cluster手动分配槽点</span></span><br><span class="line">redis-cli --cluster create ip:port[ ip:port....] --cluster-replicas</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本设置，create-cluster脚本内容</span></span><br><span class="line">PORT=30000<span class="comment">#端口</span></span><br><span class="line">TIMEOUT=2000<span class="comment">#超时时长</span></span><br><span class="line">NODES=6<span class="comment">#几个redis节点</span></span><br><span class="line">REPLICAS=1<span class="comment">#NODES*REPLICAS为redis实例个数，此处为6表示3个主，3个从</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接集群入口，-c表示是集群，会自动重定向</span></span><br><span class="line">redis-cli -c -p 30001</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新分配槽位，可以手动指定移动的槽位数、目标redis的id等</span></span><br><span class="line">redis-cli --cluster reshard ip:port</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">这时可以使用事务操作，但是可能会导致不同的key在不同的redis实例上导致事务失败。</span><br><span class="line">可以人为的给key设置前缀使得其分配到同一个rendis上，这样就可以使用事务</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一致性hash&quot;&gt;&lt;a href=&quot;#一致性hash&quot; class=&quot;headerlink&quot; title=&quot;一致性hash&quot;&gt;&lt;/a&gt;一致性hash&lt;/h3&gt;&lt;p&gt;考虑一种场景：现在后端有多个redis服务器提供&lt;strong&gt;缓存&lt;/strong&gt;功能，客户端向redis写时想要实现在不同的redis服务器中写，从而使得redis服务器的压力减少，这里就需要算法来将数据映射到某个redis服务器上，从而引出一致性hash算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="predixy" scheme="http://yoursite.com/tags/predixy/"/>
    
      <category term="twemproxy" scheme="http://yoursite.com/tags/twemproxy/"/>
    
  </entry>
  
  <entry>
    <title>Redis(5)-主从复制</title>
    <link href="http://yoursite.com/2020/02/14/Redis-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/14/Redis-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2020-02-14T08:26:42.000Z</published>
    <updated>2020-02-19T02:12:33.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>redis的主从复制与mysql类似，将数据从master复制到slave，从而实现数据集的冗余。用户向master端写数据时，redis通过sync以非阻塞方式向slave发送数据，从而slave执行相同操作。另外每个master可以有多个slave，每个slave也可以有slave，即支持串行链式复制。</p><a id="more"></a><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>master以ping的方式来检测slave是否在线(也可以被动接收slave的sync请求)，如果slave在线则master启动子进程将内存中的数据以快照方式(RDB)保存到文件中并将该文件发送给slave，这个文件保存在slave的磁盘中，之后再将slave磁盘中的数据装载到其内存中(slave装载前会将自身FLUSHALL)。第一次建立时会消耗很多时间将整个数据集同步，后来master会持续将新的写操作发送给slave从而保持一致性操作。</p><p>注意，如果slave挂了再重启，如果是RDB模式，dump文件中会保存master的id，从而实现增量恢复。而如果使用AOF模式，那么即使现在AOF采用RDB先备份，也无法实现增量，而是全量恢复。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在slave服务器的配置文件中加入：</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者在slave命令行(redis-cli)中使用slaveof命令，5.0后改成replicaof</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#/etc/redis/目录下配置文件</span></span><br><span class="line">replica-serve-stale-data<span class="comment">#主从复制时如何处理客户端请求，默认yes表示正常应答(会有过时数据)，no表示拒绝并返回错误提示</span></span><br><span class="line">replica-read-only<span class="comment">#从节点是否处理写请求，默认为yes</span></span><br><span class="line">repl-diskless-sync<span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line">repl-diskless-sync-delay<span class="comment">#当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能只需将它设置为0秒，传送会立即启动。默认值为5。</span></span><br><span class="line">repl-disable-tcp-nodelay<span class="comment">#默认值为no。yes表示redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。</span></span><br><span class="line">repl-backlog-size 1mb<span class="comment">#redis内存维护的队列，用于存储增量备份时的增量，给slave进行增量恢复</span></span><br><span class="line">slave-priority 100<span class="comment">#指明slave的优先级，数字越小优先级越低</span></span><br><span class="line">min-slaves-to-write 3<span class="comment">#如果slave服务器小于3个，master服务器就拒绝写请求</span></span><br><span class="line">min-slaves-max-lag 10<span class="comment">#slave服务器不能滞后于master10s以上，否则master拒绝写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">设置主从复制时，从服务器的<span class="built_in">bind</span>地址和主服务地址必须是同一网段的，或者直接0.0.0.0更好，否则会无法连接</span><br><span class="line">如果master使用requirepass开启认证功能，slave需要使用masterauth &lt;password&gt;进行认证</span><br></pre></td></tr></table></figure><h3 id="sentinel哨兵"><a href="#sentinel哨兵" class="headerlink" title="sentinel哨兵"></a>sentinel哨兵</h3><p>哨兵，是独立进程(redis-sentinel)，它用于监视主从多个redis服务器中master服务器的工作状态(它只监视master是因为可以从master中获取slave信息)。它获取master的信息并通过master就可以获取它的从节点的信息，一旦master挂了就可以调度slave充当master。当然为了避免哨兵误判master，哨兵的个数一般也是3个以上的奇数个，当一个哨兵检测不到master时会判断其他哨兵能否检测，如果所有哨兵都检测不到master则说明master真正挂了，从而调度slave成为master。</p><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>服务器自身初始化，运行redis-sentinel或者redis-server中专用sentinel的代码；然后初始化sentinel状态，根据给定的配置文件初始化监控的master服务器列表；最后创建连接master的连接。</p><p>sentinel会以秒级为单位向各个master发送ping命令，对方必须回复pong，否则就会判定主观下线，若多个sentinel都ping不通该master则表示master挂了，即为客观下线。</p><ul><li>主观下线：一个sentinel判断master下线</li><li>客观下线：多个sentinel均判断master下线</li></ul><p>当过半的sentinel发现某master下线，之后即判定该master已故障下线。然后sentinel根据各个slave的优先级来投票选举新的master，将选举出来的slave切换为master，然后将原来的master变为slave并添加到新的master的slave信息中，同步数据并修改sentinel的新master地址，至此，故障转移结束。</p><p>需要过半的原因是考虑到脑裂问题(也叫做网络分区问题)，比如有3个sentinel，其中3个分别独立监控master，那么如果一个sentienl发现master下线，另一个发现sentienl在线，那么是不能判断master到底是否在线。因此需要过半的sentinel一致判断master下线才能说明master真下线。</p><p>sentinel通常使用奇数，考虑一种情况：3个sentinel和4个sentinel的模型，由于需要过半的sentinel决策才不会出现脑裂问题，那么3个sentinel需要2个决策，允许1个发生错误；4个sentinel需要3个决策，容许1个发生错误，考虑到4个sentinel发生1个故障的风险肯定要比3个sentinel发生1个故障的风险要大，因此只考虑奇数个sentinel。(这不仅仅是钱的问题，更是风险问题)</p><p>另外，我们知道一个sentinel通过它监控的master可以获得其他slave的信息，但是sentinel是如何知道其他sentinel的存在的呢？这里使用了消息订阅机制，即所有sentinel都不断的在一个channel叫做<code>&quot;__sentinel__&quot;</code>的频道发送hello消息，其他sentinel只要订阅这个channel就可以知道还有哪些sentinel在线。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sentinel配置文件需要手动创建，此处创建为sentinel-6379.conf</span></span><br><span class="line"><span class="comment">#在源码目录的src里也有配置文件实例</span></span><br><span class="line"><span class="comment">#设置监听端口</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment">#是否运行为守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#日志syslog</span></span><br><span class="line">logfile <span class="string">"26379.log"</span></span><br><span class="line"><span class="comment">#临时文件目录</span></span><br><span class="line">dir <span class="string">"/tmp"</span></span><br><span class="line"><span class="comment">#指明监控的主节点，mymaster表示自定义的master名称，后接主节点ip和port；2表示sentinel同意的数量；可以定义多个，即一组sentinel集群可以监控多个m/s集群</span></span><br><span class="line">sentinel monitor mymaster 192.168.250.132 7000 2</span><br><span class="line"><span class="comment">#判断master不在线的超时时长，单位为ms</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment">#新创建master时允许多少slave向其发送请求</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment">#故障转移的超时时长，即master挂了后slave变为新master的超时时长，单位为ms</span></span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br><span class="line"><span class="comment">#master启动auth时需要验证</span></span><br><span class="line">sentinel auth-pass mymaster 123</span><br></pre></td></tr></table></figure><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用该命令根据PATH位置的配置文件启动一个sentinel</span></span><br><span class="line">redis-sentinel PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用redis-cli可以进入交互式</span></span><br><span class="line">redis-cli -h IP -p PORT</span><br><span class="line"></span><br><span class="line"><span class="comment">#相关命令</span></span><br><span class="line"><span class="comment">#查看master信息</span></span><br><span class="line">sentinel masters</span><br><span class="line"><span class="comment">#查看slave信息，需要指明是哪个master集群的</span></span><br><span class="line">sentinel slaves &lt;master name&gt;</span><br><span class="line"><span class="comment">#根据master名称获取master地址</span></span><br><span class="line">sentinel get-master-addr-by-name &lt;master name&gt;</span><br><span class="line"><span class="comment">#重置所有操作</span></span><br><span class="line">sentinel reset</span><br><span class="line"><span class="comment">#手动执行故障转移</span></span><br><span class="line">sentinel failover &lt;master name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h3&gt;&lt;p&gt;redis的主从复制与mysql类似，将数据从master复制到slave，从而实现数据集的冗余。用户向master端写数据时，redis通过sync以非阻塞方式向slave发送数据，从而slave执行相同操作。另外每个master可以有多个slave，每个slave也可以有slave，即支持串行链式复制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="主从复制" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis(4)-持久化</title>
    <link href="http://yoursite.com/2020/02/13/Redis-4-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/13/Redis-4-%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-02-13T14:01:13.000Z</published>
    <updated>2020-02-19T02:12:30.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>redis数据全部保存在内存中，因此它处理请求很快，但是为了长久保存这些数据还需要将内存中的数据保存到磁盘中，这就引出持久化概念。需要注意的是，持久化不能取代备份，仍然要指定相关的备份策略。</p><a id="more"></a><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>当我们使用fork系统调用生成一个子进程时，为了提高进程创建的速度，子进程的内存不使用调度的方式分配，而是使用类似页面共享的方法，即子进程的虚拟地址和物理地址的映射和父进程映射是相同的，子进程的地址空间相当于父进程的副本。</p><p>当子进程或者父进程发生写操作时，将需要写的物理内存地址空间作复制一份，即写在新的物理地址空间，这样就不会影响原来的地址空间内的数据。即不管父进程还是子进程对其共享的内存中的数据进行修改都不会影响对方的访问，对方仍然访问的是fork是的数据。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>以fork方式生成一个子进程以快照模式保存整个数据集，保存格式是二进制格式。它按照事先定义的策略，周期性地将数据全部保存至磁盘(不是增量)，其数据文件默认为dump.rdb。linux操作系统有<strong>写时复制</strong>机制，父进程和子进程会共享相同的物理页面，当父进程处理写请求时，操作系统为父进程修改的页面创建副本，因此此时子进程快照保存时一定是时间点一致的数据。(RDB时只有父进程写，子进程负责读进行备份)</p><p>客户端也可以显示使用SAVE和BGSAVE命令启动快照保存机制</p><ul><li>SAVE：同步，在主进程中保存快照，此时会阻塞所有客户端请求</li><li>BGSAVE：异步，fork子进程在后台执行，不会阻塞主进程处理请求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RDB配置文件，保存在/etc/redis目录中</span></span><br><span class="line">save<span class="comment">#这里是用来配置触发Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘，格式为save num1 num2表示num1秒内有num2个key发生变化则同步到磁盘，使用的是bgsave机制</span></span><br><span class="line">rdbcompression<span class="comment">#对于存储在磁盘的快照是否压缩存储，默认为yes</span></span><br><span class="line">rdbchecksum<span class="comment">#对于存储的快照是否校验，默认yes</span></span><br><span class="line">dbfilename<span class="comment">#设置快照名称，默认为dump.rdb</span></span><br><span class="line">dir<span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，使用dbfilename作为文件名</span></span><br><span class="line">stop-writes-on-bgsave-error<span class="comment">#当同步磁盘失败时是否停止接收数据，默认为yes</span></span><br></pre></td></tr></table></figure><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append only file，表示将所有写操作都追加到AOF文件的末尾，但是这样可能会因为重复冗余的写操作导致文件过大，因此redis提供合并冗余操作的机制BGREWRITEAOF来优化。例如重复1000次incr命令，这样会导致大量的incr命令附加到AOF文件末尾，这效率极低，而使用BGREWRITEAOF优化后会将重复的写命令以少量的已存在的命令进行替换。这种优化策略根据redis版本分为两种：</p><ul><li>4.0以前：BGREWRITEAOF实际上是对内存中现存的AOF文件进行重写，首先主进程fork一个子进程来处理，它不会读取内存中已存的AOF文件，而是通过将内存中的数据以命令的方式保存到临时文件中，在这个过程中主进程仍然会接收客户端请求，且将这些请求的写操作依然保存于原来的AOF文件中且同时保存在一个缓冲队列中(依旧保存在老的AOF文件中是防止重写AOF失败导致这期间的写操作请求丢失)，子进程重写入临时文件结束后通知父进程，父进程将保存在缓冲队列中的命令追加写入临时文件中，然后父进程用临时文件替换老的AOF文件。</li><li>4.0以后：采取的策略也是重写，它虽然使用BGREWRITEAOF机制来优化但优化机制不一样，新版使用的是RDB和AOF结合的方式。它将老的数据RDB到AOF文件中，将增量的数据以指令的方式追加到AOF中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#AOF配置文件，保存在/etc/redis目录中</span></span><br><span class="line">appendonly<span class="comment">#使用AOF主从方式，默认为no</span></span><br><span class="line">appendfilename<span class="comment">#文件名称</span></span><br><span class="line">appendfsync<span class="comment">#持久策略，no表示不执行fsync，由内核保证数据同步到磁盘(内核缓冲区满后写入磁盘)，可能会丢失一个缓冲区大小的数据(一般位4k)；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</span></span><br><span class="line">auto-aof-rewrite-percentage 100<span class="comment">#表示当前AOF文件已经是上次重写AOF是的二倍，立即触发重写AOF</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment">#表示当前AOF文件大小超过64mb时进行AOF重写操作</span></span><br><span class="line">no-appendfsync-on-rewrite no<span class="comment">#表示是否在重写AOF时将新写操作进行缓存，yes表示缓存</span></span><br><span class="line">aof-use-rdb-preamble yes<span class="comment">#是否使用老数据rdb，新数据AOF的方式进行持久化</span></span><br></pre></td></tr></table></figure><h4 id="AOF文件格式"><a href="#AOF文件格式" class="headerlink" title="AOF文件格式"></a>AOF文件格式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设写一个set k1 hello</span></span><br><span class="line"><span class="string">*2</span></span><br><span class="line"><span class="string">$6</span></span><br><span class="line"><span class="string">SELECT</span></span><br><span class="line"><span class="string">$1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">*3</span></span><br><span class="line"><span class="string">$3</span></span><br><span class="line"><span class="string">set</span></span><br><span class="line"><span class="string">$2</span></span><br><span class="line"><span class="string">k1</span></span><br><span class="line"><span class="string">$5</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">第一行*2表示这一部分有两段，分别是$开头的两个</span></span><br><span class="line"><span class="string">$6表示下一个操作的字符数</span></span><br><span class="line"><span class="string">可以手动删除操作过的序列，没写入磁盘时可以重启redis进行恢复</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果RDB和AOF同时启用，则BGSAVE和BGREWRITEAOF不会同时执行，且在redis服务器启动用于恢复数据时，优先使用AOF。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h3&gt;&lt;p&gt;redis数据全部保存在内存中，因此它处理请求很快，但是为了长久保存这些数据还需要将内存中的数据保存到磁盘中，这就引出持久化概念。需要注意的是，持久化不能取代备份，仍然要指定相关的备份策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="写时复制" scheme="http://yoursite.com/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis(3)-事务、订阅、缓存</title>
    <link href="http://yoursite.com/2020/02/13/Redis-3-%E4%BA%8B%E5%8A%A1%E3%80%81%E8%AE%A2%E9%98%85%E3%80%81%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/02/13/Redis-3-%E4%BA%8B%E5%8A%A1%E3%80%81%E8%AE%A2%E9%98%85%E3%80%81%E7%BC%93%E5%AD%98/</id>
    <published>2020-02-13T14:00:46.000Z</published>
    <updated>2020-02-19T02:12:24.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>redis事务通过Multi、Exec、Watch等命令实现。它只是将一些列命令打包执行，当这些命令没有执行完时不会处理其他命令。不支持回滚操作。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先在redis-cli中执行MULTI命令启动事务</span></span><br><span class="line">MULTI</span><br><span class="line"><span class="comment">#使用MULTI后直接写各个命令即可，注意这些命令没有被执行</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">#执行上述MULTI定义的命令序列，即执行事务，并一次性返回所有操作结果</span></span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">WATCH命令用于在EXEC执行前监视指定的任意数量的键，如果有键发生改变则拒绝执行事务</span><br><span class="line">WATCH命令在MULTI之前使用，且指定键名，如：WATCH IP表示监听名称为IP的键</span><br></pre></td></tr></table></figure><h3 id="消息订阅"><a href="#消息订阅" class="headerlink" title="消息订阅"></a>消息订阅</h3><p>由list实现消息队列，每个list相当于一个channel频道。由list维护消息队列的效率很高，因为list相当于一个链表，在它left和right进行元素的插入和删除的复杂度是常量级别。</p><p>使用subscribe和publish实现消息的订阅和推送，用unsubscribe进行退订，用psubscribe进行模式订阅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订阅名为news的channel</span></span><br><span class="line">subscribe news</span><br><span class="line"></span><br><span class="line"><span class="comment">#另起一个终端进行消息推送，即可在订阅端接收到消息</span></span><br><span class="line">publish news hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#模式订阅，表示订阅了new.io和new.it两个</span></span><br><span class="line">psubscribe new.i[to]</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>redis既可以作数据库也可以作缓存，缓存的数据肯定不是全量的数据库而是一些所谓的热数据，那么如何定义热数据呢？这就引入了key的有效期机制和redis的内存调度机制。</p><h4 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h4><p>在set命令时就可以设置有效期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置key和value</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">set</span></span><br><span class="line">SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">NX：键存在时不能操作，类似于新建</span><br><span class="line">XX：键存在时才能操作，类似于更新</span><br><span class="line">EX seconds：键多少秒后到期，设置存活时间(注意存活时间不会因为访问次数而增加)，如果发生写操作会修改过期时间</span><br></pre></td></tr></table></figure><p>当某个键过期时，redis不会立刻在内存中删除这个数据，这里有两种方式来处理有效期到期的键</p><ul><li>被动方式：当客户端访问时发现ttl到期说明key过期从而删除</li><li>主动方式：redis以轮询方式查询一部分key来检测是否过期</li></ul><h4 id="内存调度"><a href="#内存调度" class="headerlink" title="内存调度"></a>内存调度</h4><p>当redis内存占满了时又不断接收到写操作请求，那么就会引起内存调度，常见的调度方式有：</p><ul><li>noeviction：只返回错误信息，不做key的删除</li><li>LRU：删除最近最少使用的key</li><li>LFU：删除使用次数最少的key</li></ul><h4 id="bloom过滤器"><a href="#bloom过滤器" class="headerlink" title="bloom过滤器"></a>bloom过滤器</h4><p>考虑一种情况，当客户端请求一个key时redis内存中没有，那么这个请求会查询关系型数据库，如果关系型数据库也没有，那么才返回查找失败，这个行为叫做缓存穿透，这会浪费关系型数据库的大量时间消耗。鉴于这种情况提出了bloom过滤器的概念。</p><p>bloom过滤器是一个redis的第三方插件，它实现将关系型数据库中有的数据进行三次hash映射函数的映射，并在内存中维护一个bitmap数组，将每个元素的三次hash值依次存放在对应的bitmap位中。</p><p>在经过上述处理后，假设现在有一个请求到达，这个请求如果没有被redis名字，那么进行hash计算，看看计算的结果有没有与bitmap匹配的结果，如果有说明关系型数据库中有该值，如果没有则说明不匹配，则不查询后端数据库。但这里要考虑一种特殊情况，即假设请求的是关系型数据库不存在的键，但是hash的值却与现存的bitmap重复了(可能一部分是一个键，一部分是另一个键)，那么这种情况也会查询关系型数据库，会造成一定的损耗(出现该情况可以将该key加入到redis中，值设置为空，以防下次穿透)。因此，bloom过滤器是概率性解决问题，但是概率很大且维护bitmap的开销很小，因此性能较好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/RedisBloom/RedisBloom.git</span><br><span class="line"><span class="comment">#编译，编译后出现.so文件，即为redis模块</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#启动时加载，或者在配置文件中loadmodule均可，路径必须是绝对路径</span></span><br><span class="line">redis-server --loadmodule /path/to/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令</span></span><br><span class="line"><span class="comment">#将键foo添加到过滤器newfilter</span></span><br><span class="line">BF.ADD newFilter foo</span><br><span class="line"><span class="comment">#判断键是否存在</span></span><br><span class="line">BF.EXISTS newFilter foo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h3&gt;&lt;p&gt;redis事务通过Multi、Exec、Watch等命令实现。它只是将一些列命令打包执行，当这些命令没有执行完时不会处理其他命令。不支持回滚操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="bloom过滤" scheme="http://yoursite.com/tags/bloom%E8%BF%87%E6%BB%A4/"/>
    
      <category term="缓存穿透" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis(2)-数据类型和常用命令</title>
    <link href="http://yoursite.com/2020/02/12/Redis-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/12/Redis-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-12T06:31:28.000Z</published>
    <updated>2020-02-19T02:12:17.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>redis中存储的是KV键值对，其中key是一个对象，其内存储与value类型有关。</p><p>value是有类型的值，包括string、hash、list、set等。</p><a id="more"></a><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查key对应值的数据类型</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">type</span></span><br><span class="line">TYPE key</span><br></pre></td></tr></table></figure><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取redis对象的信息</span></span><br><span class="line"><span class="built_in">help</span> object</span><br><span class="line">OBJECT subcommand [arguments [arguments ...]]</span><br><span class="line">[subcommand]</span><br><span class="line">encoding：查看key对应value的编码格式</span><br></pre></td></tr></table></figure><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#情空所有key</span></span><br><span class="line"><span class="built_in">help</span> flushall</span><br><span class="line">FLUSHALL [ASYNC]</span><br></pre></td></tr></table></figure><h4 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清空当前db的所有key</span></span><br><span class="line"><span class="built_in">help</span> flushdb</span><br><span class="line">FLUSHDB [ASYNC]</span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取匹配pattern的所有key</span></span><br><span class="line"><span class="built_in">help</span> keys</span><br><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换数据库</span></span><br><span class="line"><span class="built_in">help</span> select</span><br><span class="line">SELECT INDEX</span><br></pre></td></tr></table></figure><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重命名key</span></span><br><span class="line"><span class="built_in">help</span> rename</span><br><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure><h4 id="ttl"><a href="#ttl" class="headerlink" title="ttl"></a>ttl</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以秒为单位返回指定key剩余生存时间</span></span><br><span class="line"><span class="built_in">help</span> ttl</span><br><span class="line">TTL key</span><br></pre></td></tr></table></figure><h4 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给指定key设置生存时间</span></span><br><span class="line"><span class="built_in">help</span> expire</span><br><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><h4 id="expireat"><a href="#expireat" class="headerlink" title="expireat"></a>expireat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在指定时间过期</span></span><br><span class="line"><span class="built_in">help</span> expireat</span><br><span class="line">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure><h4 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除指定key的生存时间</span></span><br><span class="line"><span class="built_in">help</span> persist</span><br><span class="line">PERSIST key</span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除给定的key</span></span><br><span class="line"><span class="built_in">help</span> del</span><br><span class="line">DEL key [key ...]</span><br></pre></td></tr></table></figure><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">help</span> exists</span><br><span class="line">EXISTS key [key ...]</span><br></pre></td></tr></table></figure><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前数据库的指定key转移到指定数据库中</span></span><br><span class="line"><span class="built_in">help</span> move</span><br><span class="line">MOVE key db</span><br></pre></td></tr></table></figure><h4 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从当前数据库随机返回一个key，不删除</span></span><br><span class="line"><span class="built_in">help</span> randomkey</span><br><span class="line">RANDOMKEY -</span><br></pre></td></tr></table></figure><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><h4 id="client-getname"><a href="#client-getname" class="headerlink" title="client getname"></a>client getname</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前连接名称</span></span><br><span class="line"><span class="built_in">help</span> client getname</span><br><span class="line">CLIENT GETNAME</span><br></pre></td></tr></table></figure><h4 id="client-setname"><a href="#client-setname" class="headerlink" title="client setname"></a>client setname</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置当前连接的名称</span></span><br><span class="line"><span class="built_in">help</span> client setname</span><br><span class="line">CLIENT SETNAME</span><br></pre></td></tr></table></figure><h4 id="client-kill"><a href="#client-kill" class="headerlink" title="client kill"></a>client kill</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#杀死指定连接的客户端</span></span><br><span class="line"><span class="built_in">help</span> clent <span class="built_in">kill</span></span><br><span class="line">CLIENT KILL ip:port</span><br></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前服务器信息</span></span><br><span class="line"><span class="built_in">help</span> info</span><br><span class="line">INFO [section]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">section可以查看指定段的状态信息</span><br></pre></td></tr></table></figure><h4 id="config-resetstat"><a href="#config-resetstat" class="headerlink" title="config resetstat"></a>config resetstat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重置info统计的数据</span></span><br><span class="line"><span class="built_in">help</span> config resetstat</span><br><span class="line">CONFIG RESETSTAT</span><br></pre></td></tr></table></figure><h4 id="config-get"><a href="#config-get" class="headerlink" title="config get"></a>config get</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取配置文件各个属性</span></span><br><span class="line"><span class="built_in">help</span> config get</span><br><span class="line">CONFIG GET parameter</span><br></pre></td></tr></table></figure><h4 id="config-set"><a href="#config-set" class="headerlink" title="config set"></a>config set</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置redis配置文件参数</span></span><br><span class="line"><span class="built_in">help</span> config <span class="built_in">set</span></span><br><span class="line">CONFIG SET parameter value</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">上述修改方式只是在内存中修改，不会写入到内存中</span><br></pre></td></tr></table></figure><h4 id="config-rewrite"><a href="#config-rewrite" class="headerlink" title="config rewrite"></a>config rewrite</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将config set修改的配置信息写入磁盘中的配置文件中</span></span><br><span class="line"><span class="built_in">help</span> config rewrite</span><br><span class="line">CONFIG REWRITE</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同步内存到磁盘</span></span><br><span class="line"><span class="built_in">help</span> save</span><br><span class="line">SAVE</span><br></pre></td></tr></table></figure><h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异步方式重写AOF文件</span></span><br><span class="line"><span class="built_in">help</span> bgrewriteaof</span><br><span class="line">BGREWRITEAOF</span><br></pre></td></tr></table></figure><h4 id="lastsave"><a href="#lastsave" class="headerlink" title="lastsave"></a>lastsave</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取最后一次保存磁盘的时间戳</span></span><br><span class="line"><span class="built_in">help</span> lastsave</span><br><span class="line">LASTSAVE</span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同步数据到磁盘后关闭服务</span></span><br><span class="line"><span class="built_in">help</span> shutdown</span><br><span class="line">SHUTDOWN [NOSAVE|SAVE]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">nosave表示不启用安全检查</span><br><span class="line">save表示启用安全检查</span><br></pre></td></tr></table></figure><h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#监听服务器上所有的请求</span></span><br><span class="line"><span class="built_in">help</span> monitor</span><br><span class="line">MONITOR</span><br></pre></td></tr></table></figure><h4 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a>slaveof</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置主从</span></span><br><span class="line"><span class="built_in">help</span> slaveof</span><br><span class="line">SLAVEOF host port</span><br></pre></td></tr></table></figure><h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主从节点同步</span></span><br><span class="line"><span class="built_in">help</span> sync</span><br><span class="line">SYNC</span><br></pre></td></tr></table></figure><h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><h4 id="multi"><a href="#multi" class="headerlink" title="multi"></a>multi</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标记开启事务，后续输入的命令加入缓冲队列</span></span><br><span class="line"><span class="built_in">help</span> multi</span><br><span class="line">MULTI</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标记事务开始执行，执行事务定义的一系列命令</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">exec</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h4 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#丢弃multi定义的所有命令</span></span><br><span class="line"><span class="built_in">help</span> discard</span><br><span class="line">DISCARD</span><br></pre></td></tr></table></figure><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于multi之前，如果监控的key发生变化则事务不执行</span></span><br><span class="line"><span class="built_in">help</span> watch</span><br><span class="line">WATCH key [key ...]</span><br></pre></td></tr></table></figure><h4 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取消所有监控的值</span></span><br><span class="line"><span class="built_in">help</span> unwatch</span><br><span class="line">UNWATCH</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string数据类型具体编码格式分为字符串、bitmap、数值。它是二进制安全的，即redis与socket交互时使用的是字节流而不是字符流。因为不同编程语言对字符流的理解不同(长度等)，可能会出现截断溢出等，而字节流只需要收发双发能够编码与解码即可。</p><p>value为String类型的key，key中存储有type、encoding、length等对应value的属性，存储type是为了快速判断对value的操作是否合法，length等属性也是为了加速操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看string类型所有操作，本篇文章所有操作都在redis-cli中运行</span></span><br><span class="line"><span class="built_in">help</span> @string</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置key和value</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">set</span></span><br><span class="line">SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">NX：键存在时不能操作，类似于新建</span><br><span class="line">XX：键存在时才能操作，类似于更新</span><br><span class="line">EX seconds：键多少秒后到期，设置存活时间(注意存活时间不会因为访问次数而增加)，如果发生写操作会修改过期时间</span><br></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取对应key的value</span></span><br><span class="line"><span class="built_in">help</span> get</span><br><span class="line">GET key</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">value不存在时返回nil</span><br><span class="line">key存储的不是字符串时返回错误，get只能获取字符串</span><br></pre></td></tr></table></figure><h5 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时设置多个key的value</span></span><br><span class="line"><span class="built_in">help</span> mset</span><br><span class="line">MSET key value [key value ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">mset是一个原子操作，不存在部分更新</span><br></pre></td></tr></table></figure><h5 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时获取多个key的value</span></span><br><span class="line"><span class="built_in">help</span> mget</span><br><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure><h5 id="msetnx"><a href="#msetnx" class="headerlink" title="msetnx"></a>msetnx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key存在时更新，原子操作</span></span><br><span class="line"><span class="built_in">help</span> msetnx</span><br><span class="line">MSETNX key value [key value ...]</span><br></pre></td></tr></table></figure><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#追加字符串</span></span><br><span class="line"><span class="built_in">help</span> append</span><br><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><h5 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定范围的字符串</span></span><br><span class="line"><span class="built_in">help</span> getrange</span><br><span class="line">GETRANGE key [start end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">给定字符串例如<span class="string">"Hello"</span>，它存在正向索引和反向索引。正向索引是从左到右0、1...反向索引是从右到左-1、-2...</span><br></pre></td></tr></table></figure><h5 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置某个范围的值</span></span><br><span class="line"><span class="built_in">help</span> setrange</span><br><span class="line">SETRANGE key offset value</span><br></pre></td></tr></table></figure><h5 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取字符串长度，包括空格</span></span><br><span class="line"><span class="built_in">help</span> strlen</span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><h5 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改key值为给出的value，并返回旧的value值，可以减少依次网络io</span></span><br><span class="line"><span class="built_in">help</span> getset</span><br><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><h5 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key值加1</span></span><br><span class="line"><span class="built_in">help</span> incr</span><br><span class="line">INCR key</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">key不存在时初始为0后加1</span><br><span class="line">范围为64位有符号数</span><br></pre></td></tr></table></figure><h5 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key值减1</span></span><br><span class="line"><span class="built_in">help</span> decr</span><br><span class="line">DECR key</span><br></pre></td></tr></table></figure><h5 id="incrby"><a href="#incrby" class="headerlink" title="incrby"></a>incrby</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加指定数值</span></span><br><span class="line"><span class="built_in">help</span> incrby</span><br><span class="line">INCRBY key increment</span><br></pre></td></tr></table></figure><h5 id="decrby"><a href="#decrby" class="headerlink" title="decrby"></a>decrby</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#减少指定数值</span></span><br><span class="line"><span class="built_in">help</span> decrby</span><br><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><h5 id="incrbyfloat"><a href="#incrbyfloat" class="headerlink" title="incrbyfloat"></a>incrbyfloat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加浮点数</span></span><br><span class="line"><span class="built_in">help</span> incrbyfloat</span><br><span class="line">INCRBYFLOAT key increment</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">increment为正表示增加</span><br><span class="line">increment为负表示减少</span><br></pre></td></tr></table></figure><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><h5 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置对应二进制偏移的值</span></span><br><span class="line"><span class="built_in">help</span> setbit</span><br><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><h5 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找bit第一次出现的位置</span></span><br><span class="line"><span class="built_in">help</span> bitpos</span><br><span class="line">BITPOS key bit [start] [end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">[start]和[end]表示字符序号，返回值为出现给定bit的字节序号</span><br></pre></td></tr></table></figure><h5 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计指定bit出现次数</span></span><br><span class="line"><span class="built_in">help</span> bitcount</span><br><span class="line">BITCOUNT key [start end]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">[start]和[end]表示字符序号</span><br></pre></td></tr></table></figure><h5 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位操作</span></span><br><span class="line"><span class="built_in">help</span> bitop</span><br><span class="line">BITOP operation destkey key [key ...]</span><br><span class="line">and：与操作</span><br><span class="line">or：或操作</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>list类型的value对应的key对象存储着value链表的head和tail指针，key也存储value类型type为list。</p><p>list可以实现栈、队列、数组、阻塞单播队列</p><h4 id="lpush"><a href="#lpush" class="headerlink" title="lpush"></a>lpush</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从链表左端放入值</span></span><br><span class="line"><span class="built_in">help</span> lpush</span><br><span class="line">LPUSH key value [value ...]</span><br></pre></td></tr></table></figure><h4 id="rpush"><a href="#rpush" class="headerlink" title="rpush"></a>rpush</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从链表右边放入值</span></span><br><span class="line"><span class="built_in">help</span> rpush</span><br><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure><h4 id="lpop"><a href="#lpop" class="headerlink" title="lpop"></a>lpop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#左侧出第一个值</span></span><br><span class="line"><span class="built_in">help</span> lpop</span><br><span class="line">LPOP key</span><br></pre></td></tr></table></figure><h4 id="lrange"><a href="#lrange" class="headerlink" title="lrange"></a>lrange</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取list链表start开始stop结束的值，正反索引都可以</span></span><br><span class="line"><span class="built_in">help</span> lrange</span><br><span class="line">LRANGE key [start] [stop]</span><br></pre></td></tr></table></figure><h4 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定下标的值</span></span><br><span class="line"><span class="built_in">help</span> lindex</span><br><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><h4 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置指定index的value</span></span><br><span class="line"><span class="built_in">help</span> lset</span><br><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><h4 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从指定pivot前或后插入指定value，pivot是存在的元素值，不是索引</span></span><br><span class="line"><span class="built_in">help</span> linsert</span><br><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">如果pivot存在多个，只在第一个匹配处操作</span><br></pre></td></tr></table></figure><h4 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除list链表中指定个数的指定value</span></span><br><span class="line"><span class="built_in">help</span> lrem</span><br><span class="line">LREM key count value</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数时表示下标从0开始从前往后匹配</span><br><span class="line">count为负数时表示下标从-1开始从后往前匹配</span><br></pre></td></tr></table></figure><h4 id="llen"><a href="#llen" class="headerlink" title="llen"></a>llen</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取list链表长度</span></span><br><span class="line"><span class="built_in">help</span> llen</span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure><h4 id="blpop"><a href="#blpop" class="headerlink" title="blpop"></a>blpop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阻塞式获取左侧第一个list的值</span></span><br><span class="line"><span class="built_in">help</span> blpop</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若有多个客户端对同一个key进行blpop，那么会按照阻塞队列顺序进行获取值(先来后到)</span><br></pre></td></tr></table></figure><h4 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对给定start和stop的两端数据进行删除</span></span><br><span class="line"><span class="built_in">help</span> ltrim</span><br><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>表示value的类型为hash键值对，即KV类型的值中V的值本身又是一个hash键值对。</p><h4 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置一个键值对</span></span><br><span class="line"><span class="built_in">help</span> hset</span><br><span class="line">HSET key field value</span><br></pre></td></tr></table></figure><h4 id="hget"><a href="#hget" class="headerlink" title="hget"></a>hget</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取一个键值对</span></span><br><span class="line"><span class="built_in">help</span> hget</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><h4 id="hemset"><a href="#hemset" class="headerlink" title="hemset"></a>hemset</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置多个键值对</span></span><br><span class="line"><span class="built_in">help</span> hmset</span><br><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure><h4 id="hmget"><a href="#hmget" class="headerlink" title="hmget"></a>hmget</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取多个键值对</span></span><br><span class="line"><span class="built_in">help</span> hmget</span><br><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><h4 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有"键"</span></span><br><span class="line"><span class="built_in">help</span> hkeys</span><br><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><h4 id="hvals"><a href="#hvals" class="headerlink" title="hvals"></a>hvals</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有"值"</span></span><br><span class="line"><span class="built_in">help</span> hvals</span><br><span class="line">HVALS key</span><br></pre></td></tr></table></figure><h4 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定key的所有键值对，一键一值显示</span></span><br><span class="line"><span class="built_in">help</span> hgetall</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><h4 id="hincrbyfloat"><a href="#hincrbyfloat" class="headerlink" title="hincrbyfloat"></a>hincrbyfloat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#浮点数增加</span></span><br><span class="line"><span class="built_in">help</span> hincrbyfloat</span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">increment为正表示增加</span><br><span class="line">increment为负表示减少</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>可以理解为去重的list，但是list是有序的(存储顺序，不是排序)，而set是<strong>无序</strong>的。元素类型为string。</p><h4 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member加入到key中</span></span><br><span class="line"><span class="built_in">help</span> sadd</span><br><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定的key的所有成员</span></span><br><span class="line"><span class="built_in">help</span> smembers</span><br><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><h4 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取指定集合的交集</span></span><br><span class="line"><span class="built_in">help</span> sinter</span><br><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#和sinter类似，它是将交集存到指定集合中</span></span><br><span class="line"><span class="built_in">help</span> sinterstore</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回多个集合的并集</span></span><br><span class="line"><span class="built_in">help</span> sunio</span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sunionstore"><a href="#sunionstore" class="headerlink" title="sunionstore"></a>sunionstore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#和sunion类似，它是将并集存到指定集合中</span></span><br><span class="line"><span class="built_in">help</span> sunionstore</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><h4 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断指定key中是否存在指定member</span></span><br><span class="line"><span class="built_in">help</span> sismember</span><br><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><h4 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回key对应的集合中的元素数量</span></span><br><span class="line"><span class="built_in">help</span> scard</span><br><span class="line">SCARD key</span><br></pre></td></tr></table></figure><h4 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将member元素从source集合移动到destination集合中</span></span><br><span class="line"><span class="built_in">help</span> smove</span><br><span class="line">SMOVE <span class="built_in">source</span> destination member</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若destination集合中已包含了<span class="built_in">source</span>要移动的元素则单纯的删除<span class="built_in">source</span>集合中的待移动元素</span><br></pre></td></tr></table></figure><h4 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除并返回集合中的count个随机元素，如果count不指定那么随机返回一个元素</span></span><br><span class="line"><span class="built_in">help</span> spop</span><br><span class="line">SPOP key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数且小于集合大小时返回指定数量的随机元素(各不相同)</span><br><span class="line">count为正数但大于集合大小时返回全部集合元素</span><br><span class="line">count为负数则返回其绝对值个数个随机元素(元素可能重复)</span><br></pre></td></tr></table></figure><h4 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除指定集合的一个或多个集合</span></span><br><span class="line"><span class="built_in">help</span> srem</span><br><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合内的count个随机元素</span></span><br><span class="line"><span class="built_in">help</span> srandmember</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">count为正数且小于集合大小时返回指定数量的随机元素(各不相同)</span><br><span class="line">count为正数但大于集合大小时返回全部集合元素</span><br><span class="line">count为负数则返回其绝对值个数个随机元素(元素可能重复)</span><br></pre></td></tr></table></figure><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>它和set一样都是集合，但是它是string类型<strong>有序</strong>集合。</p><h4 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member及其socre添加到set中</span></span><br><span class="line"><span class="built_in">help</span> zadd</span><br><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">NX：键存在时不能操作，类似于新建</span><br><span class="line">XX：键存在时才能操作，类似于更新</span><br></pre></td></tr></table></figure><h4 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回集合中元素个数</span></span><br><span class="line"><span class="built_in">help</span> zcard</span><br><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><h4 id="zcount"><a href="#zcount" class="headerlink" title="zcount"></a>zcount</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合中score值在min和max之间的member</span></span><br><span class="line"><span class="built_in">help</span> zcount</span><br><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><h4 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回指定集合中区间内的成员，按score从小到大排序</span></span><br><span class="line"><span class="built_in">help</span> zrange</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若score相同则按字典顺序排列</span><br><span class="line">若想要从大到小排列则使用zrevrange</span><br><span class="line">下标支持正反索引</span><br><span class="line">WITHSCORES表示member和score一并返回</span><br></pre></td></tr></table></figure><h4 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回有序集合中member的排名，从0开始，且score从小到大</span></span><br><span class="line"><span class="built_in">help</span> zrank</span><br><span class="line">ZRANK key member</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">若想要从大到小排列则使用zrevrank</span><br></pre></td></tr></table></figure><h4 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除一个或多个member</span></span><br><span class="line"><span class="built_in">help</span> zrem</span><br><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><h4 id="zremrangebyrank"><a href="#zremrangebyrank" class="headerlink" title="zremrangebyrank"></a>zremrangebyrank</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除有序集合中指定区间内的所有成员</span></span><br><span class="line"><span class="built_in">help</span> zremrangebyrank</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><h4 id="zremrangebyscore"><a href="#zremrangebyscore" class="headerlink" title="zremrangebyscore"></a>zremrangebyscore</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除有序集合中score值在指定范围的member</span></span><br><span class="line"><span class="built_in">help</span> zremrangebyscore</span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;redis中存储的是KV键值对，其中key是一个对象，其内存储与value类型有关。&lt;/p&gt;
&lt;p&gt;value是有类型的值，包括string、hash、list、set等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis(1)-基本原理和安装配置</title>
    <link href="http://yoursite.com/2020/02/11/Redis-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/02/11/Redis-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-11T09:34:30.000Z</published>
    <updated>2020-02-19T02:12:13.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Redis是一个KV型存储引擎，为了提高效率，它的所有工作都在内存中实现(可以做缓存)，但为了持久存储也会在磁盘上做冗余。它用作数据结构服务器，即存储例如String、list、Hash、Set、Bitmap等类型的数据。</p><p>Redis工作在单线程单进程单实例模式，它通过内核的epoll系统调用来处理多路并行请求。</p><a id="more"></a><h4 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h4><p>早期的内核程序处理多路请求时使用read系统调用来处理，用户空间的进程如果没有读取到对应的文件描述符fd就会一直阻塞，从而妨碍其他进程处理请求。这就是初期的BIO阻塞模型。</p><p>随后为了解决阻塞问题，提出了同步非阻塞的NIO模型。它支持单进程在用户空间通过轮询的方式处理多个并发请求，这样就不会阻塞(多个进程会阻塞，这里就使用单进程轮询处理)。</p><p>NIO又引出新的问题，即如果请求量很大那么进程将频繁的在用户空间和内核空间进行切换(之所以不停切换是用户空间进程不知道哪些fd已经准备好需要被使用)，会消耗大量CPU资源。为了解决这个问题，内核进行了修改，出现了新的系统调用select。select实现了将多个可以使用的fd同时从内核发送给用户空间进程，由用户空间进程遍历选择依次进行read系统调用读取该连接，这样就大大减少了进程切换的开销。</p><p>上述select方法已经很大程度上减少了资源消耗，但是仍然需要将fd相关数据从内核态内存拷贝到用户空间进程的内存空间，以及select并不知道哪个fd是有数据状态，它自身也需要不断遍历来选择，有没有办法减少这种开销呢？这就引出了epoll机制。它实际上是使用mmap系统调用将用户空间的一块内存和内核空间的一块内存作为共享内存空间，其内维护着数据结构(红黑树和双向链表)，其中红黑树用于管理哪些fd需要被监视，双向链表实现队列。其中双向链表由内核维护，当进程在等待fd时，会创建了一个epoll对象(epoll对象本身也是文件系统资源，也拥有自己的等待队列)并且该epoll对象会被添加到fd等待队列中(如果是多个fd就将epoll放到每个fd等待队列中)。当某个进程调用epoll_wait等待时，内核将该进程添加到epoll对象的等待队列中，当某个fd收到数据时中断程序会修改epoll的双向链表(就绪队列)，添加fd引用并且唤醒阻塞的进程，从而该进程再次得到CPU调用且根据双向链表知道是哪个fd有数据。</p><p>epoll是三个系统调用：</p><ul><li><p>epoll_create：用户创建epoll对象，该对象的成员包括内核维护的双向链表</p></li><li><p>epoll_wait：用于epoll对象等待数据</p></li><li><p>epoll_cli：用于给epoll对象添加需要监控的fd，将fd添加到红黑树上</p></li></ul><h4 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h4><p>redis持久存储主要有两种方式：快照和AOF</p><ul><li>snapshotting：快照，数据异步从内存传输到磁盘</li><li>AOF：即将每次的写操作附加在一个文件后面写入磁盘，类似于mysql的事务日志</li></ul><h4 id="NoSql特性"><a href="#NoSql特性" class="headerlink" title="NoSql特性"></a>NoSql特性</h4><p>Redis属于NoSql存储，NoSql存储主要分为四种：KV键值型、Column列式存储、Documentation文档存储、Graph图表存储</p><h4 id="与memcached区别"><a href="#与memcached区别" class="headerlink" title="与memcached区别"></a>与memcached区别</h4><p>memcached也是KV键值对的NoSql型数据库系统，他们都工作在内存中，一个重要的区别是memcached的value是没有数据类型的，而Redis的value是有数据类型的。memcached存储时将所有键值对都获取然后客户端通过程序解码(解析json格式数据)进行特定数据获取，而Redis由于有数据类型且提供了每种类型特定的获取方法(index、lpop等)，因此可以直接获取对应数据，不需要加载全部数据，换句话说所有的计算都是在server端实现不需要客户端额外的解码等消耗，因此大大提高了效率。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#官网http://download.redis.io/releases/redis-5.0.7.tar.gz，此处使用编译安装</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar xf redis-5.0.7.tar.gz</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#安装，将可执行文件迁移</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment">#服务安装，切换至util目录下进行，全部默认即可</span></span><br><span class="line">./install_server.sh</span><br><span class="line"><span class="comment">#启动，名字后面为端口号，根据不同端口进行修改</span></span><br><span class="line">systemctl start redis_6379</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，如果make失败产生垃圾需要清除，具体命令以README.md为准</span></span><br><span class="line">make distclean</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">redis根据监听端口号不同区分不同的服务</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>redis配置文件根据不同的端口号命名不同，通常以xxxx.conf(其中xxxx为端口号)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">loadmoudle<span class="comment">#加载自定义模块</span></span><br><span class="line"><span class="built_in">bind</span><span class="comment">#redis服务允许访问的地址</span></span><br><span class="line">port<span class="comment">#redis服务运行端口，默认为6379</span></span><br><span class="line">timeout<span class="comment">#客户端连接超时时长，即多久没有操作则关闭连接，0表示不设置时长</span></span><br><span class="line">tcp-keepalive<span class="comment">#周期性检测客户端监控状态，同样0表示不检测</span></span><br><span class="line">protected-mode<span class="comment">#是否开启保护模式，即是否允许客户端连接，默认为yes</span></span><br><span class="line">tcp-backlog<span class="comment">#tcp等待队列长度满后，找其他地方存储请求</span></span><br><span class="line">daemonize<span class="comment">#redis是否运行为守护进程</span></span><br><span class="line">pidfile<span class="comment">#配置PID文件路径</span></span><br><span class="line">loglevel<span class="comment">#定义日志级别debug(开发测试)、verbose、notice(生产环境)、warning，默认为notice</span></span><br><span class="line">logfile<span class="comment">#配置log文件地址,默认打印在命令行终端的窗口上</span></span><br><span class="line">databases<span class="comment">#设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select &lt;dbid&gt;命令选择一个不同的数据库，dbid是一个介于0到databases-1之间的数值。默认值是16，也就是说默认Redis有16个数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内存相关</span></span><br><span class="line">maxmemory<span class="comment">#允许使用的最大内存大小，一般限制在1-10G</span></span><br><span class="line">maxmemory-policy<span class="comment">#内存回收策略，一般有noeviction只返回错误，释放任何键(仅当redis作数据库时设置)；LRU最近最少使用的释放；ttl将设置了ttl的且存活时间较短的键释放；random随机释放；LFU：使用次数最少的释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RDB持久存储相关</span></span><br><span class="line">save<span class="comment">#这里是用来配置触发Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘，格式为save num1 num2表示num1秒内有num2个key发生变化则同步到磁盘</span></span><br><span class="line">rdbcompression<span class="comment">#对于存储在磁盘的快照是否压缩存储，默认为yes</span></span><br><span class="line">rdbchecksum<span class="comment">#对于存储的快照是否校验，默认yes</span></span><br><span class="line">dbfilename<span class="comment">#设置快照名称，默认为dump.rdb</span></span><br><span class="line">dir<span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，使用dbfilename作为文件名</span></span><br><span class="line">stop-writes-on-bgsave-error<span class="comment">#当同步磁盘失败时是否停止接收数据，默认为yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主从复制相关</span></span><br><span class="line">replica-serve-stale-data<span class="comment">#主从复制时如何处理客户端请求，默认yes表示正常应答(会有过时数据)，no表示拒绝并返回错误提示</span></span><br><span class="line">replica-read-only<span class="comment">#从节点是否处理请求，默认为yes</span></span><br><span class="line">repl-diskless-sync<span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line">repl-diskless-sync-delay<span class="comment">#当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能只需将它设置为0秒，传送会立即启动。默认值为5。</span></span><br><span class="line">repl-disable-tcp-nodelay<span class="comment">#默认值为no。yes表示redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。</span></span><br><span class="line">slave-priority 100<span class="comment">#指明slave的优先级，数字越小优先级越低</span></span><br><span class="line">min-slaves-to-write 3<span class="comment">#如果slave服务器小于3个，master服务器就拒绝写请求</span></span><br><span class="line">min-slaves-max-lag 10<span class="comment">#slave服务器不能滞后于master10s以上，否则master拒绝写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#AOF主从相关</span></span><br><span class="line">appendonly<span class="comment">#使用AOF主从方式，默认为no</span></span><br><span class="line">appendfilename<span class="comment">#文件名称</span></span><br><span class="line">appendfsync<span class="comment">#持久策略，no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</span></span><br><span class="line">auto-aof-rewrite-percentage 100<span class="comment">#表示当前AOF文件已经是上次重写AOF是的二倍，立即触发重写AOF</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment">#表示当前AOF文件大小超过64mb时进行AOF重写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#集群相关</span></span><br><span class="line">cluster-enabled<span class="comment">#是否开启集群，默认为no</span></span><br><span class="line">cluster-config-file<span class="comment">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息</span></span><br><span class="line">cluster-node-timeout<span class="comment">#节点互连超时的阀值，集群节点超时毫秒数</span></span><br><span class="line">cluster-slave-validity-factor<span class="comment">#可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period。如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</span></span><br><span class="line">cluster-migration-barrier<span class="comment">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2个可工作的从节点时，它的一个从节点会尝试迁移。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;Redis是一个KV型存储引擎，为了提高效率，它的所有工作都在内存中实现(可以做缓存)，但为了持久存储也会在磁盘上做冗余。它用作数据结构服务器，即存储例如String、list、Hash、Set、Bitmap等类型的数据。&lt;/p&gt;
&lt;p&gt;Redis工作在单线程单进程单实例模式，它通过内核的epoll系统调用来处理多路并行请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="epoll" scheme="http://yoursite.com/tags/epoll/"/>
    
      <category term="多路复用" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>k8s(9)-helm程序包管理</title>
    <link href="http://yoursite.com/2020/02/10/k8s-9-helm%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/10/k8s-9-helm%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-10T06:05:12.000Z</published>
    <updated>2020-02-19T02:12:05.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为了解决各个服务安装pod时的依赖以及资源文件修改编写等问题从而提出helm。helm和yum类似，可以理解为包管理工具。</p><a id="more"></a><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>chart：一个helm程序包，是创建一个应用的信息集合，包含各种Kubernetes对象的配置模板、参数定义、依赖关系、文档说明等。可以将Chart比喻为yum中的软件安装包；char包括参数模板和值模板，因此可以自定义对其进行修改。</p></li><li><p>Repository：Charts仓库，本质是一个http服务器，用于集中存储和分发Charts；</p></li><li><p>Config：应用程序实例化安装运行时所需要的配置信息；就是chart模板的值文件</p></li><li><p>Release：特定的Chart部署于目标集群上的一个实例，代表这一个正在运行的应用。当chart被安装到Kubernetes集群，就会生成一个release，chart可以多次安装到同一个集群，每次安装都是一个release。</p></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li>helm：客户端，实现管理本地的Chart仓库，可管理Chart，与Tiller服务进行交互，用于发送Chart，实例安装、查询、卸载等操作。</li><li>Tiller：服务端，通常运行在K8S集群之上。用于接收helm发来的Charts和Conifg，合并生成release，完成部署。</li></ul><p>Helm把Kubernetes资源(比如deployments、services或 ingress等) 打包到一个chart中，而chart被保存到chart仓库，通过chart仓库可用来存储和分享chart。在k8s集群上想要创建pod必须通过APIServer，因此helm客户端将创建请求以及需要的文件发往Tiller服务端，由其向APIServer交互实现pod的创建。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="部署helm"><a href="#部署helm" class="headerlink" title="部署helm"></a>部署helm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载https://github.com/helm/helm/releases编译好的版本，此处使用2.11版本</span></span><br><span class="line">wget https://get.helm.sh/helm-v2.11.0-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#解压出linux-amd64文件</span></span><br><span class="line">tar xf helm-v2.11.0-linux-amd64.tar.gz</span><br><span class="line"><span class="comment">#将二进制文件复制到/usr/bin下直接命令行运行</span></span><br><span class="line"><span class="built_in">cd</span> </span><br><span class="line">mv helm /usr/bin</span><br><span class="line">mv tiller /usr/bin</span><br></pre></td></tr></table></figure><h4 id="部署Tiller"><a href="#部署Tiller" class="headerlink" title="部署Tiller"></a>部署Tiller</h4><p>3.0之后的helm部署时就没有这一步了，此处使用2.11部署。</p><p>部署Tiller就是执行helm的init指令。helm第一次init时，需要APIServer进行创建部署pod，因此需要链接api-server并进行认证，所以在运行helm时，会去读取kube-config文件，所以必须确认当前用户存在kube-config文件。</p><p>Tiller运行在K8s集群之上，也必须拥有集群的管理权限，也就是需要一个serviceaccount，进行一个clusterrolebinding到cluster-admin。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建rbac</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化，使用阿里云镜像，初始化之后会在kube-system中创建pod</span></span><br><span class="line"><span class="string">helm</span> <span class="string">init</span> <span class="string">--service-account</span> <span class="string">tiller</span> <span class="string">--upgrade</span> <span class="string">-i</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.11.0</span> <span class="string">--stable-repo-url</span> <span class="string">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否安装完成，正确的话可以看到helm和tiller的版本</span></span><br><span class="line"><span class="string">helm</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">helm常用命令：</span><br><span class="line">search:    <span class="comment">#搜索charts</span></span><br><span class="line">fetch:     <span class="comment">#下载charts到本地目录</span></span><br><span class="line">install:   <span class="comment">#安装charts</span></span><br><span class="line">list:      <span class="comment">#列出charts的所有版本</span></span><br><span class="line">repo list: <span class="comment">#列出仓库</span></span><br><span class="line">repo add:  <span class="comment">#添加仓库</span></span><br><span class="line"></span><br><span class="line">用法:</span><br><span class="line">  helm [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line">命令可用选项:</span><br><span class="line">  completion  <span class="comment">#为指定的shell生成自动补全脚本（bash或zsh）</span></span><br><span class="line">  create      <span class="comment">#创建一个新的charts</span></span><br><span class="line">  delete      <span class="comment">#删除指定版本的release</span></span><br><span class="line">  dependency  <span class="comment">#管理charts的依赖</span></span><br><span class="line">  fetch       <span class="comment">#下载charts并解压到本地目录</span></span><br><span class="line">  get         <span class="comment">#下载一个release</span></span><br><span class="line">  <span class="built_in">history</span>     <span class="comment">#release历史信息</span></span><br><span class="line">  home        <span class="comment">#显示helm的家目录</span></span><br><span class="line">  init        <span class="comment">#在客户端和服务端初始化helm</span></span><br><span class="line">  inspect     <span class="comment">#查看charts的详细信息</span></span><br><span class="line">  install     <span class="comment">#安装charts</span></span><br><span class="line">  lint        <span class="comment">#检测包的存在问题</span></span><br><span class="line">  list        <span class="comment">#列出release</span></span><br><span class="line">  package     <span class="comment">#将chart目录进行打包</span></span><br><span class="line">  plugin      <span class="comment">#add(增加), list（列出）, or remove（移除） Helm 插件</span></span><br><span class="line">  repo        <span class="comment">#add(增加), list（列出）, remove（移除）, update（更新）, and index（索引） chart仓库</span></span><br><span class="line">  reset       <span class="comment">#卸载tiller</span></span><br><span class="line">  rollback    <span class="comment">#release版本回滚</span></span><br><span class="line">  search      <span class="comment">#关键字搜索chart</span></span><br><span class="line">  serve       <span class="comment">#启动一个本地的http server</span></span><br><span class="line">  status      <span class="comment">#查看release状态信息</span></span><br><span class="line">  template    <span class="comment">#本地模板</span></span><br><span class="line">  <span class="built_in">test</span>        <span class="comment">#release测试</span></span><br><span class="line">  upgrade     <span class="comment">#release更新</span></span><br><span class="line">  verify      <span class="comment">#验证chart的签名和有效期</span></span><br><span class="line">  version     <span class="comment">#打印客户端和服务端的版本信息</span></span><br></pre></td></tr></table></figure><h3 id="chart"><a href="#chart" class="headerlink" title="chart"></a>chart</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>下载下来的chart放在/root/.helm/cache/archive下，为压缩文件。其内部由多个yaml文件组成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看jenkins打包目录</span></span><br><span class="line">[root@localhost archive]@ tree jenkins</span><br><span class="line">jenkins</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── OWNERS</span><br><span class="line">├── README.md</span><br><span class="line">├── templates</span><br><span class="line">│   ├── config.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── home-pvc.yaml</span><br><span class="line">│   ├── jenkins-agent-svc.yaml</span><br><span class="line">│   ├── jenkins-master-deployment.yaml</span><br><span class="line">│   ├── jenkins-master-ingress.yaml</span><br><span class="line">│   ├── jenkins-master-networkpolicy.yaml</span><br><span class="line">│   ├── jenkins-master-svc.yaml</span><br><span class="line">│   ├── jenkins-test.yaml</span><br><span class="line">│   ├── jobs.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── rbac.yaml</span><br><span class="line">│   ├── secret.yaml</span><br><span class="line">│   ├── service-account.yaml</span><br><span class="line">│   └── <span class="built_in">test</span>-config.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">1 directory, 19 files</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">template中放的yaml文件和平时定义的差不多，但是都是以模板定义，通过values.yaml进行默认赋值。我们可以自定义该文件进行赋值</span><br></pre></td></tr></table></figure><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以jenkins为例</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Release.Name &#125;&#125;</span>-ui-test-<span class="template-variable">&#123;&#123; randAlphaNum 5 | lower &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">"helm.sh/hook":</span> <span class="string">test-success</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.Master.NodeSelector</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.Master.NodeSelector</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">4</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.Master.Tolerations</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.Master.Tolerations</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">4</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"test-framework"</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">"dduportal/bats:0.4.0"</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"bash"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"-c"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">        <span class="string">set</span> <span class="string">-ex</span></span><br><span class="line">        <span class="comment"># copy bats to tools dir</span></span><br><span class="line">        <span class="string">cp</span> <span class="string">-R</span> <span class="string">/usr/local/libexec/</span> <span class="string">/tools/bats/</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tools</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-ui-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.Image</span> <span class="string">&#125;&#125;:&#123;&#123;</span> <span class="string">.Values.Master.ImageTag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">["/tools/bats/bats",</span> <span class="string">"-t"</span><span class="string">,</span> <span class="string">"/tests/run.sh"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tests</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tools</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tests</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"jenkins.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;-tests</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tools</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#解释</span></span><br><span class="line"><span class="string">.Release.Name：是Chart内置变量，表示创建的release的名称，其他类似</span></span><br><span class="line"><span class="string">.Chart.Name：也是内置变量，表示chart名称</span></span><br><span class="line"><span class="string">.Values.Master.NodeSelector：.Values表示的是Value.yaml文件，Master是一级字段(顶格写)，依次如此</span></span><br><span class="line"><span class="string">template</span> <span class="string">"jenkins.fullname"</span><span class="string">：表示引用template目录下的其他模板的某个属性字段</span></span><br><span class="line"><span class="string">randAlphaNum</span> <span class="number">5</span> <span class="string">|</span> <span class="string">lower：前者是Go模板的函数，通过|传递结果</span></span><br></pre></td></tr></table></figure><h4 id="自定义chart"><a href="#自定义chart" class="headerlink" title="自定义chart"></a>自定义chart</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建chart基本目录结构</span></span><br><span class="line"><span class="string">helm</span> <span class="string">create</span> <span class="string">myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目录结构为</span></span><br><span class="line"><span class="string">myapp/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">charts</span></span><br><span class="line"><span class="string">├──</span> <span class="string">Chart.yaml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">templates</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">deployment.yaml</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">_helpers.tpl</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">ingress.yaml</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">NOTES.txt</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">service.yaml</span></span><br><span class="line"><span class="string">└──</span> <span class="string">values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改Chart.yaml文件，里面是基本描述信息</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">"1.0"</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">maintainer:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Dqy</span></span><br><span class="line">  <span class="attr">email:</span> <span class="number">1259178786</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://www.frdqy.top</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#template/deployment文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">helm.sh/chart:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.chart"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Service</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.replicaCount</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"myapp.name"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/instance:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Chart.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.image.tag &#125;&#125;</span>"</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.image.pullPolicy</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.Values.resources</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">12</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.affinity</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.tolerations</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">8</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="string">myapp.fullname：是当前chart的完整名称，其他类似。myapp就是当前chart的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑完后，需要检查语法，需要在myapp目录外面使用</span></span><br><span class="line"><span class="string">helm</span> <span class="string">lint</span> <span class="string">./myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打包，默认放在本地的仓库local中</span></span><br><span class="line"><span class="string">helm</span> <span class="string">package</span> <span class="string">myapp/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启仓库，监听本地8879端口</span></span><br><span class="line"><span class="string">helm</span> <span class="string">serve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装，可以通过目录安装，压缩包安装，仓库安装以及URL安装</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">local/myapp</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">./myapp</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">./myapp-0.1.0.tgz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除，使用purge删除占用的名字</span></span><br><span class="line"><span class="string">helm</span> <span class="string">delete</span> <span class="string">--purge</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure><h4 id="自定义仓库"><a href="#自定义仓库" class="headerlink" title="自定义仓库"></a>自定义仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在node1上运行httpd，存储卷绑定于/var/www目录</span></span><br><span class="line">docker run -d -p 8080:80 -v /var/www/:/usr/<span class="built_in">local</span>/apache2/htdocs/ httpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行index命令生成页面。myrepo是目录，目录内放打包好的压缩文件</span></span><br><span class="line">helm repo index myrepo/ --url http://192.168.163.135:8080/charts</span><br><span class="line"></span><br><span class="line"><span class="comment">#将mychart-0.1.0.tgz和index.yaml上传到k8s-node1的/var/www/charts目录。</span></span><br><span class="line">scp ./* root@node01:/var/www/charts/</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加仓库源</span></span><br><span class="line">helm repo add newrepo http://192.168.163.135:8080/charts</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;为了解决各个服务安装pod时的依赖以及资源文件修改编写等问题从而提出helm。helm和yum类似，可以理解为包管理工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="helm" scheme="http://yoursite.com/tags/helm/"/>
    
  </entry>
  
</feed>
