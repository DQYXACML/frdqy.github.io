{"meta":{"title":"Frdqy的博客","subtitle":"记录默默到无闻的学习路","description":"","author":"Frdqy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-12-28T00:23:37.000Z","updated":"2019-12-28T00:26:11.438Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-28T00:30:05.000Z","updated":"2019-12-28T00:30:38.637Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-28T00:25:13.000Z","updated":"2019-12-28T00:25:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"运维安全基础","slug":"运维安全基础","date":"2020-01-07T12:37:54.000Z","updated":"2020-01-07T12:39:35.397Z","comments":true,"path":"2020/01/07/运维安全基础/","link":"","permalink":"http://yoursite.com/2020/01/07/%E8%BF%90%E7%BB%B4%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/","excerpt":"加密算法和协议概要单向加密只能加密不能解密，用于特征码的制作，即验证数据完整性。","text":"加密算法和协议概要单向加密只能加密不能解密，用于特征码的制作，即验证数据完整性。 特性 定长输出 有雪崩效应，即小小的改动可以引起很大变化 常用算法md5：消息摘要算法，128位定长输出 sha1：安全hash算法，160位定长输出 对称加密主要有DES、AES、Blowfish、IDEA、RC6等加密方式 特性 加密解密使用同一密钥 将原始数据分割成为固定大小的块，逐个进行加密 缺陷 密钥过多 密钥分发困难 公钥加密密钥分为公钥与私钥，用公钥加密的数据只能使用与之配对的私钥进行解密 公钥：从私钥中提取产生，可公开给所有人，称为pubkey 私钥：通过工具创建，使用者自己留存，必须保证其私密性，称为secret key 用途数字签名：主要在于让接收方确认发送方的身份 密钥交换：发送方用对方公钥加密一个对称密钥，并发送给对方 数据加密 常用算法RSA、DSA(数字签名算法) 密钥交换公钥加密、DH算法。很少使用公钥加密实现密钥交换，因此下面只说DH算法实现的密钥交换。 背景：假设A，B，C三个人，A与B需要正常通信，C监听A与B的通信，现在需要A与B进行密钥的交换。 首先，A选择两个大素数假设为p，g，将这两个数明文发给B，此时C也收到这两个数。然后，A自己生成一个数x，将p^x%g的结果发送给B；同样，B也生成一个数y。将p^y%g的结果发送给A，此时C也可以获得这个结果，但是在有限时间内无法求出x或者y。最后，A将拿到的结果^x，B将拿到的结果^y，此时两个结果是一样的。因此这就实现了密钥交换，而此时C无法算出x和y，因此无法知道真正的密钥。 加密解密通讯过程加密过程背景：假设3个人：A，B，C。其中A与B想要通信，而C想要监听A与B的通信。(假设A发送给B数据) 首先，A将待发送的数据使用单向加密算法提取出特征码；然后A使用自己的私钥将特征码加密附加在数据后面；接着，A生成一个临时的对称密钥来加密整段数据(待发送数据和加密后的特征码)；然后，A使用B的公钥加密临时的对称密钥，并附加在整段数据后面；最后发送给B。 解密过程B拿到数据后首先使用自己的私钥来解密加密的对称密钥；然后使用对称密钥解密整段数据(真实数据和加密后的特征码)；接着使用A的公钥解密特征码(验证A的身份)；最后使用单向加密算法加密数据得到特征码与之比较，相同则数据完整性得到验证。 存在问题加密与解密过程都需要拿到对面的公钥，因此如果没有第三方可靠机构来提供公钥的验证，那么可能发生中间人攻击。即A想要B的公钥时，C表示我就是B然后把自己的公钥发送给A，接着向B表示自己是A，同时获取B的公钥与提供自己的私钥，这样AB认为自己可以正常通信，其实通信过程都经过C，这就是中间人攻击。 解决问题为了解决上述问题提出了CA的概念，即证书颁发机构。它保证通信双方能够安全的拿到对方的公钥，是一个双方都公信的第三方可信机构。 具体实现是CA首先自己给自己颁发一个证书，这个证书不通过网络传输，而是面对面交付给对方，里面包含CA机构的公钥。然后各个机构会像CA申请注册证书，里面包括该机构的公钥及有效期等信息。CA经过实地考察后没问问题会颁发电子证书给各个机构(有CA公钥可以解密CA证书)，这样当双方通信需要对方公钥时，双方通过交换证书来获得公钥(要验证证书是否有效，名称是否正确等)，从而避免假公钥的问题。 openssl开源实现ssl协议的程序 通信流程背景：A为通信客户端，B为通信服务端 首先A生成一组随机数RNC，发送client_hello信息将RNC发送给B，B也生成一组随机数RNS，发送server_hello将RNS发送给A。这个过程中双方协商使用什么加密方法进行通信(仅仅协商方法，不涉及具体密钥)。 然后，B将自己的证书发送给A，且请求A的证书；A得到证书后会检查证书有效期等信息，没问题则将自己的证书发给B，B也会检查相关信息。接着A将此前发送的所有信息使用hash签名后用自己私钥加密发给B端，B端用A公钥(从交换的证书中获得)解密后验证hash完整性，没有问题则继续进行后续通信。 上述过程如果没有问题，即最后的hash验证没有问题，则进入下面阶段。 首先A生成一个随机的密钥PMS，且使用对方的公钥加密发送给对方，这样，双方都拥有PMS、RNS、RNC，进行相同计算后即是双方通信时所需要的最终密钥。最后双方可以基于这个密钥进行通信。 组成部分libencrypt库，主要实现加密解密功能，由开发者使用 libssl库，主要实现ssl功能 openssl，是多用途命令行工具 openssl命令123456openssl [optino] help：查看帮助 version：查看版本信息 enc：对称加密相关 dgst：单向加密相关 ca：生成ca相关 对称加密1234567891011openssl enc [option] file -e：加密 -des3：指明使用des加密 -d：解密 -a：编码为base64编码格式 -salt：加杂质信息 -in file：指明要加密的文件 -out file：指明加密后生成的文件#举例openssl enc -e -des3 -a -salt -in ./fstab -out ./fstab.encopenssl enc -d -des3 -a -salt -in ./fstab.enc -out ./fstab 单向加密12openssl dgst [option] file -md5：使用md5加密 生成用户密码12openssl passwd -1 -salt 12345#-1表示基于md5算法 生成随机数1234openssl rand [option] number_length -base64：使用base64编码 -hex：使用16进制编码#常用于生成salt 公钥加密主要包括RSA，DSA、DH等 123456789#生成密钥(私钥)，保存至path目录下openssl genrsa -out path length_num#生成私钥且只能自己可读密钥保存至tmp目录下，密钥长度为2048(必须是2的次方)#注意，使用括号括起来是为了使其在子shell中运行而不影响当前shell的umask权限(umask 077; openssl genrsa -out /tmp/mykey 2048)#提取公钥openssl rsa -in /tmp/mykey -puout Linux随机数生成器1234567/dev/random：仅从熵池中返回随机数，熵池用尽则阻塞进程/dev/urandom：从熵池中返回随机数，随机数用尽会利用软件生成伪随机数(不安全)熵池：内存中存储随机数的空间熵池随机数来源： 硬盘io中断时间间隔 键盘io中断时间间隔 建立私有CA可以使用openssl命令建立CA，也可以使用OpenCA软件。这里只讲openssl命令 配置文件：/etc/pki/tls/openssl.cnf 生成私钥12#根据上述配置文件的描述放到规定目录下，命名要规范(umask 077; openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096) 生成自签证书123456#-new表示生成新证书签署请求；#-x509表示自签证书；#-key指明密钥路径(会自动从私钥中抽取公钥)#-out指明生成路径#-days指明有效期限，默认365天openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650 创建目录及文件1234mkdir /etc/pki/CA/&#123;certs,crl,newcerts&#125;touch /etc/pki/CA/&#123;serial,index.txt&#125;#给明第一个证书的序列号echo 01 &gt; /etc/pki/CA/serial 请求签署CA以httpd为例 申请的主机生成私钥1234#在服务的目录下创建ssl目录mkdir /etc/httpd/ssl ; cd /etc/httpd/ssl#生成私钥(umask 077; openssl genrsa -out httpd.key 4096) 生成请求命令1openssl req -new -key httpd.key -out httpd.csr -days 365 请求传送给主机略，一般直接硬盘拷走 在CA主机上签署证书1openssl ca -in /tmp/httpd.csr -out /etc/pki/CA/certs/httpd.crt -days 365 查看证书签署信息12#查看证书签署的subject信息openssl x509 -in /etc/pki/CA/certs/httpd.crt -noout -subject 吊销CA首先客户端获取要吊销的serial 1openssl x509 -in /etc/pki/CA/certs/httpd.crt -noout -serial -subject 其次，CA主机ijnx吊销操作 12openssl ca -revoke /etc/pki/CA/newcerts/serial.pem#其中serial为对应要吊销的序列号 最后生成吊销编号(只在第一次吊销时执行) 1echo 01 /etc/pki/CA/crinumber 更新证书吊销列表 1234openssl ca -gencrl -out thisca.crl#查看crl文件openssl crl -in /path/xxx.crl -noout -text","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"openssl","slug":"openssl","permalink":"http://yoursite.com/tags/openssl/"},{"name":"加密解密","slug":"加密解密","permalink":"http://yoursite.com/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"}],"author":"Frdqy"},{"title":"SELinux简介","slug":"SELinux简介","date":"2020-01-06T13:11:45.000Z","updated":"2020-01-06T13:12:33.201Z","comments":true,"path":"2020/01/06/SELinux简介/","link":"","permalink":"http://yoursite.com/2020/01/06/SELinux%E7%AE%80%E4%BB%8B/","excerpt":"概念增强型的Linux系统。","text":"概念增强型的Linux系统。 普通的linux使用DAC(自由访问控制)机制来管理用户权限，DAC对进程没有束缚，即进程拥有该进程的发起者的权限，这是很危险的，如果被别人提权，那么别人也就拥有了该用户的权限。 SELinux采用了MAC(强制访问控制)来解决上述问题。它规定了进程的权限是有限的，即使进程发起者有其他的权限，但是由其启动的进程只有发起时所规定的权限。 因此，在开启了SELinux的系统中，进程的权限不仅受到属组和属主的限制，还受到MAC的限制，可以理解为类似沙箱的环境，即使进程的发起者拥有访问沙箱外的权限，沙箱内的进程也无法访问沙箱外的空间。 工作模式strict每个进程都受到SELinux的控制 targeted仅有限个进程受到SELinux控制 SELinux状态enforcing强制，每个受限的进程都必然受限(因为工作模式处于targeted时并不是每个程序都受到限制，因此存在不受限的程序)。 permissive启用，每个受限的进程违规操作不会被禁止，但会被记录到日志中 disabled禁用 1234567#获取当前SELinux状态getenforce#设置当前SELinux状态，仅当前有效#永久有效需要修改/etc/sysconfig/selinuxsetenforce 0|1 0：设置为permissive状态 1：设置为enforcing状态 安全上下文SELinux为每个进程提供的安全标签，其标签为user:role:type:sensitivity:category。但是有用的主要是第三段。用于定义不同的权限范围，类似定义不同的沙箱。另外，某一目录下的文件默认拥有该文件的类型，即tmp目录内的文件类型为tmp***等等。 12345678910111213141516[root@localhost ~]@ ls -Z system_u:object_r:admin_home_t:s0 anaconda-ks.cfg system_u:object_r:admin_home_t:s0 anaconda-ks.cfg_bakunconfined_u:object_r:admin_home_t:s0 anaconda-ks.cfg_symbolic system_u:object_r:admin_home_t:s0 initial-setup-ks.cfgunconfined_u:object_r:admin_home_t:s0 testunconfined_u:object_r:admin_home_t:s0 test_symbolic#修改安全上下文chcon [option] file -t type_name：修改指定标签 -R：递归打标签 #还原默认安全上下文restorecon file -R：递归还原 SELinux规则库定义了处于哪些type域的进程可以访问哪些type文件。 此时访问流程变为：当进程发起文件访问时，首先检查进程的属主和属组是否可以访问，其次检查SELinux规则库内定义的该进程的域是否能够访问该类型的文件(读/写)，若失败则拒绝访问并记录到日志中。 布尔型规则一个程序运行时有多种功能，比如文件上传和下载功能。不同的功能的权限和危险程度也是不同的，因此SELinux可以实现将程序的功能设定为开启或关闭，这就是布尔型规则。 123456789101112#显示当前系统的所有SELinux的布尔型状态[root@localhost ~]@ getsebool -aabrt_anon_write --&gt; offabrt_handle_event --&gt; offabrt_upload_watch_anon_write --&gt; on#得到布尔型标签getsebool [option] file -a：显示所有#设置布尔型标签setsebool [option] file -P：写入配置文件中，永久有效 日志文件12345#注意，并不是所有日志都是文本文件[root@localhost ~]@ ls /var/log/audit/audit.log /var/log/audit/audit.log[root@localhost ~]@ file /var/log/audit/audit.log/var/log/audit/audit.log: data","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"SELinux","slug":"SELinux","permalink":"http://yoursite.com/tags/SELinux/"}],"author":"Frdqy"},{"title":"内核管理","slug":"内核管理","date":"2020-01-06T13:11:17.000Z","updated":"2020-01-06T13:13:40.989Z","comments":true,"path":"2020/01/06/内核管理/","link":"","permalink":"http://yoursite.com/2020/01/06/%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86/","excerpt":"内核特点 支持模块化。各模块以.ko结尾(kernel object) 支持模块运行时动态装载或卸载 单内核设计，却借鉴了微内核模块化机制的特点","text":"内核特点 支持模块化。各模块以.ko结尾(kernel object) 支持模块运行时动态装载或卸载 单内核设计，却借鉴了微内核模块化机制的特点 组成部分核心文件保存在/boot/下，名称为vmlinuz-VERSION-release 123456789101112ls /boot/config-4.18.0-80.el8.x86_64efigrub2initramfs-0-rescue-75fbe50f6f2b4dbfae8dc77fbbd4d906.imginitramfs-4.18.0-80.el8.x86_64.imginitramfs-4.18.0-80.el8.x86_64kdump.imgloaderlost+foundSystem.map-4.18.0-80.el8.x86_64vmlinuz-0-rescue-75fbe50f6f2b4dbfae8dc77fbbd4d906vmlinuz-4.18.0-80.el8.x86_64 模块文件保存在/lib/modules/下，名称为VERSION-release 123#ls /lib/modules/4.18.0-79.el8+2.x86_64 4.18.0-80.el8.x86_64 ramdisk内核的辅助性文件，本质是一个简装本的根文件系统，不是必须的文件，如果内核能直接驱动rootfs那么就不需要此文件。它可以加载目标设备驱动、逻辑设备驱动、文件系统驱动 存放在/boot/目录下叫做initramfs-VERSION.img 在centos6上叫做initrd，在centos7上叫做initramfs，可以通过dracut工具创建。 基于内存的磁盘设备，在内存区域模拟一个硬盘空间。当系统启动时，内核需要加载根文件系统，而根文件系统放在磁盘上，那么内核需要有该磁盘的相应驱动程序才可以读磁盘从而获取根文件系统，但是驱动程序都保存在文件系统中，这就成了一个死循环。因此设置了一个ramdisk，作为一个临时根文件系统，他是在安装操作系统时通过扫描本地磁盘接口从而获取相应的驱动程序放在内存中即ramdisk中，那么当内核需要读取根文件系统时就可以先把ramdisk当作根，然后通过其内的驱动来读取磁盘中的根文件系统，此时再把ramdisk的根切换到真正的根文件系统中，这样就完成了内核加载根的过程。 12345#自行创建initrd.imgdracut [option] initrd-image kernel-name --with=&lt;module&gt;：需要额外装载的模块#例如dracut /boot/initramfs-$(uname -r).img $(uname -r) 重要内核参数net.ipv4.ip_forward：核心转发(即同主机不同网卡之间的转发) vm.drop_caches：缓存丢弃，即关闭缓存 kernel.hostname：主机名 net.ipv4.icmp_echo_ignore_all：忽略所有ping操作 伪文件系统proc123456789内核状态和统计信息的输出接口；同时提供了配置接口&#x2F;proc&#x2F;sys 只读：&#x2F;proc&#x2F;@&#x2F;@ 可写：&#x2F;proc&#x2F;sys&#x2F;可接收用户指定的值来修改内核 修改： sysctl [option] name -a：显示所有可修改的值&#x2F;proc&#x2F;sys&#x2F;目录下的参数值 -w name&#x3D;value：修改某值 -p cfg_path：立即生效配置文件在&#x2F;etc&#x2F;sysctl.d&#x2F;*.conf，修改后可永久有效 sys1234567用于输出内核识别出的各硬件相关属性信息，也有内核对硬件特性的可设置参数，可定制硬件工作特性udev：通过读取&#x2F;sys目录下的硬件设备信息创建对应的硬件设备文件，方便管理配置文件一般在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;目录以及&#x2F;usr&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;#例子&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-ipoib.rules保存了网卡硬件信息，如果有多块网卡想交换则修改这里同时还要修改&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;下的网卡信息要想上述更改生效需要使用modprobe -r卸载在装载模块 内核相关命令编译选择符号123[ ]：不要此模块[M]：编译成内核模块，用到时再装载[*]：直接编译进内核核心 内核信息获取uname123456#显示系统信息uname [option] -r：显示内核的release号 -n：显示主机名，即hostname -v：显示编译版本号 -a：显示所有信息 lsmod12#显示内核状态，内容来自/proc/moduleslsmod modinfo12345#显示单个模块信息modinfo name -k：指明内核(适用多内核) -F field：显示指定字段 -n：显示文件路径 内核模块管理modprobe1234#实现模块的动态装载和卸载，不加选项则安装指定模块#正在使用的模块不要随意卸载modprobe [option] name -r：卸载模块 depmod12#生成依赖关系depmod [option] name insmod123#安装指定模块，但是无法解决依赖关系#filename必须是具体模块路径，可使用modinfo -n module_nameinsmod [option] filename rmmod12#删除指定模块rmmod module_name 内核编译开发环境Centos6/7：Development tools、server platform development、ncurses相关包 硬件信息cpu123#查看cpu信息，主要看平台型号即可cat /proc/infolscpu pci123456#查看pci信息lscpi#查看sub信息lsusb#查看硬盘设备lsblk 编译 下载内核并解压到/usr/source/kernel目录下，并创建连接对其操作 使用make menuconfig进入图形界面设置内核模块 make编译、make modules_install、make install 123456#进行内核编译时建议使用screen运行，防止终端断开导致内核编译失败打开：screen拆除：ctrl+a，d列出：screen -ls连接：screen -r screen_id关闭：exit 配置文件红帽系列的内核编译配置文件一般在/boot/config-4.18.0-80.el8.x86_64文件，里面列出了当前内核编译时的一些选项。非红帽发行版可能在/proc/config.gz内有配置文件。 编译前需要将上述这个模板复制过来，然后使用make menuconfig在其基础上进行修改即可。 进行编译多线程编译：make -j 指定cpu核心数 只对内核某个模块进行编译：切换到/usr/src/kernel对应模块目录下，使用make file_name.ko进行编译，注意.ko的文件必须是一个已有的.c文件。最后将其放到/lib/modules/release-name/kernel/下的对应目录中即可 内核清理用于对执行过编译操作的内核源码树进行重新编译 123456#清理绝大多数文件，但保存configmake clean#清理所有文件make mrproper#相当于mrproper，额外清理patches和编辑器备份文件make distclean 模块安装1make modules_install","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"内核管理","slug":"内核管理","permalink":"http://yoursite.com/tags/%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86/"}],"author":"Frdqy"},{"title":"系统启动流程","slug":"系统启动流程","date":"2020-01-06T13:10:42.000Z","updated":"2020-01-06T13:13:04.263Z","comments":true,"path":"2020/01/06/系统启动流程/","link":"","permalink":"http://yoursite.com/2020/01/06/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"POST带电自检，存储在ROM中，其中包括BIOS。","text":"POST带电自检，存储在ROM中，其中包括BIOS。 BOOT按次序查找各引导设备，第一个有引导程序的设备即为本次启动要用到的设备，引导程序叫做bootloader。在linux中叫做grub2。他主要是提供一个菜单，允许用户选择要启动的系统或不同的内核版本，把其装载到RAM中解压并展开，之后把系统执行权限移交给内核。 由于MBR的bootloader只允许446字节，远不够bootloader的编写。因此grub分成三段，第一段就位于bootloader中；第二段位于mbr之后的扇区中，用于让第一段的程序能够识别grub真正程序所在的文件系统；第三段位于/boot/grub目录下，提供真正能编辑的界面。配置文件在/boot/grub/grub.conf中。 这里提一个注意点，就是grub是如何识别不同设备的，也就是说grub是如何找到/boot/grub/下的grub配置文件的。这里分两种情况讨论。 第一种情况是boot单独分区，那么访问grub的配置文件时就不需要通过根文件系统来访问，即不需要/boot/grub/grub.conf来访问，而是通过grub的root命令将根设定为boot分区即可，这样访问就通过/grub/grub.conf即可。这种情形通常出现在根文件系统比较复杂或需要LVM支持，而boot只能放在基本磁盘上分区，因此将boot单独分区即可。 第二种情况是将boot放在/下，不进行单独分区，这样就需要通过根文件系统来访问，即/boot/grub/grub.conf，这样根文件系统就不能做成LVM形式，只能是基本磁盘分区。 分区命名12hd(@,@)#第一个@表示磁盘编号，第二个@表示分区编号，从0开始编号 第二阶段 提供菜单，并提供交互式接口 e：编辑模式 c：命令模式，交互式接口 123456help：显示帮助信息root (hd@,@)：把指定磁盘分区设定为根设备find (hd@,@)/path：查找指定磁盘上的文件，如果有的话会自动补齐kernel /path：指明内核程序的位置用于本次内核启动initrd /path：指明内核的额外帮助文件即ramdisk，版本号要匹配boot：引导启动内核 加载用户选择的内核或操作系统，允许传递特定参数，允许隐藏菜单 为菜单设置密码提供保护措施 配置文件grub2的配置文件在/boot/grub2/grub.cfg文件中，他依次调用/etc/grub.d目录下的配置文件来执行，还有一个配置文件在/etc/default/grub文件中。 1234567891011121314#修改启动等待时间需要修改/etc/default/grub文件中的GRUB_TIMEOUT选项#为grub加密，即需要密码才能修改grub启动以及编辑参数在/etc/grub.d/00_header 文件末尾添加如下内容set superusers='admin'password admin frdqy#设置加密的密码，使用grub2-mkpasswd-pbkdf2[root@localhost default]@ grub2-mkpasswd-pbkdf2 Enter password: Reenter password: PBKDF2 hash of your password is grub.pbkdf2.sha512.10000.9C469331A01C52D45794B9C812DEEA6D35DC876677D5552AE4AB7DA775C6FAAF495237DCB6E093F48CAFB42F259C4F0E15BE21AE1B146663B25135D605051795.08CEB5DDF92884E1239FBCF5C003BABCBD4FE11B73DF1557ECE31D028927F05AD013F5138B5E85A84A1E29EF51480837B878E5868D0E55F9C97B8D86CB9662F8再按照上文加入password字段即可 登录模式登录模式主要主要有rescue、emergency、shell引导 rescue模式只要在commandline配置末尾加s即可，类似单用户模式，ctrl+x启动 emergency则直接将上面s替换为emergency即可，ctrl+x启动 实例忘记root密码12345首先，在内核一行后加“rd.break console=tty0”，然后ctrl+x启动其次，挂载文件系统：mount -o remount /sysroot/之后，切换根目录到sysroot：chroot /sysroot/最后使用passwd修改root密码即可#注意：可能有时需要在根下创建autorelabel，用于标记selinux环境 MBR引导丢失123即前446字节丢失需要挂载一个镜像来排错，用iso即可进入rescue后切换至源系统的根，然后找到启动分区(例如sda)，最后grub2-install /dev/sda即可 配置文件丢失1需要使用rpm的--force强制覆盖安装内核，之后再安装grub2到启动分区即可 KERNELCentos5自身初始化探测可识别到的所有硬件设备、加载硬件驱动程序(可能此时会借助于ramdisk加载驱动)、以只读方式挂载根文件系统、运行用户空间第一个应用程序/sbin/init。 注意：init它的配置文件在centos6中存放在/etc/init/目录中，他会读取/etc/init.d/*.conf配置文件；而在centos7中，配置文件在/etc/systemd/system中和/usr/lib/systemd/system目录中 运行级别为了系统的运行或维护等目的而设定的机制，包括0~6七个级别，默认一般为3或5级别。定义在/etc/inittab中。 1234567#级别切换init 数字#级别查看，第一个表示上次级别，第二个是当前级别runlevel N 5#也可以查看级别who -r 0：关机模式，shutdown 1：单用户模式，root用户，无需认证；维护模式 2：多用户模式，会启动网络功能，但不启动NFS；维护模式 3：多用户模式，完全功能模式；文本界面，正常模式 4：预留级别，目前无特别使用目的，但习惯以同3级别功能使用 5：多用户模式，完全功能模式，图形界面，有图像接口 6：重启模式，reboot 初始化脚本12#/etc/rc.d/sysinit，系统初始化脚本任务：设计主机名、设置欢迎信息、激活udev和selinux、挂载/etc/fstab所有文件系统、检测根文件系统、以读写方式重新挂载根文件系统、设置系统时钟、根据/etc/sysctl.conf文件设置内核参数、激活lvm和软raid设备、激活各swap设备、加载额外设备的驱动程序、清理一些多余文件 配置文件Centos5中init的配置文件，即所有运行脚本存放在/etc/init.d/目录中。 1234567891011121314151617181920212223#每行定义一个action与之对应的processid:runlevel:action:processid：一个任务的标识符runlevels：在哪些级别启动此任务，为空表示所有级别action：在什么条件下启动此任务 wait：等待切换至此任务执行级别时执行一次 respawn：此任务终止时就会重新启动一次 initdefault：设定默认允许级别，process此时被省略 sysinit：设定系统初始化方式，一般为指定/etc/rc.d/rc.sysinit脚本process：具体任务#管控每个服务脚本在各级别下的启动或关闭状态chkconfig [option] name --list：查看服务状态 --add：添加一个脚本 --del：删除一个脚本 --level LEVELs &#123;on|off|reset&#125;：修改级别，默认为2345 #/etc/rc.d/rc @在这个文件中放了不同运行级别所需要的不同服务连接，他们都是连接至/etc/init.d/目录内的服务，其中命名都以K或S开头加数字加服务名 K**：需要停止的服务，数字越小越先关闭 S**：需要开启的服务，数字越小越先开启注意这里有一个独特的脚本叫做rc.local，他是最后执行的脚本，当用户想每次开机执行一条命令时即可编辑此脚本，在里面直接加命令即可，不需要单独添加服务。 总结由/sbin/init脚本执行。 流程为：设置默认运行级别、运行系统初始化脚本(/etc/rc.d/sysinit)、关闭对应级别下需要停止的服务、启动对应级别下需要开启的服务(/etc/rc.d/rc @)、设置登录终端。 Centos6本质和Centos5仍然时一样的，只不过由于启动进程被换成了upstart(依然是/sbin/init)，其描述文件发生了变化。即配置文件都是/etc/init/*.conf结尾的配置文件，而/etc/inittab仅用于定义默认运行级别。其语法为upstart语法，但由于centos7以后就不用该语法，且centos7已经缓存systemd来启动了，因此此处不做过多介绍。 Centos7init程序：systemd 特性系统引导时实现服务并行启动；按需激活进程；系统状态快照；基于依赖关系定义服务控制逻辑 基于socket的激活机制：socket与程序分离 基于bus的激活机制：总线有对某个接口的请求时，激活该接口 基于device的激活机制：自动激活、挂载设备 基于path的激活机制：监控某一路径，可以对特定行为进行响应 系统快照：保存unit当前状态信息于持久存储设备中 向后兼容sysv init脚本：/etc/init.d/的脚本仍可以执行 新概念unit：所有的系统资源都称作unit。它统一了资源配置格式，而使用文件后缀名来区别不同类型的文件及服务。 配置文件：/usr/lib/systemd/system/*、/etc/systemd/system unit常见类型service unit：文件扩展名为.service，用于定义系统服务 target unit：文件扩展名为.target，用于模拟实现运行级别，由于Centos7上没有运行级别概念，但是为了兼容6，就定义了target来模拟不同的级别 123#获取当前用户级别[root@localhost init.d]# systemctl get-default graphical.target device unit：文件扩展名为.device，用于定义内核识别的设备 mount unit：文件扩展名为.mount，用于定义文件系统挂载点 socket unit：文件扩展名为.socket，用于进程间通信 snapshot unit：文件扩展名为.snapshot，管理系统快照 swap unit：文件扩展名为.swap，用于标识swap设备 automount unit：文件扩展名为.automount，文件系统自动挂载设备 path unit：文件扩展名为.path用于定义文件系统中的文件和目录 systemctl命令管理系统服务主要靠service类型的unit文件来实现控制 12345678910111213141516171819systemctl [option] COMMAND [NAME...] start：启动服务 stop：停止服务 restart：重启服务 status：显示状态 try-restart：条件式重启 reload-or-restart：重载或重启服务 reload-or-try-restart：重载或条件重启服务 daemon-reload：重读unit文件 is-adtive：查看是否激活 list-units：列出所有已激活的服务 --type/-t：指明类型 --all：显示所有选项 enable：设置服务开机自启 disable：设置服务禁止开机自启 is-enable：查询服务是否能开机自启 mask：禁止某服务设置为开机自启 unmask：取消禁止某服务开机自启 list-dependencies：查看服务的依赖关系 管理target 级别 含义 0 runlevel0.target；poweroff.target 1 runlevel1.tartget；rescue.target 2 runlevel2.tartget；multi-user.target 3 runlevel3.tartget；multi-user.target 4 runlevel4.tartget；multi-user.target 5 runlevel5.tartget；graphical.target 6 runlevel6.tartget；reboot.target 123456789101112131415#级别切换systemctl isolate NAME.target#查看级别systemctl list-units -t target#获取默认运行级别systemctl get-default#修改默认运行级别#修改运行级别实质是修改/etc/systemd/system/default.target的符号链接实现的#且定义在不同级别运行的服务也会在/etc/systemd/system/下对应的目录中创建符号链接，他们实际是/usr/lib/systemd/system/下对应unit的符号链接systemctl set-default NAME.target#切换紧急救援模式systemctl rescue#切换至紧急模式，不会装载额外系统驱动或者多余设置#拿Centos6来说，rescue模式还会执行sysinit初始化脚本，而emergency不会执行systemctl emergency 其他命令12345678910#关机systemctl halt；systemctl poweroff#重启systemctl reboot#挂起(睡眠)systemctl suspend#快照systemctl hibernate#快照并挂起(睡眠)systemctl hybird-sleep unit文件格式由三部分组成[unit]、[service]、[install] [unit]：定义与unit类型无关的信息。如描述信息和依赖关系 [service]：定义与特定类型相关的专用选项，各种类型均不一样 [install]：定义由enable和disable实现服务启动关闭时用到的选项 unit段常用选项description：描述信息 after：定义启动次序，表示当前unit晚于哪些unit requires：指明依赖到的其他unit，即依赖关系，要求比wants强，即必须全部启动 wants：指明依赖到的其他unit，即依赖关系，但即使不启动，本服务自身也能启动 conflicts：定义units之间的依赖关系 service段常用选项type：定义影响execstart及相关参数的功能的unit进程启动类型 类型有：simple：默认类型，表示为主进程 ​ forking：表示进程会生成一个主进程，自身会退出 ​ oneshot：一次性进程 ​ dbus：后续进程在主进程得到dbus后才能启动 ​ notify：后续进程在主进程发送notify后才能启动 ​ idle：类似于simple execstart：指明启动unit要运行的命令或脚本 execstop：停止unit要运行的命令或脚本 restart：进程意外退出后重启的命令或脚本 environmentfile：环境配置文件，在execstart前读取，为其提供变量 install段常用选项alias：当前程序别名 requiredby：被哪些unit所依赖，强依赖 wantedby：被那些unit所依赖，弱依赖 注意当修改或新建unit文件时，要通知systemd重载此配置文件 1systemctl daemon-reload","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"启动流程","slug":"启动流程","permalink":"http://yoursite.com/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"name":"systemd","slug":"systemd","permalink":"http://yoursite.com/tags/systemd/"},{"name":"init","slug":"init","permalink":"http://yoursite.com/tags/init/"}],"author":"Frdqy"},{"title":"系统安装自动化","slug":"系统安装自动化","date":"2020-01-06T13:09:57.000Z","updated":"2020-01-06T13:13:27.987Z","comments":true,"path":"2020/01/06/系统安装自动化/","link":"","permalink":"http://yoursite.com/2020/01/06/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%87%AA%E5%8A%A8%E5%8C%96/","excerpt":"总览电脑启动时，首先bootloader加载kernel，然后为了防止kernel不能识别硬盘，kernel首先使用ramdisk在内存中模拟一个根文件系统，这就不需要读取真正的磁盘，而且这个模拟文件系统有操作系统安装时需要的各种程序。之后，启动anaconda程序来完成系统安装，这个程序处在待安装系统的某个程序包下即可装载运行。","text":"总览电脑启动时，首先bootloader加载kernel，然后为了防止kernel不能识别硬盘，kernel首先使用ramdisk在内存中模拟一个根文件系统，这就不需要读取真正的磁盘，而且这个模拟文件系统有操作系统安装时需要的各种程序。之后，启动anaconda程序来完成系统安装，这个程序处在待安装系统的某个程序包下即可装载运行。 安装过程首先加载安装镜像中的boot.cat文件 其次执行isolinux/isolinux.bin，他的配置文件为同目录下的/isolinux.cfg 等待用户选择对应安装的内核，每个菜单项加载不同的内核，也在/isolinux/vmlinuz下，并且通过append向内核传递参数。 最后装载img根文件系统(即)，并启动anaconda。注意，后续的anaconda及其安装用到的程序包可以来自光盘及镜像自带的仓库，也可以手动指定仓库(http,ftp等)，手动指定时需要在boot命令(引导界面按ESC)下输入linux method即可。 安装引导选项引导选项可以将必要的直接添加在/isolinux/isolinux.cfg的对应条目下，就不需要手动输入了 1234567891011121314151617181920boot： text：文本安装方式 method：手动指定安装方式 与网络相关的引导选项： ip&#x3D;IPADDR netmask&#x3D;MASK gateway&#x3D;GW dns&#x3D;DNS_SERVER 远程访问功能： vnc vncpassword&#x3D;&#39;password&#39; 启动紧急救援： rescue 装载额外驱动程序： dd 指明kickstart的位置 ks&#x3D;cdrom:&#x2F;path ks&#x3D;http:&#x2F;&#x2F;host:port&#x2F;path ks&#x3D;ftp:&#x2F;&#x2F;host:post&#x2F;path ks&#x3D;https:&#x2F;&#x2F;host:port&#x2F;path 配置文件anaconda除了基本的交互式配置外，还支持通过读取配置文件中事先定义好的配置项自动完成配置；配置文件遵循特定的语法格式，此文件即为kickstart文件，该文件如果是系统第一次安装且需要自定义的话一般放在服务器上，因为放在光盘内的话不能编辑，然后安装时从服务器读取即可。 安装好的系统后配置文件在家目录下，为anaconda-ks.cfg。 文件格式命令段指定各种安装前配置选项，如键盘类型。由必备命令，可选命令组成。 必备命令authconfig：认证方式配置 bootloader：定义bootload安装位置 keyboard：设置键盘类型 lang：语言类型 part：分区布局 rootpw：管理员密码； 12#生成密码方式使用opensslopenssl passwd -1 -salt `openssl rand -hex 4` clearpart：清空磁盘分区 volgroup：创建卷组 logvol：创建逻辑卷 timezone：设置时区 其他命令install or upgrade：安装或升级 text：安装界面类型，text为tui，默认为gui network：配置网络接口 repo：指明仓库 url：指明仓库，优先级高于repo firewall：防火墙 selinux：SELinux 123456#关闭firewallsystemctl stop firewalld.servicesystemctl disable firewalld.service#关闭selinux编辑/etc/sysconfig/selinux文件，修改SELINUX值，不等于enforcing即可另外可以通过getenforce查看，如果是1或者是enforcing则使用setenforce 0设置即可 程序包段指明要安装的程序包以及包组，也包括不安装的程序包。以%packages开头，%end结尾 @group_name表示包组 package表示单个程序包 -package表示不安装程序包，但是为了解决依赖可能自动安装 脚本段%pre：安装前shell脚本 %post：安装后shell脚本 生成工具system-config-kickstart图形界面来配置kickstart配置文件 123456789#安装yum install system-config-kickstart#启动system-config-kickstart#检查语法错误ksvalidator#将isolinux目录复制到一个新的目录下，为myboot，然后把kickstart配置文件放在与目录同级位置#创建光盘镜像mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V \"Centos\" -c isolinux/boot.cat -b isolinux/isolinux.bin -o /root/boot.iso myboot/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"自动化安装","slug":"自动化安装","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85/"}],"author":"Frdqy"},{"title":"进程管理","slug":"进程管理","date":"2020-01-05T05:44:15.000Z","updated":"2020-01-05T05:45:17.711Z","comments":true,"path":"2020/01/05/进程管理/","link":"","permalink":"http://yoursite.com/2020/01/05/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"pstree显示进程树信息","text":"pstree显示进程树信息 12345678#显示的一部分[root@localhost 1]# pstreesystemd─┬─ModemManager───2*[&#123;ModemManager&#125;] ├─NetworkManager───2*[&#123;NetworkManager&#125;] ├─VGAuthService ├─2*[abrt-dump-journ] ├─abrtd───2*[&#123;abrtd&#125;] ├─accounts-daemon───2*[&#123;accounts-daemon&#125;] ps显示当前进程运行的状态快照。内核通过/proc/将内核信息输出给用户。其中具体/proc/PID文件中的文件都是内核输出的参数，文件内容即是当前的内核对应数据。 1234567891011121314151617181920212223242526272829303132333435363738#ps选项有三种风格，注意区分ps [option] a：所有与终端相关的进程 x：所有与终端无关的进程 u：以用户为中心组织进程状态信息显示 -e：显示所有进程 -f：完整格式 -H：以层级结构显示进程相关信息 -o/o field1,field2...：自定义显示字段，后面加字段名即可#常用fieldpid、ni、pri、psr、pcpu、stat、comm、tty、ppid、rtprioni：nice值，范围-20~19，越小优先级越高priority：优先级rtprio：实时优先级#常用组合：ps aux[root@localhost 1]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANVSZ：虚拟内存集RSS：常驻内存集STAT： R：运行态 S：可终端睡眠 D：不可中断睡眠 T：停止态 Z：僵死态，自己没资源了，等待父进程回收 +：前台进程 l：多线程进程 N：低优先级进程 &lt;：高优先进程 s：会话引领者 #常用组合：ps -ef/F[root@localhost 1]# ps -eFUID PID PPID C SZ RSS PSR STIME TTY TIME CMDPPID：父进程idC：cpu占用百分比PSR：占用哪个cpuSTIME：进程开始时间 pgrep/pkill根据进程的名字或其他属性来查询进程或向进程发送信号。 123456pgrep/pkill [option] pattern -u/U uid：显示指定用户进程 -t tty：与指定终端相关的进程 -l：显示进程名 -a：显示完整格式进程名 -P pid：显示此进程的子进程 pidof根据进程名取指定进程的进程号 12[root@localhost 1]# pidof systemd8331 8324 1292 1274 1 top动态显示进程信息 12345678910111213141516171819202122232425262728293031323334353637383940414243[root@localhost 1]# toptop - 04:41:07 up 8:28, 1 user, load average: 0.09, 0.05, 0.01Tasks: 261 total, 1 running, 260 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stMiB Mem : 798.1 total, 85.0 free, 467.6 used, 245.5 buff/cacheMiB Swap: 2048.0 total, 1759.0 free, 289.0 used. 172.5 avail MemPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND -d @：指定显示时间间隔 -b：以批次方式显示 -n @：显示多少批次#第一行；也可以用uptime显示当前时间；运行时间；登录当前系统的用户数；平均负载(过去1分钟、5分钟、15分钟的平均队列长度，即等待cpu进程数)#第一行一共运行进程数；运行数、睡眠数、停止数、僵死数#第三行cpu占用百分比 us：用户空间百分比 sy：内核空间百分比 ni：用于nice值调整占用的cpu百分比 id：空闲百分比 wa：等待io完成所消耗cpu时间百分比 hi：处理硬件中断占用cpu百分比 si：处理软件中断占用cpu百分比 st：被虚拟化程序占用的cpu百分比#第四行物理空间占用情况：总空间；空闲空间；已使用空间；用于缓存和缓冲的内存空间#第五行交换分区占用情况：总空间；空闲空间；已使用空间；用于缓存和缓冲的内存空间#第六行SHR：共享内存空间；其他与ps显示意义一样#内部命令P：以占据CPU百分比显示M：以占据内存百分比显示T：以累计占用CPU时间排序l：显示/隐藏第一行信息t：显示/隐藏第二行信息m：显示隐藏第三行信息s：修改显示时间间隔k：终止指定进程1：显示全部cpu htop改进版的top 12345678910111213141516#安装#安装epel库dnf install epel-release -ydnf install htop htop [option] -d @：指定延迟时间 -s colume：以指定字段进行排序 -u UserName：仅显示指定user的进程u：选择指定用户进程H：显示/隐藏用户线程K：显示隐藏内核线程l：跟踪一个进程的操作s：跟踪一个进程的系统调用t：以层级关系显示各进程状态a：选定进程运行在指定cpu上 vmstat管理虚拟内存信息 12345678910111213141516171819202122232425262728293031vmstat [option] [delay [count]] delay：多久刷新一次 count：刷新多少次 -s：显示内存统计数据[root@localhost ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st procs： r：等待运行进程的个数 b：处于不可中断睡眠的进程个数memory： swpd：交换内存使用情况，若使用则说明内存不足 free：空闲的物理内存总量 buffer：用于buffer的内存总量 cache：用于cache内存总量swap： si：数据进入swap的速率(kb&#x2F;s) so：数据离开swap的速率(kb&#x2F;s)io： bi：从块设备读入数据到系统的速度(kb&#x2F;s) bo：保存数据到块设备的速度(kb&#x2F;s)system： in：中断速率 cs：进程上下文切换速率cpu： us：用户空间占用百分比 sy：系统占用百分比 id：空闲时间占用百分比 wa：等待时间百分比 st：被虚拟化偷走的时间 pmap显示进程内存映射，实际是通过查看/proc下对应进程的maps文件 12pmap [option] pid -x：显示详细格式信息 dstat生成系统资源统计数据，几乎包括上述所有功能 1234567891011121314151617181920dstat [option] [delay[count]] delay：多久刷新一次 count：刷新多少次 -c：查看cpu信息 -d：查看disk信息 -m：查看内存信息 -g：查看内存页交换信息 -n：显示网络信息 -r：显示io统计数据 -p：统计进程相关数据 -s：统计swap数据 --tcp：显示tcp相关信息 --udp：显示udp相关信息 --raw：显示裸套接字信息 --socket：显示所有套接字信息 --ipc：显示进程间交换信息 --top-cpu：显示最占用cpu的信息 --top-io：显示最占用io的信息 --top-mem：显示最占用内存的信息 --top-lantency：显示延迟最大的进程信息 kill终止一个进程，本质是向进程发送一个命令。 1234567891011kill [option] pid -l：列出可用信号 -s @：发送指定信号 % @：终止指定id的作业(jobs)常用信号 SIGHUP：不重启读配置文件 SIGINT：终止正在运行的进程，相当于Ctrl+c SIGTERM：默认信号，终止正在运行的进程(关闭进程相关后再杀死) SIGKILL：杀死正在执行的进程(不管进程在干什么直接杀死，可能会损坏文件) SIGCONT：后天进程继续执行 SIGSTOP：将进程送到后台 killall根据进程名杀死进程，用于关闭一整个服务 1killall [SIGNAL] PRRC_NAME fg/bg/jobs/nohup12345678#把指定作业调往前台fg jobs_num#把作业送往后台bg jobs_num#查询作业jobs#将指定作业剥离与中断关系在后台运行nohup COMMAND/FIEL &amp; 进程优先级调整可通过nice值调整的优先级范围：100-139，分别对应于-20~19。nice值越低优先级越高 进程启动时，其nice值默认为0，其优先级是120。 12345678910#仅root可以调低nice值nice [option] [COMMAND] -n NICE：以指定nice值启动#调整nicerenice [option] pid -n NICE：调整nice值 #查看nice和优先级ps axo pid,ni,priority,comm","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"author":"Frdqy"},{"title":"Linux网络属性配置","slug":"Linux网络属性配置","date":"2020-01-04T12:03:23.000Z","updated":"2020-01-05T05:47:41.022Z","comments":true,"path":"2020/01/04/Linux网络属性配置/","link":"","permalink":"http://yoursite.com/2020/01/04/Linux%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/","excerpt":"ifcfg系列ifconfig接口及地址查看和管理","text":"ifcfg系列ifconfig接口及地址查看和管理 1234567ifconfig [interface] -a：显示所有接口，包括非激活状态ifconfig INTERFACE [aftype] option | address...#启用网卡,其中大写的需要替换成具体接口名以及ip地址、子网掩码等信息ifconfig INTERFACE_NAME IP/MASK [up]ifconfig INTERFACE_NAME netmask NETMASK route路由查看和管理 查看12route [option] -n：直接显示数字信息，不进行主机名解析，效率比较高 添加123456route add [-net|-host] target [netmask Nm] [gw GW] [dev]#实例#添加条目，经由192.168.10.1访问10.10.10.0网络route add -net 10.10.10.0/8 gw 192.168.10.1#添加默认网关route add -net 0.0.0.0/0.0.0.0 gw 192.168.10.1 删除123456route del [-net|-host] target [gw GW] [dev]#实例#删除上面创建的条目route del -net 10.10.10.0/8 gw 192.168.10.1#删除默认网关route del default netstat网络连接、路由表、接口信息等网络信息查看 1234567891011121314151617#显示路由表netstat -rn -r：路由表 -n：数字格式#显示网络连接netstat [option] -t：tcp相关连接 -u：UDP相关连接 -w：raw socket相关连接 -l：处于监听状态的连接 -a：所有状态 -n：以数字格式显示 -e：扩展格式 -p：显示相关进程pid -i：显示接口信息#常用组合 -tan、-uan、-tnl、-unl、-tnlp ifup/ifdown通过读取/etc/sysconfig/network-scripts/下网卡的配置文件进行网卡的开启和禁用 hostnamectl配置主机名 1234hostnamectl status：显示当前主机名设定 set-hostname NAME：设定主机名，永久有效#centos6中需要修改/etc/sysconfig/network来修改主机名才能永久有效 DNS配置1234#在配置文件/etc/resolov.conf中修改即可，最多可以同时添加3个#nameserver为关键字，后面ip地址只能以数字形式，不能使用域名nameserver 192.168.163.2#注意/etc/hosts优先于dns配置文件，如果本地有host，那么host内的设置优先 iproute2系列ip查看和管理路由、设备、策略路由以及隧道等信息，主要用来逐渐取代ifcfg系列。 1234567891011121314151617181920212223242526272829303132333435ip [option] OBJECT &#123;COMMAND|help&#125; link：网络设备配置 show/list：显示设备的属性 set：设置设备的属性 dev NAME：指明要管理的设备 up/down：启用和关闭设备 multicast on/off：启用关闭多播 name NAME：重命名网络接口 mtu NUMBER：设置MTU大小，默认1500 netns NAME：ns为命名空间，用于将指定接口移到某个netns中，常用于构建虚拟网络 help：显示简要帮助 netns：管理网络命名空间 add NAME：增加一个网络命名空间 del NAME：删除一个网络命名空间 list：列出所有的netns exec NAME COMMAND：在netns中执行COMMAND命令 addr：管理网络接口的ip地址 add IP dev INTERFACE：指定接口增加IP地址 label NAME：为指定接口添加接口别名。用于解决ifconig命令不显示多个地址的问题 broadcast ADDRESS：广播地址，一般自动获得 scope SCOPE_VALUE：指定接口作用范围 global：全局可用 link：接口可用 host：仅本机可用 delete IP dev INTERFACE：删除指定设备的地址 show：显示地址信息 flush dev INTERFACE：清空指定接口地址 route：路由管理 add 目标网络/掩码长度 via GW dev 设备 [src]：添加路由 change：同上 repalce：同上 delete 网络：删除到指定网络的路由 show：显示路由信息 get 目标网络：获取某单个路由信息 flush：清空路由信息 ss用来取代netstat的命令 1234567891011121314151617181920ss [option] [filter] -t：tcp相关连接 -u：UDP相关连接 -w：raw socket相关连接 -l：处于监听状态的连接 -a：所有状态 -n：以数字格式显示 -e：扩展格式 -p：显示相关进程pid -i：显示接口信息 -m：显示内存用量 -o：显示计时器信息 [fileter] state [TCP-STATE] [EXPRESSION]#实例#过滤出目标端口和源端口均为22的信息ss -tan '( dport = :22 or sport = :22 )'#过滤出TCP状态为ESTABLISHED的连接ss -tan state ESTABLISHED#常见TCP状态：LISTEN,ESTABLISHED,FIN_WAIT_1,FIN_WAIT_@,SYN_SENT,SYN_RECV,CLOSED 配置文件ip上述命令修改的信息都是临时有效，若想重启后仍然有效需要修改配置文件。配置文件一般放在/etc/sysconfig/network-scripts/目录下。 参数 含义 DEVICE 此配置文件的设备名 ONBOOT 开机时是否激活 UUID 设备唯一标识 IPV6INIT 是否初始化IPV6 BOOTPROTO 激活此接口时使用什么协议配置接口属性，常用dhcp、static TYPE 接口类型 DNS1 定义第一DNS服务器指向 DNS2 定义备用DNS服务器指向 DOMAIN DNS搜索域 GATEWAY 网关 IPADDR ip地址，静态是要填写 NETMASIK/PREFIX 以长度方式指明子网掩码 USERCTL 是否允许普通用户控制此设备 PEERDNS 是否允许dhcp的dns指向覆盖本地的dns NM_CONTROLLED 是否使用nm工具 12345#centos6service SERVICE_NAME &#123;start|stop|statues|restart&#125;#centos7/8systemctl &#123;start|stop|statues|restart&#125; SERVICE_NAMEnmcli SERVICE_NAME &#123;start|stop|statues|restart&#125; route配置文件放在/etc/sysconfig/network-scripts/route-INTERFACE，有两种配置方式，不可混用。 每行一个路由条目 1TARGET via GW 每三行一个路由条目 123ADDRESS#&#x3D;TARGETNETMASK#&#x3D;MASKGATEWAY#&#x3D;NEXTHOP 其他命令ping通过icmp协议报文进行网络探测。可用于DDOS攻击(需要大量主机) 1234ping [option] destination -c：指明ping包个数 -w @：ping命令超时时长 -W @：一次ping中等待对方响应 hping3进阶版ping，可设置选项更多，DDOS更快了 12345#安装时需要epel源hping3 [option] ip --fast：每秒发10次 --faster：更快 --flood：更快，且不会显示ping过程 traceroute用于追踪主机间路由信息，即跟踪当前主机到目标主机之间经过的路由信息。 ftp文件传输协议相关命令 12345678910匿名登录：anonymoushelp：命令帮助get：下载一个文件mget：下载多个文件put：上传一个文件mput：上传多个文件delete：删除一个文件mdelete：删除多个文件bye：结束ftp连接#注意：在ftp模式下执行命令前加！则表示在本地主机上执行 lftp取代ftp的命令工具 12345678910lftp [option] ip -u usre,passwd：以指定用户名和密码登录,若要匿名访问则不输入该选项即可help：命令帮助get：下载一个文件mget：下载多个文件put：上传一个文件mput：上传多个文件rm：删除一个文件mrm：删除多个文件bye：结束ftp连接 wget下载网络资源 12345#不能下载目录，只能下载文件wget [option] url -b：在后台下载(脚本中可能使用) -q：静默模式 -O file：指明下载位置","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"网络配置","slug":"网络配置","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}],"author":"Frdqy"},{"title":"IF常见检测选项补充","slug":"IF常见检测选项补充","date":"2020-01-03T11:39:30.000Z","updated":"2020-01-03T11:45:54.526Z","comments":true,"path":"2020/01/03/IF常见检测选项补充/","link":"","permalink":"http://yoursite.com/2020/01/03/IF%E5%B8%B8%E8%A7%81%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9%E8%A1%A5%E5%85%85/","excerpt":"常用选项","text":"常用选项 123456789101112131415161718192021222324[ -f \"somefile\" ] ：判断是否是一个文件[ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限[ -n \"$var\" ] ：判断$var变量是否有值[ \"$a\" = \"$b\" ] ：判断$a和$b是否相等-r file 用户可读为真-w file 用户可写为真-x file 用户可执行为真-f file 文件为正规文件为真-d file 文件为目录为真-c file 文件为字符特殊文件为真-b file 文件为块特殊文件为真-s file 文件大小非0时为真-t file 当文件描述符(默认为1)指定的设备为终端时为真含条件选择的shell脚本 对于不含变量的任务简单shell脚本一般能胜任。但在执行一些决策任务时，就需要包含if/then的条件判断了。shell脚本编程支持此类运算，包括比较运算、判断文件是否存在等。基本的if条件命令选项有： - eq —比较两个参数是否相等（例如，if [ 2 –eq 5 ]）-ne —比较两个参数是否不相等-lt —参数1是否小于参数2-le —参数1是否小于等于参数2-gt —参数1是否大于参数2-ge —参数1是否大于等于参数2-f — 检查某文件是否存在（例如，if [ -f \"filename\" ]）-d — 检查目录是否存在几乎所有的判断都可以用这些比较运算符实现。脚本中常用-f命令选项在执行某一文件之前检查它是否存在。 其他选项123456789101112131415161718192021222324252627282930313233343536373839404142434445[-a file] 如果file存在则为真[-b file] 如果file存在且是一个块特殊文件则为真[-c file] 如果file存在且是一个字特殊文件则为真[-d file] 如果file文件存在且是一个目录则为真-d前的!是逻辑非例如：if [ ! -d $lcd_path/$par_date ]表示后面的那个目录不存在，则执行后面的then操作[-e file] 如果file文件存在则为真[-f file] 如果file存在且是一个普通文件则为真[-g file] 如果file存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思）[-h file] 如果file存在且是一个符号连接则为真[-k file] 如果file存在且已经设置粘制位则为真当一个目录被设置为\"粘制位\"(用chmod a+t),则该目录下的文件只能由一、超级管理员删除二、该目录的所有者删除三、该文件的所有者删除也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。具体例子如下：#ls -dl /tmpdrwxrwxrwt 4 root root .........注意other位置的t，这便是粘连位。[-p file] 如果file存在且是一个名字管道（F如果O）则为真管道是linux里面进程间通信的一种方式，其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等。[-r file] 如果file存在且是可读的则为真[-s file] 如果file存在且大小不为0则为真[-t FD] 如果文件描述符FD打开且指向一个终端则为真[-u file] 如果file存在且设置了SUID（set userID）则为真[-w file] 如果file存在且是可写的则为真[-x file] 如果file存在且是可执行的则为真[-O file] 如果file存在且属有效用户ID则为真[-G file] 如果file存在且属有效用户组则为真[-L file] 如果file存在且是一个符号连接则为真[-N file] 如果file存在and has been mod如果ied since it was last read则为真[-S file] 如果file存在且是一个套接字则为真[file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真[file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真[file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真[-o optionname] 如果shell选项“optionname”开启则为真[-z string] “string”的长度为零则为真[-n string] or [string] “string”的长度为非零non-zero则为真[sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真[string1!=string2] 如果字符串不相等则为真[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真[arg1 OP arg2] “OP”is one of –eq,-ne,-lt,-le,-gt or –ge.These arithmetic binary oprators return true if “arg1”is equal to,not equal to,less than,less than or equal to,greater than,or greater than or equal to“agr2”,respectively.“arg1”and “agr2”are integers.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"IF选项","slug":"IF选项","permalink":"http://yoursite.com/tags/IF%E9%80%89%E9%A1%B9/"}],"author":"Frdqy"},{"title":"Linux程序包管理","slug":"Linux程序包管理","date":"2020-01-03T11:38:49.000Z","updated":"2020-01-04T12:17:27.874Z","comments":true,"path":"2020/01/03/Linux程序包管理/","link":"","permalink":"http://yoursite.com/2020/01/03/Linux%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"概念将源代码编译后变成目标二进制格式，然后需要将二进制程序和其库文件、配置文件、帮助文件等打包形成一个或多个方便用户使用管理的包，这个包叫做程序包，实现这个过程的工具叫做程序包管理器。他可以帮助用户实现程序的安装、升级、卸载、查询、校验的等。","text":"概念将源代码编译后变成目标二进制格式，然后需要将二进制程序和其库文件、配置文件、帮助文件等打包形成一个或多个方便用户使用管理的包，这个包叫做程序包，实现这个过程的工具叫做程序包管理器。他可以帮助用户实现程序的安装、升级、卸载、查询、校验的等。 包管理器组成格式 程序包的组成清单。每个程序包单独实现。包括文件清单、安装或卸载脚本 数据库。整个系统维护一个数据库，存放各个包的名称版本、依赖关系、功能说明、文件路径和校验码等，数据库存放在/var/lib/rpm下，每个文件都存放不同侧重点的信息。 dpkg待补充 rpm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950rpm [option] package -i：安装 -h：hash marks输出进度条，每个'#'表示2%进度 --test：只检测不安装，通常检测依赖 --replacepkgs：重新安装 --nosignature：不检查签名，即不检查来源合法性 --nodigest：不检查包完整性信息 -U：升级或安装 -h：hash marks输出进度条，每个'#'表示2%进度 --oldpackage：程序包降级 --force：强制升级 -e：卸载 --allmatches：卸载所有匹配到的指定程序包各版本 --test：只测试卸载，检测依赖 -q：查询 #rpm &#123;-q|--query&#125; [select-options] [query-options] [select options] package_name：查询指定的程序包是否安装及其版本 -a：查询所有已安装包 -f file：查询指定的文件由哪个程序包安装生成 -p package：对未安装的程序包查询 --whatprovides capability：查询指定capability由哪个包提供 --whatrequiers capability：查询指定capability被哪个包依赖 [query-options] --changelog：查询rpm包的changelog -l：列出程序包安装生成的所有文件 -i：查询程序包相关的信息，版本号、大小等 -c：查询指定程序包的配置文件 -d：查询指定程序包文档 --provides：列出指定程序包的所有capability -R：查询指定程序包的依赖关系 --scripts：查询程序包自带的脚本 -V：校验 #校验位含义 S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P caPabilities differ -v：详细信息 -K：不安装直接检验程序合法性与完整性 --nosignature：不检查签名，即不检查来源合法性 --nodigest：不检查包完整性信息 #注意：不要对内核做升级操作，直接安装，支持多内核共存#程序包原配置文件被改动过，那么安装新版本时不会覆盖，而是将新的配置文件重命名后提供 包命名格式name-version-release.arch.rpm version：major.minor.release release.arch：rpm包的发行号 拆包由于程序打包后并不是所有功能都被用户所需要，因此引进拆包的概念。拆包后包分为主包和支包。 主包：name-version-release.arch.rpm 支包：name-function-version-release.arch.rpm ​ function：devel，utils，libs等各种开发或者插件包 依赖关系每个rpm包之间可能存在安装A就要先安装B这种情况，这叫做依赖关系。 12#查询指定程序包的依赖关系rpm -qr package 前端工具用来自动解决依赖关系。rhel系列上rpm包前端工具为yum、dnf。centos8中dnf已取代yum，不过大体命令使用格式没变，下文均使用习惯的yum来表示dnf。 仓库yum的仓库就是yum repository，它存储了大量的rpm包以及包的相关源数据，通常放置于特定目录下repodata 1234567891011121314151617#仓库定义#&#123;A|B&#125;其中A为默认选项[repositoryid]name=some name for repo#baseurl指向的是一堆url，可以是包含repodata的文件夹baseurl=url://pathenable=&#123;1|0&#125;#该仓库是否启用gpgcheck=&#123;1|0&#125;#是否启用校验gpgkey=url#指明gpg的密钥文件mirrorlist=url#镜像url文件enablegroups=&#123;1|0&#125;#是否使用组批量管理程序包failovermethod=&#123;roundrobin|priority&#125;#多个仓库的选用顺序定义#创建repo，即在指定目录下创建仓库#执行后会在指定目录下创建repodata目录，里面存放了有关各个rpm的信息#其中repmod.xml存放了各个文件的校验码，用于检查上述文件是否合法，不合法则丢弃cachecreaterepo 目录 配置文件 /etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置 12345#repo文件中的变量$releasever：当前OS的发型版的主版本号$arch：平台$basearch：基础平台$YUM0-9：自定义变量 yum命令1234567891011121314151617181920212223242526272829yum [option] &lt;commands&gt; [args...] repolist &#123;all|enable|disable&#125;：显示仓库列表 list &#123;available|installed|updates&#125;：显示程序包 install package：安装指定包，可以指定具体版本 reinstall package：重新安装 downgrade package：降级 update package：升级指定程序包 check-update：检查可用升级 remove|erase package：卸载程序包，依赖也会被卸载 info package：显示指定package详细信息 provides|whatprovides feature：查看指定特性由哪个程序包提供 clean &#123;package|all|plugins...&#125;：清理本地缓存 makecache：生成缓存 search string：根据关键字模糊搜索程序包名和summary信息 deplist package：显示指定包的依赖关系 history：查看安装、卸载等信息 groupinstall group：安装包组 groupupdate group：更新包组 grouplist：查询所有包组信息 groupinfo group：查询指定包组信息 groupremove group：删除包组 #命令行选项 --nogpgcheck：禁止进行gpgcheck -y：自动回答yes -q：静默模式 --disablerepo=repoidglob：临时禁用指定的repo --enablerepo=repoidglob：临时启用指定的repo --noplugins：禁用所有插件 安装脚本rpm包可以自带安装脚本，主要分为四类： preinstall：安装之前执行的脚本，用%pre定义，用–nopre取消 postinstall：安装之后执行的脚本，用%post定义，用–nopost取消 preuninstall：卸载真正执行前执行的脚本，用%preun定义，用–nopreun取消 postuninstall：卸载完成后执行的脚本，用%postun定义，用–nopostun取消 完整性验证数字签名的含义是指制作者首先用单向加密算法对数据进行加密并得到特征码，然后使用自己的私钥对特征码进行加密，这样别人只能使用制作者的公钥才能对文件解密，然后再使用相同的单向加密算法计算特征码，相同则文件没有问题。 12345#获取并导入信任的包制作者密钥，centos发行版的密钥通常保存在/etc/pki/rpm-gpg/目录下rpm --import /etc/pki/rpm-gpg/#不安装直接检查完整性与合法性rpm -K package 数据库重建rpm数据库放在/var/lib/rpm/下，其中存放各个包的信息。 1234#使用rpmdb命令，本身还是rpmrpm &#123;--initdb|--rebuilddb&#125; [-v] [--dbpath DIRECTORY] [--root DIRECTORY] --initdb：初始化数据库，若没有数据库则创建一个新的 --rebuilddb：重新构建数据库，构建后的数据库没有rpm事务文件，即__db.001等文件 程序包编译安装形如testname-version-release.src.rpm的包成为源程序包，需要使用rpmbuild命令制作成二进制格式的rpm包后再进行安装。 组织格式源代码一般由多个文件组成，且文件中的代码之间很有可能存在跨文件的依赖关系。因此需要使用make来管理源代码的编译。 编译安装步骤 ./configure 通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户指定的Makefile.in文件生成makefile 检查各指定功能依赖到的外部环境 一般由autoconf系列命令根据开发者的需要生成configure脚本；由automake系列命令根据用户需要生成Makefile.in文件(一般源代码文件都会提供) 1234#configure脚本，一般可以指定安装位置、指定启用的特性 --help：获取帮助 --prefix=path：指明默认安装位置，默认为/usr/local/ --sysconfdir=path：指明配置文件安装位置 make 根据makefile文件构建应用程序 make install 导出二进制程序至PATH环境变量中。即编辑文件/etc/profile.d/name.sh添加export PATH=$PATH:/yourpath 导出库文件路径。即编辑/etc/ld.so.conf.d/name.conf，添加新的库文件所在目录至此文件中。之后使用ldconfig命令让系统重新生成缓存 导出头文件。可以导出整个目录的符号链接到/usr/include/目录下即可。 导出帮助手册。编辑/etc/man.conf，添加一条MANPATH路径即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"rpm","slug":"rpm","permalink":"http://yoursite.com/tags/rpm/"},{"name":"yum","slug":"yum","permalink":"http://yoursite.com/tags/yum/"},{"name":"dnf","slug":"dnf","permalink":"http://yoursite.com/tags/dnf/"}],"author":"Frdqy"},{"title":"任务计划crontab","slug":"任务计划crontab","date":"2020-01-02T14:21:35.000Z","updated":"2020-01-02T14:26:20.789Z","comments":true,"path":"2020/01/02/任务计划crontab/","link":"","permalink":"http://yoursite.com/2020/01/02/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab/","excerpt":"概念用于设定系统定时处理某件事情的功能，例如设定数据库定时备份等。","text":"概念用于设定系统定时处理某件事情的功能，例如设定数据库定时备份等。 工具at、batch、crontab 其中at和batch是在未来的某个时间点执行一次任务，crontab是周期性的运行某任务 上述命令的执行结果会通过邮件发送给用户。这里说的邮件是本机邮件，不是互联网邮件。 at在未来某个时间点执行一次某个任务 1234567891011at [option] time -l：查看已有的任务 -f file：从file中读取作业内容，不用交互输入 -d #：删除指明作业号的作业 -c #：查看指定作业号的具体内容 -q QUEUE：指明任务执行队列，默认队列为a#运行结果以邮件方式发给提交作业的用户#时间格式为：HH:MM[YYYY-mm-dd]#模糊时间表示：noon、midnight、teatime、tomorrow#相对时间表示：now+#mins/hours/days/weeks crontab实现周期性执行某任务。需要服务程序来监控，该服务为cronle，提供了crond守护进程及相关辅助工具 12345678#注意：如果拒绝接收邮件可以用command &gt; /dev/null，还会接收错误输出#若使用command &amp;&gt; /dev/null则连错误输出也过滤掉，不推荐crontab [option] -e：编辑任务；可用于删除单个任务 -l：列出所有任务 -r：移除所有任务；即删除/var/spool/cron/下的用户文件 -i：交互式 -u user：root用户用于管理其他用户的任务，与其他命令组合使用 系统cron任务主要用于实现系统自身的维护，编辑时直接手动编辑配置文件/etc/crontab 1234567891011121314151617#cat /etc/crontab#注意：每一行定义一个周期任务；命令建议使用绝对路径；执行结果发送给MAILTO指定的用户；共7个字段[root@localhost ~]# cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 用户cron任务使用命令crontab编辑任务 12345678910111213141516171819#确保crond运行systemctl status crond.service#定义于/var/spool/cron/username中，只能用命令crontab修改，且只有6个字段(无用户名)#注意：每一行定义一个周期任务；命令建议使用绝对路径；结果发给定义文件的用户SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 注意 *表示“每…执行一次”； 在时间点上使用逗号分隔的多个值可以表示多个时间实现离散取值 在时间点上使用#-#表示连续时间取值； 可以在指定时间上定义步长*/#，#就是步长，且步长需要能整除时间； 最小单位为分钟，不能完成秒级任务(可以通过脚本每分钟循环实现) 实例 3 * * * *：每小时执行一次；每小时的第3分钟执行 3 4 * * 5：每周执行一次；每周5的4点3分执行 5 6 7 * *：每月执行一次；每月的7号的6点5分执行 7 8 9 10 *：每年执行一次；每年10月9号8点7分执行 9 8 * * 3,7：每周3和周日执行一次 0 8,20 * * 3,7：每周3和周日的8点和20点执行一次，注意前面的min位必须指定，否则每分钟都执行 0 9-18 * * 1-5：周1到周5的9点到18点每小时执行一次 */5 * * * *：每5分钟执行一次 本地电子邮件服务smtpsimple mail transmission protocol，简单邮件投递服务，只能发邮件不能收邮件 pop3post office protocol，邮局协议，用于接收邮件 mail命令1234mail [-s 'SUBJECT'] 用户 &lt; 邮件正文#邮件正文一般用输入重定向即可#注意，初次实验可能对面没有收到，因为配置文件/etc/postfix/main.cf文件中的inet_interfaces = all一开始没有设置成all而是localhost，修改后即可正常发送。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"定时任务","slug":"定时任务","permalink":"http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}],"author":"Frdqy"},{"title":"压缩与归档","slug":"压缩与归档","date":"2020-01-02T14:20:58.000Z","updated":"2020-01-05T05:48:16.831Z","comments":true,"path":"2020/01/02/压缩与归档/","link":"","permalink":"http://yoursite.com/2020/01/02/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%BD%92%E6%A1%A3/","excerpt":"目的CPU时间换磁盘空间","text":"目的CPU时间换磁盘空间 压缩工具compress/uncompress .z gzip/gunzip .gz bzip2/bunzip2 .bz2 xz/unxz .xz 上述工具不支持压缩目录，要压缩目录需要先归档。 gzip123456789#压缩文件并删除源文件gzip [option] file -d：解压缩，相当于gunzip -#：指定压缩比，默认6，数字越大压缩比越大(1-9) -c：将压缩结果输出至标准输出例如：gzip -c file &gt; file.gz#解压缩文件，结尾必须是.gz结尾gunzip [option] file.gz#不解压直接查看压缩文件zcat file.gz bzip2123456bizip2 [option] file -d：解压缩，相当于bunzip -#：指定压缩比，默认为6，数字越大压缩比越大(1-9) -k：保留源文件#不解压直接查看压缩文件bzcat file.bz xz/unxz123456xz [option] file -d：解压缩 -#：指定压缩比，默认为6，数字越大压缩比越大(1-9) -k：保留源文件#不解压直接查看压缩文件xzcat file.xz 归档工具用于将目录内所有文件都归档成一个文件再指行压缩 tar12345678910111213141516171819202122tar [option] file -c：创建归档 -x：展开归档 -t：查看归档文件列表，不展开归档 -f path：指明要归档的文件目录 -C path：指明归档文件展开到何处 -z：使用gizp2压缩/解压缩 -j：使用bzip2压缩/解压缩 -J：使用xz压缩/解压缩 -v：显示压缩详细信息 -A：新增文件到已压缩文件中 #常用搭配#使用gzip压缩和解压缩目录文件tar zcvf 保存文件.tar.gz ./test/tar zxvf 保存文件.tar.gz ./test/#使用bzip2压缩和解压缩目录文件tar jcvf 保存文件.tar.bz ./test/tar jxvf 保存文件.tar.bz ./test/#使用xz压缩和解压缩目录文件tar Jcvf 保存文件.tar.xz ./test/tar Jxvf 保存文件.tar.xz ./test/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"tar","slug":"tar","permalink":"http://yoursite.com/tags/tar/"},{"name":"压缩","slug":"压缩","permalink":"http://yoursite.com/tags/%E5%8E%8B%E7%BC%A9/"}],"author":"Frdqy"},{"title":"磁盘管理与文件系统","slug":"磁盘管理与文件系统","date":"2020-01-02T14:20:26.000Z","updated":"2020-01-02T14:25:47.253Z","comments":true,"path":"2020/01/02/磁盘管理与文件系统/","link":"","permalink":"http://yoursite.com/2020/01/02/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"设备类型块随机访问，数据交换单位是块 字符线性访问，数据交换单位是字符","text":"设备类型块随机访问，数据交换单位是块 字符线性访问，数据交换单位是字符 设备文件关联至设备的驱动程序；设备的访问入口 命名12/dev/sd[a-z]##其中\"#\"表示任意数字 设备号 major：主设备号，区分设备类型，用于标明设备所需要的驱动程序 minor：次设备号，区分同种设备类型下的不同设备，是特定设备的访问路口 mknod命令123#用于创建块或字符设备mknod [OPTION]... NAME TYPE [MAJOR MINOR] -m MODE:创建后的设备文件的访问权限 引用方式 设备文件名 卷标 UUID 磁盘分区MBR主引导记录，处于0号扇区(每个扇区512B)。 组成部分 446B：bootloader程序，是引导启动操作系统的程序 64B：分区表，每16B标识一个分区，一共只能有4个分区，其中第四个分区使用拓展分区即可超过4个分区的限制 2B：MBR区域的有效性标识，一般为55AA GPT待补充 fdisk命令12345678910111213#用于管理磁盘分区fdisk [options] device#fdisk /dev/dev_name后将进入交互式管理接口#交互常用命令 n:创建新分区 d:删除已有分区 t:修改分区类型 l:查看已有id w:保存修改到磁盘 q:不保存直接退出 m:查看帮助信息 p:显示现有分区信息 注意：在已经分区且已经挂载其中某个分区的磁盘上创建新的分区，内核可能在创建完成后无法直接识别，使用以下命令解决 12345678#查看内核分区cat /proc/partitions#通知内核强制重读磁盘分区CentOS 5：partprobe [device]CentOS 6/7： partx -a [device] kpartx -af [device] 文件系统格式化低级格式化分区之前进行，主要划分磁道 高级格式化分区之后对分区进行，主要是创建文件系统 元数据元数据主要是文件的属性例如大小、权限、时间戳、数据块指针等信息的存放区域(不包括文件名)，一般一个文件的元数据叫做一个inode(index node)索引节点，在创建操作系统时就已经分配了一段区域作为元数据的存储区域。另外，元数据区域包括一个位图，用于标识inode节点的分配情况。 123456789101112131415#文件前的编号即为inode编号[root@localhost ~]# ls -i 34214878 anaconda-ks.cfg 34214891 initial-setup-ks.cfg#stat命令查看具体文件的inode信息[root@localhost ~]# stat ./anaconda-ks.cfg File: ./anaconda-ks.cfg Size: 1467 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 34214878 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2019-12-23 08:02:55.976905697 -0500Modify: 2019-12-23 07:16:53.042026882 -0500Change: 2019-12-23 07:16:53.042026882 -0500 Birth: - 目录目录本身也是文件，他所在的块存贮的是他的一级目录下的文件名和对于的inode映射。因此在每次查找路径时都会先查找/的inode，然后查找/的块，从/的块中的映射查找需要的文件再依次查找下去，直到找到目标文件。 12345#free查看内存看出cache占用，里面存储的就包含路径的缓存，用于加快查找映射[root@localhost ~]# free total used free shared buff/cache availableMem: 817272 522836 91996 1804 202440 140784Swap: 2097148 216064 1881084 VFS虚拟文件系统，是一个中间层，用于将各种文件系统的差异性屏蔽而向上层统一输出一个接口。 Linux文件系统：ext2~4、xfs、btrfs等 网络文件系统：nfs、cifs等 集群文件系统：gfs2、ocfs2等 内核级分布式文件系统：ceph等 伪文件系统：proc、sysfs、tmpfs等 交换文件系统：swap等 用户空间分布式文件系统：mogiles、moosefs等 管理工具创建文件系统工具mkfs：它包括一系列指令，如mkfs.ext2、mkfs.ext3、mkfs.xfs等 12345678910#ext系列专用管理工具mke2fs [option] device -t &#123;ext2|3|4&#125;：指明文件系统类型 -b &#123;1024|2048|4096&#125;：指明文件系统的块大小 -L LABLE：指明卷标 -j：创建有日志的文件系统 -i #：指明inode的比率，即每多少字节创建一个inode -N #：直接指明要给此文件系统创建的inode数量 -O [^]feature：以指定的特性创建文件系统(或取消某种特性) -m #：指定预留空间百分比，直接根数字即可 检测及修复文件系统工具fsck：它包括一系列指令，如fsck.ext2、fsck.ext3、fsck.xfs等 12345678910#e2fsck用于检查ext系列文件系统e2fsck [option] device -y：对所有问题自动回复yes -f：即使文件系统clean也要强制检测 #fsck用于通用的linux文件系统检查fsck -t type：指明文件系统类型 -a：无须交互而自动修复所有错误 -r：交互式修复(推荐) 查看管理属性工具dumpe2fs、tune2fs、blkid、e2label 1234567891011121314151617181920212223#e2label用于查看与设置ext系列的卷标e2label devicee2label device LABEL#blkid打印块属性blkid [option] device -L LABEL；根据LABEL定位设备 -U UUID：根据UUID定位设备 #tune2fs用于调整ext系列系统中可调整的参数，例如卷标和系统类型等tune2fs [option] device -l：查看超级块信息 -j：将ext2升级为ext3 -L LABEL：修改卷标 -m #：修改预留空间百分比，直接跟数字即可 -O [^]feature：开启或关闭某种特性 -o [^]mount_option：开启或关闭某种默认挂载选项，常用设置acl #dumpe2fs用于显示文件系统属性信息，包括每个块组和超级块信息dumpe2fs [option] device#修改ext系列文件系统的大小，主要用于扩展lv后扩展文件系统使用resize2fs lvname 日志主要是解决当写文件发生错误导致系统重启后恢复哪些文件而设置的机制。在磁盘上会单独分一块日志区，写文件时先写在日志区，然后再写回文件系统中。虽然会有性能损失，但是利大于弊。 文件操作删除文件将此文件指向的所有数据块标记为未使用状态并将此文件的inode标记为未使用，即只修改inode位图和数据块位图即可，因此速度很快。 移动文件当处于同一文件系统时，移动文件仅仅是改变其路径。即将当前目录的条目移到另一目录即可，文件本身并不做改变。 当处于不同文件系统时，移动文件相当于复制数据至目标文件并删除源文件，因此比较慢。 链接文件硬链接指向同一inode的不同路径 其中目录不支持硬链接；硬链接不能跨文件系统；创建硬链接会增加inode引用计数；硬链接大小相同 1234567891011121314151617181920212223#硬链接inode相同[root@localhost ~]# ls -i34214878 anaconda-ks.cfg 34214891 initial-setup-ks.cfg34214878 anaconda-ks.cfg_bak 34214894 test#第二列的“1”就是引用计数[root@localhost ~]# ls -ltotal 8-rw-------. 1 root root 1467 Dec 23 07:16 anaconda-ks.cfg-rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg#创建一个硬链接，可以看到引用计数加1#删除一个硬链接不影响另一个[root@localhost ~]# ln anaconda-ks.cfg anaconda-ks.cfg_bak[root@localhost ~]# ls -ltotal 12-rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg-rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg_bak-rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg#不能链接目录[root@localhost ~]# ln test test_1ln: test: hard link not allowed for directory 符号链接inode数据保存的指针区域保存的不是指向磁盘块的指针，而是指向那个真正文件的路径 其中，符号链接和文件是两个独立的文件，他们有各自的inode；可以对目录进行符号链接，且可以跨文件系统；删除符号链接不影响源文件，但是删除源文件影响符号链接；符号链接大小为路径字符串长度。 符号链接本身权限是777，因为用户对符号链接的访问本质还是要看源文件的权限。 123456789101112131415161718#可以看到符号链接的文件inode与硬链接和源文件不同#且源文件和符号链接的引用计数也不同，源文件引用计数不变[root@localhost ~]# ln -s anaconda-ks.cfg anaconda-ks.cfg_symbolic[root@localhost ~]# ls -litotal 1234214878 -rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg34214878 -rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg_bak34214895 lrwxrwxrwx. 1 root root 15 Jan 1 06:15 anaconda-ks.cfg_symbolic -&gt; anaconda-ks.cfg34214891 -rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg34214894 drwxr-xr-x. 2 root root 6 Jan 1 06:09 test#可以对目录进行符号链接[root@localhost ~]# ln -s test test_symbolic[root@localhost ~]# ls -li test*34214899 lrwxrwxrwx. 1 root root 4 Jan 1 06:17 test_symbolic -&gt; testtest:total 0 swap交换分区Linux上的交换分区必须使用独立的文件系统，且文件系统的system_ID必须为82 创建swap分区123mkswap [option] device -L：指明卷标 -f：强制创建 启用swap12swapon [option] device -a：启用定义在/etc/fstab文件中的所有swap设备 禁用swap1swapoff device 挂载根文件系统以外的其他文件系统想要被访问就必须先关联到根文件系统上的某个目录来实现，这个关联操作称为“挂载”，挂载目录成为”挂载点“，即用于另一个文件系统的访问入口。 此外，挂载点必须实现存在；应该使用不会被或未被其他进程使用的目录；挂载点下原有的文件会被隐藏 mount使用1234567891011121314151617181920212223242526272829303132333435#mount实现挂载mount [-fnrsvw] [-t fstype] [-o options] device dir -a：自动挂载 -r：只读挂载 -w：读写挂载 -n：默认情况下，挂载卸载会同步更新到/etc/mtab中，该选项用于禁止该功能 -t：指明挂载文件系统类型，可省略，默认通过blkid识别 -L LABEL：挂载时以卷标的方式指明设备 -U UUID：挂载时以UUID方式指明设 -o options挂载选项 sync/async：同步/异步操作 atime/noatime：文件在被访问时是否更新其访问时间戳，不启用更好 diratime/nodiratime：同上，对目录操作 remount：重新挂载，不用卸载再挂载 acl：支持使用facl ro：只读类似-r rw：读写类似-w dev/nodev：此设备上是否允许创建设备文件 exec/noexec：是否允许运行此设备上的程序文件 auto/noauto：是否允许自动挂载 user/nouser：是否允许普通用户挂载 suid/nosuid：是否允许suid和sgid特殊权限生效 defaults：rw, suid, dev, exec, auto, nouser, and async --bind 源目录 目标目录：实现目录的绑定，用作某目录临时入口 #查看当前已挂载设备mountcat /etc/mtabcat /proc/mounts#挂载光盘mount -r /dev/cdrom mount_point#挂载本地回环设备(iso等映像)mount -o loop 回环设备 mount_point umount使用123456789#umount实现卸载umount [-dflnrv] &#123;directory|device&#125;#正在被访问时无法卸载,查看被谁访问使用lsof mount_pointfuser -v mount_point#终止所有访问挂载点的进程fuser -km mount_point fstab用于定义开机自动挂载的目录。其每行定义一个要挂载的文件系统及其相关属性 属性从左自右分别为：挂载设备、挂载点、文件系统类型、挂载选项、转储频率、自检次序 挂载设备：LAEBL、UUID、伪文件系统均可 挂载选项：defaults表示默认选项，若自定义多个选项，则每个选项之间使用”，“分隔 转储频率：0表示不备份；1表示每天备份、2表示每隔一天备份 自检次序：0表示不自检；1表示首先自检，通常为根文件系统；2.3.4….依次自检 其余命令df12345#显示文件系统使用情况df [option] -l：仅显示本地文件的相关信息 -h：以人可读的形式显示，即单位换算 -i：显示inode使用状态 du1234#显示文件使用情况而非文件系统du [option] file -h：以人可读的形式显示，即单位换算 -s：显示目录下所有文件的大小总和 dd1234567891011121314#底层的复制工具#表示从path1复制文件到path2dd if=/path1 of=/path2 bs=#：表示复制单元大小 count=#：表示复制多少个bs #备份MBRdd if=/dev/sda of=/tmp/mbr.bck bs=512 count=1#破坏MBR的bootloaderdd if=/dev/zero of=/dev/sda bs=256 count=1#特殊设备/dev/null/dev/zero","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"磁盘管理","slug":"磁盘管理","permalink":"http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"},{"name":"文件系统","slug":"文件系统","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"author":"Frdqy"},{"title":"LVM2","slug":"LVM2","date":"2020-01-02T14:19:49.000Z","updated":"2020-01-03T11:43:14.672Z","comments":true,"path":"2020/01/02/LVM2/","link":"","permalink":"http://yoursite.com/2020/01/02/LVM2/","excerpt":"概念Logical Volume Manager，逻辑卷管理器。在硬盘之上创建一个逻辑层用于管理硬盘分区系统。主要用于实现文件系统的动态增加与减少，类似于btrfs的动态扩展和收缩。","text":"概念Logical Volume Manager，逻辑卷管理器。在硬盘之上创建一个逻辑层用于管理硬盘分区系统。主要用于实现文件系统的动态增加与减少，类似于btrfs的动态扩展和收缩。 术语PVphysical volume 在物理层面组成的磁盘卷，是在硬件磁盘分区基础上加上了lVM相关的管理参数，可以理解为对硬盘的划分，与分区类似。PV可以是一个磁盘也可以是一个分区。 VGvolume group 将多个PV组合而成抽象出的一个逻辑卷组，用以对外提供PE(physical extend)，即PV在逻辑上组合成VG后再经过逻辑划分成PE来使用。 PEphysical extend 在VG里划分的对外提供的块，一般为M单位大小。 LVlogical volume 由多个PE组成的逻辑卷，对LV可以进行挂载和建立文件系统操作。此时可以通过增加或删除PE实现文件系统的动态增加与减少。 管理工具PV管理工具123456#简要pv信息显示pvs#显示pv详细信息pvdisplay device#创建pv。新创建的pv没有加入VG，所以不知道PE大小pvcreate device VG管理工具123456789101112#简要vg信息显示vgs#显示vg详细信息vgdisplay#创建vg，其中device必须是已被创建的pvvgcreate [option] vgname device#扩展vg，device必须是已创建的pvvgextend vgname device#缩减vg，device必须是已创建的pv，且删除前要使用pvmove移走pv中的数据到同一vg的其他pv上vgreduce vgname device#删除vgvgremove vgname LV管理工具123456789101112131415161718#简要lv信息显示lvs#显示lv详细信息lvdisplay#创建lvlvcreate [option] lvname vgname -L：指明卷大小 -n：指明卷名称#扩展逻辑卷#注意：修改逻辑卷后要修改文件系统大小resize2fs lvnamelvextend [option] lvnam -L：指明目标大小#缩减逻辑卷#注意：缩减逻辑卷前要先卸载逻辑卷，然后做文件系统强制检测修复fsck -f lvname，之后修改文件系统大小resize2fs lvname 大小，最后再挂载即可lvreduce [option] lvname -L：指明目标大小#逻辑卷删除lvremove lvname 快照快照是LVM提供对lv上文件系统做备份的一个功能。快照也是一个或多个逻辑卷区域，只是文件类型与正常文件不同而已。快照使用写时复制，本质是一个指向要备份数据的inode的硬链接，当没有数据改变时快照和目标数据相同。当目标数据发生变化时，会把要修改的文件先拷贝到快照区域，然后再修改需要修改的目标文件，这样快照里保存的就是未修改前的文件了，这方便备份与还原。 1234567#创建快照#-p r：指明只读lvcreate -L 大小 -p r -s snapshot_name original_lv_name#利用lvconvert合并快照与源数据#注意：合并前源数据和快照都需要卸载才可以合并，且合并结束后会自动删除快照lvconvert --merge original_lv_name","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"lvm","slug":"lvm","permalink":"http://yoursite.com/tags/lvm/"}],"author":"Frdqy"},{"title":"RAID","slug":"RAID","date":"2020-01-02T14:19:14.000Z","updated":"2020-01-03T11:45:30.396Z","comments":true,"path":"2020/01/02/RAID/","link":"","permalink":"http://yoursite.com/2020/01/02/RAID/","excerpt":"概念Redundant Arrays Of Independent Disks，独立磁盘冗余阵列","text":"概念Redundant Arrays Of Independent Disks，独立磁盘冗余阵列 级别RAID-0概念条带卷(stripe) 将要存储的数据分块然后并行存储到RAID的不同的磁盘下叫做条带。 特点 读、写性能提升 可用空间：N*min(S1,S2…) 无容错能力 最小磁盘数：2,2+ RAID-1概念镜像卷(mirror) 将要存储的数据分块然后在RAID的每个磁盘上都存储一份，即镜像。 特点 读性能提升，写性能下降 可用空间：1*min(S1,S2…) 有冗余能力 最小磁盘数：2,2+ RAID-5概念使用异或校验的形式且校验码依次存储在每个磁盘上，即每个磁盘轮流当校验码，目前主要以左对称为主 特点 读写性能提升 可用空间：(N-1)*min(S1,S2…) 用冗余能力，最多坏一块 最小磁盘数：3,3+ RAID-6概念在RAID-5基础上增加一块校验盘 特点 读写性能提升 可用空间：(N-2)*min(S1,S2…) 有冗余能力，最多坏2块 最少磁盘数：4,4+ RAID-10概念先两两做成RAID-1再做成RAID-0。存储时先按RAID-0条带后再镜像存储到RAID-1中。 特点 读写性能提升 可用空间：N*(S1,S2…)/2 有冗余能力，每组镜像最多只能坏一块 RAID-01概念先两两做成RAID-0再做成RAID-1。存储时先按RAID-1镜像后再条带到RAID-0中。 特点 读写性能提升 可用空间：N*(S1,S2…)/2 有冗余能力，每组镜像最多只能坏一块 JBODJust a Bunch Of Disks 功能：将多块磁盘空间合并一个大的连续空间使用，可用空间一般为磁盘容量总和","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"raid","slug":"raid","permalink":"http://yoursite.com/tags/raid/"}],"author":"Frdqy"},{"title":"文件特殊权限","slug":"文件特殊权限","date":"2020-01-01T11:23:25.000Z","updated":"2020-01-01T11:55:55.319Z","comments":true,"path":"2020/01/01/文件特殊权限/","link":"","permalink":"http://yoursite.com/2020/01/01/%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/","excerpt":"文件特殊权限SUID、SGID、STICKY","text":"文件特殊权限SUID、SGID、STICKY 安全上下文 进程以某用户的身份运行：进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作 权限匹配模型： 判断进程的属主是否为被访问文件的属主 ，如果是则使用属主权限访问，否则进入2 判断进程的属主是否属于被访问文件的属组，如果是就使用属组权限，否则进入3 应用other模型 SUID默认情况下用户发起的进程其属主是其发起者。而设置SUID的进程执行时，其属主为进程自己的属主。 1234567891011121314151617181920#/etc/shadow无访问权限[frdqy@localhost ~]$ ls -l /etc/shadow----------. 1 root root 1434 Dec 31 22:26 /etc/shadow#以frdqy身份无法访问/etc/shadow，因为此时以使用cat的发起者权限来访问/etc/shadow，即other[frdqy@localhost ~]$ cat /etc/shadowcat: /etc/shadow: Permission denied#此时cat并没有设置SUID权限[frdqy@localhost ~]$ ls -l /bin/cat-rwxr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#用root给cat设置SUID权限后[root@localhost frdqy]# chmod u+s /bin/cat[root@localhost frdqy]# ls -l /bin/cat-rwsr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#frdqy用户即可用cat查看/etc/shadow内容，因为此时cat进程使用的是其属主root权限，而不是进程的发起者[frdqy@localhost ~]$ cat /etc/shadowroot:$6$RsZ/8mPpOXX17jO8$yeL/BOfROjigWhsFEEwvF6ZDe3ldr/FJX9vvQFtzJCIWZngO5RhjLVRRgAeSg13ymfLWELIyl5R.sTBbGtP390::0:99999:7::: 注意： 如果进程属主原本有执行权限，那么加了SUID后就变成s；如果进程属主原本没有执行权限，那么加SUID后就变成S。 SGID通常对目录设置，这样其他用户在该目录下创建文件时，文件的属组全都是目录的属组，主要为了方便同组用户的修改。 1chmod g+|g- /dir STICKY用于解决某一目录下每个用户都可以删除同组其他用户的文件问题，在该目录上设置STICKY后用户只能新建和删除自己的文件，不能删除同组其他用户的文件。 12chmod o+t|o-t /dir#/tmp和/var/tmp默认具有STICKY权限 FACLfacl是文件的额外赋权机制，在原来的ugo之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制 getfacl1234getfacl fileuser:USERNAME:MODEgroup:GROUPNAME:MODE#若username为空则为属主的权限，若groupname为空则为默认属组的权限 setfacl1234567#赋权给用户setfacl -m u:USERNAME:MODE file#赋权给组setfacl -m g:GROUPNAME:MODE file#撤销赋权setfacl -x u:USERNAME:MODE filesetfacl -x g:GROUPNAME:MODE file 访问控制顺序首先，检查进程属主与被访问文件属主是否相同，相同则使用属主权限；否则检查被访问文件是否定义关于该用户的访问控制链表(facl)，有则应用该访问链表权限；否则检查此进程的属主是否是被访问文件的属组，是则应用属组访问权限，否则检查访问控制链表是否有该用属组的定义，若有则应用该属组权限。最后还不匹配就按other访问。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"}],"author":"Frdqy"},{"title":"Shell编程之（七）：脚本实战","slug":"Shell编程之（七）：脚本实战","date":"2019-12-31T08:27:45.000Z","updated":"2019-12-31T08:28:45.979Z","comments":true,"path":"2019/12/31/Shell编程之（七）：脚本实战/","link":"","permalink":"http://yoursite.com/2019/12/31/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98/","excerpt":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态","text":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态 拆分脚本功能app_statuesfunction get_all_process123456789101112#返回进程名称列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125; function get_all_group1234567891011121314#返回进程租列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_group&#123; if [ ! -e $HOME_DIR/$CONFIG_FILE ];then echo \"$CONFIG_FILE is not exit.\" exit 1 else G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $G_LIST fi&#125; function get_process_pid_by_name12345678910#参数为进程pid根据进程名称查pidfunction get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $0 | awk '&#123;print $2&#125;'` echo $pids fi&#125; function get_process_info_by_pid1234567891011121314#参数为pid，根据pid查询进程状#详细信息包括：运行状态，PID，MEM信息，CPU信息，时间信息#此处不能根据进程名查，会有很多无关信息function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 \"$2==pid&#123;print &#125;\" | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $3&#125;\"` pro_mem=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $4&#125;\"` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125; function is_group_in_config1234567891011121314#参数为group，判断group是否在config中# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125; function get_all_process_group1234567891011#参数为group，根据group获取processfunction get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125; function get_group_by_process12345678910111213#根据进程获取组名，参数为processfunction get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125; function format_print12345678910111213#接收两个参数，第一个为process，第二个为groupfunction format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_status=$pro_stat_time -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=$pro_stat_time 'BEGIN&#123;printf \"%-10s%-10s%-5s%-5s%-5s%-5s%-15s\\n\",p_name,g_name,p_status,p_cpu,p_mem,p_start_time&#125;' done fi &#125; function is_process_in_config123456789101112#参数为process#坑点：此处一开始将return1写在循环里导致直接跳出function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125; 主函数流程 无参数 列出配置文件中所有经常的运行信息 -g GroupName 列出GroupName组内的所有进程 process_name1 列出指定进程的运行信息 代码实现1234567891011121314151617181920212223242526if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/bin/bash## Func:Get process statues in process.cfg# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"this_pid=$$function get_all_group&#123; G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE| egrep -v \"(^$|^\\[)\"` echo $G_LIST&#125;function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125;function get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $this_pid | awk '&#123;print $2&#125;'` echo $pids fi&#125;function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 '$2==pid&#123;print&#125;' | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 '$2==pid&#123;print $3&#125;'` pro_mem=`ps aux | awk -v pid=$1 '$2==pid&#123;print $4&#125;'` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125;function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125;function get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125;function get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125;function format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_id=$pid -v p_status=$proc_statues -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=\"$pro_stat_time\" 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,p_id,p_status,p_cpu,p_mem,p_start_time&#125;' done else awk -v p_name=$1 -v g_name=$2 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,\"NULL\",\"NULL\",\"NULL\",\"NULL\",\"NULL\"&#125;' fi &#125;function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125;if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 小结至此，shell编程的专项学习告一段落，下面的练习都将在学习其他知识时进行巩固。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（六）：mysql","slug":"Shell编程之（六）：mysql","date":"2019-12-30T07:54:12.000Z","updated":"2019-12-30T07:57:06.178Z","comments":true,"path":"2019/12/30/Shell编程之（六）：mysql/","link":"","permalink":"http://yoursite.com/2019/12/30/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Amysql/","excerpt":"安装mariadb1sudo apt-get install mariadb-server","text":"安装mariadb1sudo apt-get install mariadb-server 测试实例建表脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--student.sql--create tables--student tablescreate table &#96;student&#96;( &#96;s_id&#96; varchar(20), &#96;s_name&#96; varchar(20) not null default &#39;&#39;, &#96;s_birth&#96; varchar(20)not null default &#39;&#39;, &#96;s_sex&#96; varchar(20) not null default &#39;&#39;, primary key(&#96;s_id&#96;));--course tablescreate table &#96;course&#96;( &#96;c_id&#96; varchar(20), &#96;c_name&#96; varchar(20)not null default &#39;&#39;, &#96;t_id&#96; varchar(20) not null, primary key(&#96;c_id&#96;));--teacher tablecreate table &#96;teacher&#96;( &#96;t_id&#96; varchar(20), &#96;t_name&#96; varchar(20)not null default &#39;&#39;, primary key(&#96;t_id&#96;));--score tablecreate table &#96;score&#96;( &#96;s_id&#96; varchar(20), &#96;c_id&#96; varchar(20), &#96;s_score&#96; int(3), primary key(&#96;s_id&#96;,&#96;c_id&#96;));--insert student tableinsert into student values(&#39;1001&#39;,&#39;zhaolei&#39;,&#39;1990-1001-1001&#39;,&#39;male&#39;);insert into student values(&#39;1002&#39;,&#39;lihang&#39;,&#39;1990-12-21&#39;,&#39;male&#39;);insert into student values(&#39;1003&#39;,&#39;yanwen&#39;,&#39;1990-1005-20&#39;,&#39;male&#39;);insert into student values(&#39;1004&#39;,&#39;hongfei&#39;,&#39;1990-1008-1006&#39;,&#39;male&#39;);insert into student values(&#39;1005&#39;,&#39;ligang&#39;,&#39;1991-12-1001&#39;,&#39;female&#39;);insert into student values(&#39;1006&#39;,&#39;zhousheng&#39;,&#39;1992-1003-1001&#39;,&#39;female&#39;);insert into student values(&#39;1007&#39;,&#39;wangjun&#39;,&#39;1989-1007-1001&#39;,&#39;female&#39;);insert into student values(&#39;1008&#39;,&#39;zhoufei&#39;,&#39;1990-1001-20&#39;,&#39;female&#39;);--insert course tableinsert into teacher values(&#39;1001&#39;,&#39;aidisheng&#39;);insert into teacher values(&#39;1002&#39;,&#39;aiyinsitan&#39;);insert into teacher values(&#39;1003&#39;,&#39;qiansanqiang&#39;);--insert score tableinsert into score values(&#39;1001&#39;,&#39;1001&#39;,80);insert into score values(&#39;1001&#39;,&#39;1002&#39;,90);insert into score values(&#39;1001&#39;,&#39;1003&#39;,99);insert into score values(&#39;1002&#39;,&#39;1001&#39;,70);insert into score values(&#39;1002&#39;,&#39;1002&#39;,60);insert into score values(&#39;1002&#39;,&#39;1003&#39;,80);insert into score values(&#39;1003&#39;,&#39;1001&#39;,80);insert into score values(&#39;1003&#39;,&#39;1002&#39;,80);insert into score values(&#39;1003&#39;,&#39;1003&#39;,50);insert into score values(&#39;1004&#39;,&#39;1001&#39;,20);insert into score values(&#39;1004&#39;,&#39;1002&#39;,30); 建数据库1create database school; 导入数据1mysql school &lt; student.sql 授权用户1234--授予dbuser用户在所有网段都可以对school数据库进行操作，密码为123456grant all on school.* to dbuser@&#39;%&#39; identified by &#39;123456&#39;grant all on school.* to dbuser@&#39;localhost&#39; identified by &#39;123456&#39;--&#39;%&#39;表示所有主机都可以访问 使用授权用户登录12--u和p与参数间可以省略mysql -udbuser -p123456 -h localhost mysql命令参数 命令 含义 -u 用户名 -p 用户密码 -h 服务器ip地址 -D 链接的数数据库 -N 不输出列信息 -B 使用tab键代替默认交互分隔符 -e 执行sql语句 -E 垂直输出 -H 以HTML格式输出 -X 以XML格式输出 注意 -B用来不显示周围一圈分隔符时建议放在选项最后，在-e之前。 查询实例 写一个脚本，该脚本可以接收一个参数，参数为需要执行的sql语句 123#!/bin/bash#mysql -u dbuser -p123456 -D school -e \"$1\" 查询mysql任意表的数据，并将查询到的结果保存到HTML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -H -e \"$1\" &gt; $2 查询mysql任意表的数据，并将查询到的结果保存到XML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -X -e \"$1\" &gt; $2 导入实例需求一处理文本中的数据，将文本中的数据插入mysql ​ 1010 jerry 1991-12-13 male ​ 1011 mike 1991-12-13 female ​ 1012 tracy 1991-12-13 male ​ 1013 kobe 1991-12-13 female ​ 1014 allen 1991-12-13 male ​ 1015 curry 1991-12-13 male ​ 1016 tom 1991-12-13 female 123456789101112#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"cat data.txt | while read id name birth sexdo $mysql_conn -D $database -e \"insert into student1 values('$id','$name','$birth','$sex')\"done 需求二同上，但是分隔符变了 ​ 1010|jerry|1991-12-13|male ​ 1011|mike|1991-12-13|female ​ 1012|tracy|1991-12-13|male ​ 1013|kobe|1991-12-13|female ​ 1014|allen|1991-12-13|male ​ 1015|curry|1991-12-13|male ​ 1016|tom|1991-12-13|female 123456789101112131415#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"#mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"#输入分隔符指定IFS=\"|\"cat data2.txt | while read id name birth sexdo mysql -u \"dbuser\" -p\"$passwd\" -D $database -e \"insert into student2 values('$id','$name','$birth','$sex')\"done 注意需求二有一个坑，在于注释的sql语句那样写在变量里会提示找不到命令，可能时管道符号冲突问题，shll真不规范！！ mysqldump备份语法格式1mysqldump [OPTIONS] database [tables] 命令参数 命令 含义 -u 用户名 -p 密码 -h 服务器IP地址 -d 等价于–no-data，只导出表结构 -t 等价于–no-create-info，只导出数据，不导出建表语句 -A 等价于–all-databases -B 等价于–databases，导出一个或多个数据库 需求将school中的score备份，并且将备份数据通过ftp传输到xxx.xxx.xxx.xxx的/data/backup目录下 补充知识 open xxx.xxx.xxx.xxx：用于打开远端连接 user 用户名 密码：用于登录 -i：不交互 -n：自动登录 -v：显示详细信息 &lt;&lt; EOF：表示下面将输入长命令，直到遇到EOF结束，且EOF最后一行必须顶格写 12345678910111213141516171819202122232425262728#!/bin/bash#db_user=\"dbuser\"db_passwd=\"123456\"ftp_user=\"ftp_user\"ftp_passwd=\"redhat\"ftp_host=\"192.168.184.3\"dst_dir=\"/data/backup\"time_date=\"`date +%Y%m%d%H%M%S`\"file_name=\"school_score_$&#123;time_date&#125;.sql\"function auto_ftp&#123; ftp -niv &lt;&lt; EOF open $ftp_host user $ftp_user $ftp_passwd cd $dst_dir put $1 byeEOF&#125;mysqldump -u\"$db_user\" -p\"$db_passwd\" school score &gt; ./$file_name &amp;&amp; auto_ftp ./$file_name","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"Frdqy"},{"title":"Shell编程之（五）：awk","slug":"Shell编程之（五）：awk","date":"2019-12-29T13:09:12.000Z","updated":"2019-12-30T07:58:27.704Z","comments":true,"path":"2019/12/29/Shell编程之（五）：awk/","link":"","permalink":"http://yoursite.com/2019/12/29/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aawk/","excerpt":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'","text":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' 语法格式说明 语法格式 解释 BEGIN{} 正式处理数据之前执行 pattern 匹配模式 {commands} 处理命令，可能多行 END{} 处理完所有匹配数据后执行 内置变量对照表 内置变量 含义 $0 整行内容 $1-$n 当前行的第1-n个字段 NF(Number Field) 当前行的字段个数 NR(Number Row) 当前行行号，从1开始 FNR(File Number Row) 多文件每个文件行号单独计数，从0开始 FS(Field Separator) 输入字段分隔符，默认空格或tab RS(Row Separator) 输入行分隔符，默认回车换行 OFS(Output Field Separator) 输出字段分隔符，默认空格 ORS(Output Row Separator) 输出行分隔符，默认回车换行 FILENAME 当前输入的文件名字 ARGC 命令行参数个数 ARGV 命令行参数数组 printf详解printf格式说明符 格式符 含义 %s 打印字符串 %d 打印十进制数 %f 打印浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字科学计数法形式 %c 打印单个字符的ASCII printf修饰符 修饰符 含义 - 左对齐 + 右对齐 # 八进制加0，十六进制加0x 格式符实例 以字符串格式打印/etc/passwd中的第7个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以10进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以浮点数进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符，小数点保留2位 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%0.2f\\n\",$3&#125;' /etc/passwd 以16进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#x\\n\",$3&#125;' /etc/passwd 以8进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#o\\n\",$3&#125;' /etc/passwd 以科学技术格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%e\\n\",$3&#125;' /etc/passwd 模式匹配语法格式 语法格式 含义 /RegExp/ 按正则匹配 关系运算 按关系匹配 正则实例 匹配/etc/passwd文件行中包含有root字符串的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/root/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 匹配/etc/passwd文件行中以frdqy开头的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/^frdqy/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 关系实例 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段大于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&gt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7==\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段不为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7!=\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段包含3个以上数字的所有行信息 12awk 'BEGIN&#123;FS=\":\"&#125;$3~/[0-9]&#123;3,&#125;/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd#~表示匹配正则，!~表示不匹配正则 布尔实例 以:为分隔符，匹配/etc/passwd文件中包含root或frdqy的所有 1awk 'BEGIN&#123;FS=\":\"&#125;$1==\"root\" || $1==\"frdqy\"&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50并且第4个字段大于50的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50 &amp;&amp; $4&gt;50&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 动作算术运算符 运算符 含义 + 加 - 减 * 乘 除 / % 模 ^或** 乘方 ++x 返回变量x之前+1 x++ 返回变量x之后+1 x+=y x=x+y 算数实例 使用awk计算/etc/services中空白行的数量 1awk '/^$/&#123;sum++&#125;END&#123;printf \"%d\\n\",sum&#125;' /etc/services 计算下列每个同学的平均分数，将其打印在最后一列后 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 1awk 'BEGIN&#123;FS=\",\"&#125;&#123;sum=$2+$3+$4+$5;avg=sum/(NF-1);printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;' ./student.txt 条件语句123456if(条件表达式) 动作1else if(条件表达式) 动作2else 动作3 条件实例 以:为分隔符，只打印/etc/passwd中第3个字段的数值在50-100范围内的行信息 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;if($3&lt;=100&amp;&amp;$3&gt;=50)print $0&#125;' /etc/passwd 计算下列每个学生的平均分数，并且只打印平均分大于90的学生姓名和分数信息 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 12345678910111213#过长，写在scripts.awk中BEGIN&#123; FS=\",\" &#125;&#123; sum=$2+$3+$4+$5; avg=sum/(NF-1); if(avg&gt;90) printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;#用-f选项调用awk -f ./scripts.awk ./student.txt 循环语句-while12while(条件表达式) 动作 循环语句-do while123do 动作while(条件表达式) 循环语句-for12for(初始化计数器;测试计数器;计数器变更) 动作 循环实例 计算1+2+…+100的和，使用while、do while、for三种实现 1234567891011121314151617181920212223242526272829#whileBEGIN&#123; while(i&lt;=100) &#123; sum+=i; i++; &#125; print sum&#125;#do-whileBEGIN&#123; i=0; do &#123; i++ sum+=i &#125;while(i&lt;100) print sum&#125;#forBEGIN&#123; for(i=0;i&lt;=100;i++) &#123; sum+=i; &#125; print sum&#125; 字符串函数 函数名 解释 函数返回值 length 计算字符串长度 整数长度值 index(str1,str2) 在str1中找str2位置 返回索引，从1开始 tolower(str) 转换为小写 转换后的字符串 toupper(str) 转换为大写 转换后的字符串 substr(str,m,n) 从str的m个字符开始，截取n位 截取后的子串 match(str,RE) 在str中按RE查找 返回索引 split(str,arr,fs) 按fs切割字符串，结果存arr中 切割后的子串个数 sub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换一个 替换个数 gsub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换所有 替换个数 字符串处理实例 以:为分隔符，返回/etc/passwd中每行每个字段的长度 1234567891011121314151617BEGIN&#123; FS=\":\" &#125;&#123; for(i=1;i&lt;=NF;i++) &#123; if(i!=NF) &#123; printf \"%d:\",length($i) &#125; if(i==NF) &#123; printf \"%d\",length($i) printf \"\\n\" &#125; &#125;&#125; 搜索字符串”I have a dream”中出现”ea”字符串的位置 1234567891011#indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125;#match,可见match功能包含了indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为小写 1234BEGIN&#123; str=tolower(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为大写 1234BEGIN&#123; str=toupper(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop Kafka Spark Storm HDFS YARN Zookeeper”分割保存到数组arr中 12345678910BEGIN&#123; str=\"Hadoop Kafka Spark Storm HDFS YARN Zookeeper\" len=split(str,arr,\" \") i=1 while(i&lt;=len) &#123; print arr[i] i++ &#125;&#125; 搜素字符串”Transaction 2345 Start:Select * from master”第一个数字出现的位置 12345BEGIN&#123; str=\"Transaction 2345 Start:Select * from master\" i=match(str,\"[0-9]\") print i&#125; 截取字符串”Transaction start”的子串，截取条件从第4个字符开始，截取5位 12345BEGIN&#123; str=\"Transaction start\" str1=substr(str,4,5) print str1&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中第一个匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" sub(\"[0-9]+\",\"$\",str) print str&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中所有匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" gsub(\"[0-9]+\",\"$\",str) print str&#125; 选项 选项 解释 -v 参数传递 -f 指定脚本文件 -F 指定分隔符 -V 查看awk版本号 注意1234567#在使用参数传递时，引用变量建议全部使用\"\"，否则如果引用的字符串内出现空格则会报错。num=20var=\"Hello World\"#下面命令会报错，原因在于var变量字符串包含空格awk -v num2=$num -v var1=$var 'BEGIN&#123;print num2,var1&#125;'#遇到上述问题需要将引用用\"\"包含起来awk -v \"num2=$num\" -v \"var1=$var\" 'BEGIN&#123;print num2,var1&#125;' 数组shell中数组的用法1234567#定义,各元素用空格或tab分隔array=(\"Allen\" \"Mike\" \"Messi\")#遍历for a in $&#123;array[@]&#125;do echo $adone 命令 含义 echo ${array[2]} 打印元素 echo ${ #array[@]} 打印元素个数 echo ${ #array[3]} 打印元素长度 array[3]=”Li” 数组元素赋值 unset array[2];unset array 删除元素 echo ${array[@]:1:3} 分片访问 ${array[@]/e/E} 替换第一个e为E ${array[@]//e/E} 替换所有的e为E awk中数组的用法既可以数字作为数组下标也可以字符串作为数组下标 12345678910111213141516#检测数组第i+1下标是否存在if i in array#删除某个数组元素delete array[i]#删除整个数组delete array#for循环语法格式1for(初始化; 布尔表达式; 更新) &#123;//代码语句&#125; #for循环语法格式2for(变量 in 数组) &#123;//代码语句&#125; 数组实例 统计主机上所有的TCP连接状态数，按照每个TCP状态分类 1netstat -an | grep tcp | awk '&#123;array[$6]++&#125;END&#123;for(a in array) print a,array[a]&#125;' 计算横向数据总和，计算纵向数据总和 allen 80 90 87 91 mike 78 86 93 96 Kobe 66 92 82 78 Jerry 98 74 66 54 Wang 87 21 100 43 1234567891011121314151617BEGIN&#123; printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Yuwen\",\"Math\",\"English\",\"Physical\",\"total\"&#125;&#123; total=$2+$3+$4+$5 sum+=total i=2 while(i&lt;=NF) &#123; array[i]+=$i i++ &#125; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total&#125;END&#123; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",\"sum_c\",array[2],array[3],array[4],array[5],sum&#125; 实战演练模拟脚本123456789101112131415161718192021222324#!/bin/bash#数据生成脚本，模拟大型数据function create_random&#123; min=$1 max=$(($2-$min+1)) num=`date +%s%N` echo $(($num%$max+$min))&#125;INDEX=1while truedo for user in allen mike jerry tracy han lilei do COUNT=$RANDOM NUM1=`create_random 1 $COUNT` NUM2=`expr $COUNT - $NUM1` echo \"`date '+%Y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into database:product table:detal, insert $NUM1 records successfully,failed $NUM2 records\" &gt;&gt; ./db.log.`date +%Y%m%d` INDEX=`expr $INDEX + 1` donedone 需求及解决方案 统计每个人分别插入多少条record进数据库 1234567&#123; array[$6]+=$8&#125;END&#123; for (i in array) printf \"%-10s%-10d\\n\",i,array[i]&#125; 统计每个人分别插入成功多少record，失败多少record 12345678910&#123; array[$6]+=$14 array1[$6]+=$17&#125;END&#123; for (i in array) printf \"%-10s %-10d successed!\\n\",i,array[i] for (j in array1) printf \"%-10s %-10d Failed!\\n\",j,array[j]&#125; 将1和2结合起来一起输出 1234567891011121314BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125;&#125; 在3结尾加上统计全部插入记录、失败记录数、成功记录数 123456789101112131415161718BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; total_sum+=array[i] total_successed+=array1[i] total_failed+=array2[i] printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125; printf \"%-20s%-20d%-20d%-20d\\n\",\"total\",total_sum,total_successed,total_failed&#125; 查找丢失数据的现象(成功+失败不等于插入的记录数) 1234&#123; if($8!=$14+$17) print $0&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"awk","slug":"awk","permalink":"http://yoursite.com/tags/awk/"}],"author":"Frdqy"},{"title":"Shell编程之（四）：sed","slug":"Shell编程之（四）：sed","date":"2019-12-28T12:48:41.000Z","updated":"2020-01-03T11:35:41.973Z","comments":true,"path":"2019/12/28/Shell编程之（四）：sed/","link":"","permalink":"http://yoursite.com/2019/12/28/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Ased/","excerpt":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。","text":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 pattern space模式空间，每一个被pattern所匹配到的行都放到pattern space中等待进一步处理 hold space保持空间，内存中另一块可以存放sed匹配行的空间，可以使操作更灵活。但主要是用来炫技，实际很少使用。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行 sed选项 选项 含义 -n 只打印模式匹配行(静默模式) -e 直接在命令行进行sed编辑,默认选项;适用于多个匹配模式和命令 -f 编辑动作保存在文件中，指定文件执行 -r 支持扩展正则表达式 -i 直接修改文件内容 pattern用法 匹配模式 含义 10command 匹配到第10行 10,20command 匹配从第10行开始，到第20行结束 10,+5command 匹配从第10行开始，到第16行结束 /pattern1/command 匹配到pattern1的行 /pattern1/,/pattern2/command 匹配到pattern1开始，pattern2结束的行 10,/pattern1/command 匹配从第10行开始，到匹配到pattern1的行结束 /pattern1/,10command 匹配到pattern1的行开始到第10行结束 1~2command 步长为2：从第一行开始每两行执行一次 编辑命令对照表查询 编辑命令 含义 p 打印 增加 编辑命令 含义 a 往后追加 i 往前追加 r 外部文件读入，行后追加 w 匹配行写入外部文件 删除 编辑命令 含义 d 删除 修改 编辑命令 含义 s/old/new 将行内第一个old替换为new s/old/new/g 将行内全部的old替换为new s/old/new/2g 将行内从第两个old开始到最后所有的old替换为new s/old/new/ig 将行内old全部替换为new，忽略大小写 其他 编辑命令 含义 = 显示行号 n 覆盖读取下一行 N 追加读取下一行 h 把模式空间的内容覆盖至保持空间 H 把模式空间的内容追加至保持空间 g 把保持空间的内容覆盖至模式空间 G 把保持空间的内容追加至模式空间 x 把模式空间与保持空间内容互换 ！ 条件取反，例如！1表示除了第一行 后向引用12345&amp; #引用匹配的整个串\\1 #引用匹配的第一个分组，需要&quot;()&quot;将待匹配括起来#例如： sed &#39;s&#x2F;\\(l..e\\)&#x2F;\\1r&#x2F;g&#39; #表示将以l开头e结尾的四字串替换为结尾加e#注意：&amp;只能匹配整个串，而\\1可以匹配一部分串，更加灵活 注意事项当写脚本时使用sed匹配模式中包含变量时，要用双引号将整个匹配模式括起来。也可以对引用变量使用单引号单独括起来，效果一样。 查询实例 打印/etc/passwd中第20行内容 1sed -n '20p' /etc/passwd 打印/etc/passwd中从第8行开始，到第15行结束的内容 1sed -n '8,15p' /etc/passwd 打印/etc/passwd中从第8行开始，然后+5行结束的内容 1sed -n '8,+5p' /etc/passwd 打印/etc/passwd中开头匹配frdqy字符串的内容 1sed -n '/^frdqy/p' /etc/passwd 打印/etc/passwd中开头为root的行开始，到开头为frdqy的行结束的内容 1sed -n '/^root/,/^frdqy/p' /etc/passwd 打印/etc/passwd中第8行开始，到含有/sbin/nologin的内容的行结束的内容 1sed -n '8,/\\/sbin\\/nologin/p' /etc/passwd 打印/etc/passwd中第一个包含/bin/bash内容的行开始，到第五行结束的内容 1sed -n '/\\/bin\\/bash/,5p' /etc/passwd 删除实例 删除/etc/passwd中的第15行 1sed -i '15d' /etc/passwd 删除/etc/passwd中的第8行到第14行的所有内容 1sed -i '8,14d' /etc/passwd 删除/etc/passwd中的不能登录的用户(/sbin/nologin) 1sed -i '/\\/sbin\\/nologin/d' /etc/passwd 删除/etc/passwd中以mail开头的行，到以backup开头的行的所有内容 1sed -i '/^mail/,/^backup/d' /etc/passwd 删除/etc/passwd中第一个不能登录的用户，到第13行的所有内容 1sed -i '/\\/sbin\\/nologin/,13d' /etc/passwd 删除/etc/passwd中第5行到以ftp开头的所有行的内容 1sed -i '5,/^ftp/d' /etc/passwd 删除/etc/passwd中以backup开头的行到最后行的所有内容 1sed -i '/^backup/,$d' /etc/passwd 删除配置文件的注释行和空行 1234sed -i '/^#/d;/^$/d'#只能删除#在开头的注释，例如代码内部注释就删不了。sed -i '/^[:blank:]*#/d' ./nginx#只删除代码内部的注释 在配置文件中所有不以#开头的行前面添加*符号，注意：以#开头的行不添加 12sed -i 's/^[^#]/\\*&amp;/g' ./nginx#中括号外的^表示行首，中括号内的^表示取反，即不取中括号内的值。 修改实例 修改/etc/passwd中第1行中第一个root为ROOT 1sed -i '1s/root/ROOT/' /etc/passwd 修改/etc/passwd中第5行到第10行中所有的/sbin/nologin为/bin/bash 1sed -i '5,10/\\/sbin\\/nologin/\\/bin\\/bash/g' /etc/passwd 修改/etc/passwd中匹配到/sbin/nologin的行，将匹配到行中的login改为大写LOGIN 1sed -i 's/\\(\\/sbin\\/no\\)login/\\1LOGIN/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到匹配到行中包括mail的所有行，将bin改为dqy 1sed -i '/^root/,/mail/s/bin/dqy/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到第15行中所有行的nologin修改为frdqy 1sed -i '/^root/,15s/nologin/frdqy/g' /etc/passwd 修改/etc/passwd从第15行开始，到匹配到以frdqy开头的所有行的bin修改为BIN 1sed -i '15,/^frdqy/s/bin/BIN/g' /etc/passwd 追加实例 在/etc/passwd文件第10行后面追加”Add Line Behind” 1sed -i '10a Add Line Behind' /etc/passwd 在/etc/passwd文件第10行到第20行，每行后面追加”Test Line Behind” 1sed -i '10,20a Test Line Behind' /etc/passwd 在/etc/passwd文件匹配到/bin/bash的行后追加”Insert Line For /bin/bash Behind” 1sed -i '/\\/bin\\/bash/a Insert Line For /bin/bash Behind' /etc/passwd 在/etc/passwd文件匹配到以gdm开头的行，在匹配行前面追加”Add Line Before” 1sed -i '/^gdm/i Add Line Before' /etc/passwd 在/etc/passwd文件每一行前面都追加”Insert Line Before Every Line” 1sed -i 'i Insert Line Before Every Line' /etc/passwd 将/etc/fstab文件内容追加到/etc/passwd文件第 20行后 1sed -i '20r /etc/fstab' /etc/passwd 将/etc/inittab文件内容追加到/etc/passwd文件匹配/sbin/nologin行后 1sed -i '/\\/sbin\\/nologin/r /etc/inittab' /etc/passwd 将/etc/vconsole.conf文件内容追加到/etc/passwd文件匹配以sync开头到18行的所有行后 1sed -i '/^sync/,18r /etc/vconsole.conf' /etc/passwd 将/etc/passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt中 1sed -i '/\\/bin\\/bash/w /tmp/sed.txt' /etc/passwd 将/etc/passwd文件从第10行开始到匹配到frdqy开头的所有行追加到/tmp/sed_1.txt中 1sed -i '10,/^frdqy/w /tmp/sed_1.txt' /etc/passwd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"sed","slug":"sed","permalink":"http://yoursite.com/tags/sed/"}],"author":"Frdqy"},{"title":"正则知识补充","slug":"正则知识补充","date":"2019-12-27T14:19:00.000Z","updated":"2019-12-28T00:46:28.925Z","comments":true,"path":"2019/12/27/正则知识补充/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界","text":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# #表示前面的字符连续出现任意次，包括0次。. #表示任意单个字符。.* #表示任意长度的任意字符，与通配符中的*的意思相同。\\? #表示匹配其前面的字符0或1次\\+ #表示匹配其前面的字符至少1次，或者连续多次，连续次数上不封顶。\\&#123;n\\&#125; #表示前面的字符连续出现n次，将会被匹配到。\\&#123;x,y\\&#125; #表示之前的字符至少连续出现x次，最多连续出现y次，都能被匹配到，换句话说，只要之前的字符连续出现的次数在x与y之间，即可被匹配到。\\&#123;,n\\&#125; #表示之前的字符连续出现至多n次，最少0次，都会陪匹配到。\\&#123;n,\\&#125; #表示之前的字符连续出现至少n次，才会被匹配到.. #表示匹配任意单个字符S* #表示匹配前面的字符任意次，包括0次[ ] #表示匹配指定范围内的任意单个字符[^ ] #表示匹配指定范围外的任意单个字符 [[:alpha:]] #表示任意大小写字母[[:lower:]] #表示任意小写字母[[:upper:]] #表示任意大写字母[[:digit:]] #表示0到9之间的任意单个数字（包括0和9）[[:alnum:]] #表示任意数字或字母[[:space:]] #表示任意空白字符，包括&quot;空格&quot;、&quot;tab键&quot;等。[[:punct:]] #表示任意标点符号 [0-9]与[[:digit:]]等效[a-z]与[[:lower:]]等效[A-Z]与[[:upper:]]等效[a-zA-Z]与[[:alpha:]]等效[a-zA-Z0-9]与[[:alnum:]]等效 [^0-9]与[^[:digit:]]等效[^a-z]与[^[:lower:]]等效[^A-Z]与[^[:upper:]]等效[^a-zA-Z]与[^[:alpha:]]等效[^a-zA-Z0-9]与[^[:alnum:]]等效 #简短格式并非所有正则表达式解析器都可以识别\\d #表示任意单个0到9的数字\\D #表示任意单个非数字字符\\t #表示匹配单个横向制表符（相当于一个tab键）\\s #表示匹配单个空白字符，包括&quot;空格&quot;，&quot;tab制表符&quot;等\\S #表示匹配单个非空白字符\\(\\) #表示分组，且可以嵌套\\(ab\\) #表示将ab作为一个整体处理\\1 #表示引用整个表达式中第一个分组中的正则表达式\\2 #表示引用整个表达式中第二个分组中的正则表达式#若分组嵌套，以左括号为基准判断是第几个分组","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}],"author":"Frdqy"},{"title":"Shell编程之（三）：常用查找工具","slug":"Shell编程之（三）：常用查找工具","date":"2019-12-27T14:16:02.000Z","updated":"2019-12-30T07:58:04.759Z","comments":true,"path":"2019/12/27/Shell编程之（三）：常用查找工具/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n","text":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n 操作： -print(默认) -ok(与exec相似，会给用户提示) -exec 删除etc下conf结尾的文件 find ./etc -name &apos;*.conf&apos; -exec rm -rf {} \\; 复制 find ./etc -size +1M -exec cp {} ./test/ \\; 删除/var/log下以.log结尾的7天以前的文件 find /var/log -name &apos;*.log&apos; -mtime +7 -exec rm -rf {} \\; 搜素etc下以conf结尾的且大于10k的文件，复制到root/conf目录下 find /etc/ -name &apos;*.conf&apos; -size +10k -exec cp {} /root/conf/ \\; locate locate在数据库文件中查找，而find在整个磁盘中查找 由系统定时任务负责更新数据库 find默认全部匹配，locate默认部分匹配 updatedb命令： 更新/var/lib/mlocate/mlocate.db 配置文件为：/etc/updatedb.conf whereis -b查找二进制文件 -m查找帮助文件 -s查找源代码文件 which 查找二进制文件(查用于查找程序绝对路径) grep 形式一：grep [option] [pattern] [file1,file2...] 形式二：command | grep [option] [pattern] 参数： -v 不显示匹配行 -i 忽略大小写 -n 显示行号 -r 递归搜索(当前目录下搜索所有文件) -E 支持扩展正则 -F 不按正则 -c 输出匹配行的数量 -w 匹配整个单词 -x 匹配整行 -l 只列出匹配的文件名 逻辑运算：123-a #与-o #或-not|! #非","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"find","slug":"find","permalink":"http://yoursite.com/tags/find/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}],"author":"Frdqy"},{"title":"Shell编程之（二）：函数的使用","slug":"Shell编程之（二）：函数的使用","date":"2019-12-27T14:15:17.000Z","updated":"2020-01-06T07:39:51.424Z","comments":true,"path":"2019/12/27/Shell编程之（二）：函数的使用/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2 函数传参12345function name&#123; echo $1 #第一个参数 echo $2 #第二个参数&#125; 函数调用1name zhangsan lisi 函数返回值 返回0：成功返回1~255：失败 echo返回单一字符串或数据列表 echo $$：返回脚本执行的进程pid，用于解决脚本自身名字包含所要管 理的服务引起冲突的情况。守护进程(daemon)：通过脚本判断某个服务是否正常，不正常就启动 netstat -tnlp：查看网络状态 全局变量与局部变量的定义 不做特殊说明，shell中变量都是全局变量(不建议在大型脚本中使用全 局变量) 定义变量时使用local关键字函数内外若存在同名变量，则函数内部变量覆盖外部变量 库函数：用于封装常用函数，后缀通常以.lib结尾。引用库函数时，用. base_function即可，推荐用绝对路径(点后有一个 空格) 文件包含12345678#!/bin/bash# author:菜鸟教程# url:www.runoob.com#注意.和文件名中间有空格. file_name#或者source file_name while循环只强调一个while循环的特殊用法，即依次读取文件的行 123456#格式while read linedo 循环体done &lt; /path/file#上述可以实现一次读取file中的每一行并赋值给line变量 case选择123456789101112case $var inpar1) 分支1 ;;part2) 分支2 ;;...#上述都不匹配则匹配此选项*) 分支nesac","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（一）：变量的用法","slug":"Shell编程之（一）：变量的用法","date":"2019-12-27T14:13:36.000Z","updated":"2020-01-05T05:43:45.926Z","comments":true,"path":"2019/12/27/Shell编程之（一）：变量的用法/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"定义范围12345#显示1到100的数echo &#123;1..100&#125;#表示从1到10，步长为2seq 1 2 10 计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个 计算子串长度1expr match $String subString 抽取子串12345$&#123;string:position:length&#125;#从position取length个$&#123;String:position&#125; #从String中的position开始$&#123;String: -position&#125; #从右往左(注意空格)$&#123;String:(position)&#125; #从左往右$expr substr $String $position $length #与二类似 变量替换：1234567$&#123;变量名#正则&#125; #从开头匹配最短删除$&#123;变量名##正则&#125; #从开头匹配最长删除$&#123;变量名%正则&#125; #从尾部匹配最短删除$&#123;变量名%%正则&#125; #从尾部匹配最长删除$&#123;变量名/旧字符串/新字符串&#125; #第一个字符串替换$&#123;变量名//旧字符串/新字符串&#125; #全部字符串替换#注意：使用expr索引计数从1开始，使用$&#123;&#125;索引计数从0开始 命令替换12``$() 数学运算12$[a+b]$((a+b)) #注意与命令替换区分 有类型变量1234567891011declare -r #声明变量为只读类型declare -i #声明变量为整型declare -f #在脚本中显示定义的函数和内容declare -F #在脚本中显示定义的函数declare -a #声明数组arr=(\"jones\" \"mike\" \"kobe\" \"jordan\") #以空格分隔echo $&#123;arr[@]&#125; #获取整个数组echo $&#123;#arr[@]&#125; #获取整个数组长度echo $&#123;#arr[i]&#125; #获取某个数组元素长度declare -x #声明环境变量#取消某个设置只需要“-”改为“+”即可 expr语法格式1234567expr $num1 operator $num2#操作符对照表(注意转义)num1 | num2 num1 #不为空且非0，返回num1；否则返回num2num1 &amp; num2 num1 #不为空且非0，返回num1；否则返回0#判断整数expr $num + 1 #如果执行成功则为整数(成功返回1) bc进行浮点数计算123echo \"23 + 5\" | bcecho \"23.15 + 4.3\" | bcecho \"scale=4;23.5/3.5\" | bc let自增12#let后变量不需要$引用，一般直接++即可let i++","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Hello World","slug":"hello-world","date":"2019-12-27T05:38:00.000Z","updated":"2019-12-27T15:36:33.873Z","comments":true,"path":"2019/12/27/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}