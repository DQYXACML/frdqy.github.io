{"meta":{"title":"Frdqy的博客","subtitle":"记录默默到无闻的学习路","description":"","author":"Frdqy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2019-12-28T00:25:13.000Z","updated":"2019-12-28T00:25:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-28T00:30:05.000Z","updated":"2019-12-28T00:30:38.637Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-28T00:23:37.000Z","updated":"2019-12-28T00:26:11.438Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"文件特殊权限","slug":"文件特殊权限","date":"2020-01-01T11:23:25.000Z","updated":"2020-01-01T11:55:55.319Z","comments":true,"path":"2020/01/01/文件特殊权限/","link":"","permalink":"http://yoursite.com/2020/01/01/%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/","excerpt":"文件特殊权限SUID、SGID、STICKY","text":"文件特殊权限SUID、SGID、STICKY 安全上下文 进程以某用户的身份运行：进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作 权限匹配模型： 判断进程的属主是否为被访问文件的属主 ，如果是则使用属主权限访问，否则进入2 判断进程的属主是否属于被访问文件的属组，如果是就使用属组权限，否则进入3 应用other模型 SUID默认情况下用户发起的进程其属主是其发起者。而设置SUID的进程执行时，其属主为进程自己的属主。 1234567891011121314151617181920#/etc/shadow无访问权限[frdqy@localhost ~]$ ls -l /etc/shadow----------. 1 root root 1434 Dec 31 22:26 /etc/shadow#以frdqy身份无法访问/etc/shadow，因为此时以使用cat的发起者权限来访问/etc/shadow，即other[frdqy@localhost ~]$ cat /etc/shadowcat: /etc/shadow: Permission denied#此时cat并没有设置SUID权限[frdqy@localhost ~]$ ls -l /bin/cat-rwxr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#用root给cat设置SUID权限后[root@localhost frdqy]# chmod u+s /bin/cat[root@localhost frdqy]# ls -l /bin/cat-rwsr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#frdqy用户即可用cat查看/etc/shadow内容，因为此时cat进程使用的是其属主root权限，而不是进程的发起者[frdqy@localhost ~]$ cat /etc/shadowroot:$6$RsZ/8mPpOXX17jO8$yeL/BOfROjigWhsFEEwvF6ZDe3ldr/FJX9vvQFtzJCIWZngO5RhjLVRRgAeSg13ymfLWELIyl5R.sTBbGtP390::0:99999:7::: 注意： 如果进程属主原本有执行权限，那么加了SUID后就变成s；如果进程属主原本没有执行权限，那么加SUID后就变成S。 SGID通常对目录设置，这样其他用户在该目录下创建文件时，文件的属组全都是目录的属组，主要为了方便同组用户的修改。 1chmod g+|g- /dir STICKY用于解决某一目录下每个用户都可以删除同组其他用户的文件问题，在该目录上设置STICKY后用户只能新建和删除自己的文件，不能删除同组其他用户的文件。 12chmod o+t|o-t /dir#/tmp和/var/tmp默认具有STICKY权限 FACLfacl是文件的额外赋权机制，在原来的ugo之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制 getfacl1234getfacl fileuser:USERNAME:MODEgroup:GROUPNAME:MODE#若username为空则为属主的权限，若groupname为空则为默认属组的权限 setfacl1234567#赋权给用户setfacl -m u:USERNAME:MODE file#赋权给组setfacl -m g:GROUPNAME:MODE file#撤销赋权setfacl -x u:USERNAME:MODE filesetfacl -x g:GROUPNAME:MODE file 访问控制顺序首先，检查进程属主与被访问文件属主是否相同，相同则使用属主权限；否则检查被访问文件是否定义关于该用户的访问控制链表(facl)，有则应用该访问链表权限；否则检查此进程的属主是否是被访问文件的属组，是则应用属组访问权限，否则检查访问控制链表是否有该用属组的定义，若有则应用该属组权限。最后还不匹配就按other访问。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"}],"author":"Frdqy"},{"title":"Shell编程之（七）：脚本实战","slug":"Shell编程之（七）：脚本实战","date":"2019-12-31T08:27:45.000Z","updated":"2019-12-31T08:28:45.979Z","comments":true,"path":"2019/12/31/Shell编程之（七）：脚本实战/","link":"","permalink":"http://yoursite.com/2019/12/31/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98/","excerpt":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态","text":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态 拆分脚本功能app_statuesfunction get_all_process123456789101112#返回进程名称列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125; function get_all_group1234567891011121314#返回进程租列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_group&#123; if [ ! -e $HOME_DIR/$CONFIG_FILE ];then echo \"$CONFIG_FILE is not exit.\" exit 1 else G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $G_LIST fi&#125; function get_process_pid_by_name12345678910#参数为进程pid根据进程名称查pidfunction get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $0 | awk '&#123;print $2&#125;'` echo $pids fi&#125; function get_process_info_by_pid1234567891011121314#参数为pid，根据pid查询进程状#详细信息包括：运行状态，PID，MEM信息，CPU信息，时间信息#此处不能根据进程名查，会有很多无关信息function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 \"$2==pid&#123;print &#125;\" | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $3&#125;\"` pro_mem=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $4&#125;\"` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125; function is_group_in_config1234567891011121314#参数为group，判断group是否在config中# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125; function get_all_process_group1234567891011#参数为group，根据group获取processfunction get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125; function get_group_by_process12345678910111213#根据进程获取组名，参数为processfunction get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125; function format_print12345678910111213#接收两个参数，第一个为process，第二个为groupfunction format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_status=$pro_stat_time -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=$pro_stat_time 'BEGIN&#123;printf \"%-10s%-10s%-5s%-5s%-5s%-5s%-15s\\n\",p_name,g_name,p_status,p_cpu,p_mem,p_start_time&#125;' done fi &#125; function is_process_in_config123456789101112#参数为process#坑点：此处一开始将return1写在循环里导致直接跳出function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125; 主函数流程 无参数 列出配置文件中所有经常的运行信息 -g GroupName 列出GroupName组内的所有进程 process_name1 列出指定进程的运行信息 代码实现1234567891011121314151617181920212223242526if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/bin/bash## Func:Get process statues in process.cfg# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"this_pid=$$function get_all_group&#123; G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE| egrep -v \"(^$|^\\[)\"` echo $G_LIST&#125;function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125;function get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $this_pid | awk '&#123;print $2&#125;'` echo $pids fi&#125;function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 '$2==pid&#123;print&#125;' | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 '$2==pid&#123;print $3&#125;'` pro_mem=`ps aux | awk -v pid=$1 '$2==pid&#123;print $4&#125;'` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125;function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125;function get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125;function get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125;function format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_id=$pid -v p_status=$proc_statues -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=\"$pro_stat_time\" 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,p_id,p_status,p_cpu,p_mem,p_start_time&#125;' done else awk -v p_name=$1 -v g_name=$2 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,\"NULL\",\"NULL\",\"NULL\",\"NULL\",\"NULL\"&#125;' fi &#125;function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125;if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 小结至此，shell编程的专项学习告一段落，下面的练习都将在学习其他知识时进行巩固。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（六）：mysql","slug":"Shell编程之（六）：mysql","date":"2019-12-30T07:54:12.000Z","updated":"2019-12-30T07:57:06.178Z","comments":true,"path":"2019/12/30/Shell编程之（六）：mysql/","link":"","permalink":"http://yoursite.com/2019/12/30/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Amysql/","excerpt":"安装mariadb1sudo apt-get install mariadb-server","text":"安装mariadb1sudo apt-get install mariadb-server 测试实例建表脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--student.sql--create tables--student tablescreate table &#96;student&#96;( &#96;s_id&#96; varchar(20), &#96;s_name&#96; varchar(20) not null default &#39;&#39;, &#96;s_birth&#96; varchar(20)not null default &#39;&#39;, &#96;s_sex&#96; varchar(20) not null default &#39;&#39;, primary key(&#96;s_id&#96;));--course tablescreate table &#96;course&#96;( &#96;c_id&#96; varchar(20), &#96;c_name&#96; varchar(20)not null default &#39;&#39;, &#96;t_id&#96; varchar(20) not null, primary key(&#96;c_id&#96;));--teacher tablecreate table &#96;teacher&#96;( &#96;t_id&#96; varchar(20), &#96;t_name&#96; varchar(20)not null default &#39;&#39;, primary key(&#96;t_id&#96;));--score tablecreate table &#96;score&#96;( &#96;s_id&#96; varchar(20), &#96;c_id&#96; varchar(20), &#96;s_score&#96; int(3), primary key(&#96;s_id&#96;,&#96;c_id&#96;));--insert student tableinsert into student values(&#39;1001&#39;,&#39;zhaolei&#39;,&#39;1990-1001-1001&#39;,&#39;male&#39;);insert into student values(&#39;1002&#39;,&#39;lihang&#39;,&#39;1990-12-21&#39;,&#39;male&#39;);insert into student values(&#39;1003&#39;,&#39;yanwen&#39;,&#39;1990-1005-20&#39;,&#39;male&#39;);insert into student values(&#39;1004&#39;,&#39;hongfei&#39;,&#39;1990-1008-1006&#39;,&#39;male&#39;);insert into student values(&#39;1005&#39;,&#39;ligang&#39;,&#39;1991-12-1001&#39;,&#39;female&#39;);insert into student values(&#39;1006&#39;,&#39;zhousheng&#39;,&#39;1992-1003-1001&#39;,&#39;female&#39;);insert into student values(&#39;1007&#39;,&#39;wangjun&#39;,&#39;1989-1007-1001&#39;,&#39;female&#39;);insert into student values(&#39;1008&#39;,&#39;zhoufei&#39;,&#39;1990-1001-20&#39;,&#39;female&#39;);--insert course tableinsert into teacher values(&#39;1001&#39;,&#39;aidisheng&#39;);insert into teacher values(&#39;1002&#39;,&#39;aiyinsitan&#39;);insert into teacher values(&#39;1003&#39;,&#39;qiansanqiang&#39;);--insert score tableinsert into score values(&#39;1001&#39;,&#39;1001&#39;,80);insert into score values(&#39;1001&#39;,&#39;1002&#39;,90);insert into score values(&#39;1001&#39;,&#39;1003&#39;,99);insert into score values(&#39;1002&#39;,&#39;1001&#39;,70);insert into score values(&#39;1002&#39;,&#39;1002&#39;,60);insert into score values(&#39;1002&#39;,&#39;1003&#39;,80);insert into score values(&#39;1003&#39;,&#39;1001&#39;,80);insert into score values(&#39;1003&#39;,&#39;1002&#39;,80);insert into score values(&#39;1003&#39;,&#39;1003&#39;,50);insert into score values(&#39;1004&#39;,&#39;1001&#39;,20);insert into score values(&#39;1004&#39;,&#39;1002&#39;,30); 建数据库1create database school; 导入数据1mysql school &lt; student.sql 授权用户1234--授予dbuser用户在所有网段都可以对school数据库进行操作，密码为123456grant all on school.* to dbuser@&#39;%&#39; identified by &#39;123456&#39;grant all on school.* to dbuser@&#39;localhost&#39; identified by &#39;123456&#39;--&#39;%&#39;表示所有主机都可以访问 使用授权用户登录12--u和p与参数间可以省略mysql -udbuser -p123456 -h localhost mysql命令参数 命令 含义 -u 用户名 -p 用户密码 -h 服务器ip地址 -D 链接的数数据库 -N 不输出列信息 -B 使用tab键代替默认交互分隔符 -e 执行sql语句 -E 垂直输出 -H 以HTML格式输出 -X 以XML格式输出 注意 -B用来不显示周围一圈分隔符时建议放在选项最后，在-e之前。 查询实例 写一个脚本，该脚本可以接收一个参数，参数为需要执行的sql语句 123#!/bin/bash#mysql -u dbuser -p123456 -D school -e \"$1\" 查询mysql任意表的数据，并将查询到的结果保存到HTML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -H -e \"$1\" &gt; $2 查询mysql任意表的数据，并将查询到的结果保存到XML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -X -e \"$1\" &gt; $2 导入实例需求一处理文本中的数据，将文本中的数据插入mysql ​ 1010 jerry 1991-12-13 male ​ 1011 mike 1991-12-13 female ​ 1012 tracy 1991-12-13 male ​ 1013 kobe 1991-12-13 female ​ 1014 allen 1991-12-13 male ​ 1015 curry 1991-12-13 male ​ 1016 tom 1991-12-13 female 123456789101112#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"cat data.txt | while read id name birth sexdo $mysql_conn -D $database -e \"insert into student1 values('$id','$name','$birth','$sex')\"done 需求二同上，但是分隔符变了 ​ 1010|jerry|1991-12-13|male ​ 1011|mike|1991-12-13|female ​ 1012|tracy|1991-12-13|male ​ 1013|kobe|1991-12-13|female ​ 1014|allen|1991-12-13|male ​ 1015|curry|1991-12-13|male ​ 1016|tom|1991-12-13|female 123456789101112131415#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"#mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"#输入分隔符指定IFS=\"|\"cat data2.txt | while read id name birth sexdo mysql -u \"dbuser\" -p\"$passwd\" -D $database -e \"insert into student2 values('$id','$name','$birth','$sex')\"done 注意需求二有一个坑，在于注释的sql语句那样写在变量里会提示找不到命令，可能时管道符号冲突问题，shll真不规范！！ mysqldump备份语法格式1mysqldump [OPTIONS] database [tables] 命令参数 命令 含义 -u 用户名 -p 密码 -h 服务器IP地址 -d 等价于–no-data，只导出表结构 -t 等价于–no-create-info，只导出数据，不导出建表语句 -A 等价于–all-databases -B 等价于–databases，导出一个或多个数据库 需求将school中的score备份，并且将备份数据通过ftp传输到xxx.xxx.xxx.xxx的/data/backup目录下 补充知识 open xxx.xxx.xxx.xxx：用于打开远端连接 user 用户名 密码：用于登录 -i：不交互 -n：自动登录 -v：显示详细信息 &lt;&lt; EOF：表示下面将输入长命令，直到遇到EOF结束，且EOF最后一行必须顶格写 12345678910111213141516171819202122232425262728#!/bin/bash#db_user=\"dbuser\"db_passwd=\"123456\"ftp_user=\"ftp_user\"ftp_passwd=\"redhat\"ftp_host=\"192.168.184.3\"dst_dir=\"/data/backup\"time_date=\"`date +%Y%m%d%H%M%S`\"file_name=\"school_score_$&#123;time_date&#125;.sql\"function auto_ftp&#123; ftp -niv &lt;&lt; EOF open $ftp_host user $ftp_user $ftp_passwd cd $dst_dir put $1 byeEOF&#125;mysqldump -u\"$db_user\" -p\"$db_passwd\" school score &gt; ./$file_name &amp;&amp; auto_ftp ./$file_name","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"Frdqy"},{"title":"Shell编程之（五）：awk","slug":"Shell编程之（五）：awk","date":"2019-12-29T13:09:12.000Z","updated":"2019-12-30T07:58:27.704Z","comments":true,"path":"2019/12/29/Shell编程之（五）：awk/","link":"","permalink":"http://yoursite.com/2019/12/29/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aawk/","excerpt":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'","text":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' 语法格式说明 语法格式 解释 BEGIN{} 正式处理数据之前执行 pattern 匹配模式 {commands} 处理命令，可能多行 END{} 处理完所有匹配数据后执行 内置变量对照表 内置变量 含义 $0 整行内容 $1-$n 当前行的第1-n个字段 NF(Number Field) 当前行的字段个数 NR(Number Row) 当前行行号，从1开始 FNR(File Number Row) 多文件每个文件行号单独计数，从0开始 FS(Field Separator) 输入字段分隔符，默认空格或tab RS(Row Separator) 输入行分隔符，默认回车换行 OFS(Output Field Separator) 输出字段分隔符，默认空格 ORS(Output Row Separator) 输出行分隔符，默认回车换行 FILENAME 当前输入的文件名字 ARGC 命令行参数个数 ARGV 命令行参数数组 printf详解printf格式说明符 格式符 含义 %s 打印字符串 %d 打印十进制数 %f 打印浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字科学计数法形式 %c 打印单个字符的ASCII printf修饰符 修饰符 含义 - 左对齐 + 右对齐 # 八进制加0，十六进制加0x 格式符实例 以字符串格式打印/etc/passwd中的第7个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以10进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以浮点数进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符，小数点保留2位 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%0.2f\\n\",$3&#125;' /etc/passwd 以16进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#x\\n\",$3&#125;' /etc/passwd 以8进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#o\\n\",$3&#125;' /etc/passwd 以科学技术格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%e\\n\",$3&#125;' /etc/passwd 模式匹配语法格式 语法格式 含义 /RegExp/ 按正则匹配 关系运算 按关系匹配 正则实例 匹配/etc/passwd文件行中包含有root字符串的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/root/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 匹配/etc/passwd文件行中以frdqy开头的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/^frdqy/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 关系实例 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段大于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&gt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7==\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段不为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7!=\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段包含3个以上数字的所有行信息 12awk 'BEGIN&#123;FS=\":\"&#125;$3~/[0-9]&#123;3,&#125;/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd#~表示匹配正则，!~表示不匹配正则 布尔实例 以:为分隔符，匹配/etc/passwd文件中包含root或frdqy的所有 1awk 'BEGIN&#123;FS=\":\"&#125;$1==\"root\" || $1==\"frdqy\"&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50并且第4个字段大于50的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50 &amp;&amp; $4&gt;50&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 动作算术运算符 运算符 含义 + 加 - 减 * 乘 除 / % 模 ^或** 乘方 ++x 返回变量x之前+1 x++ 返回变量x之后+1 x+=y x=x+y 算数实例 使用awk计算/etc/services中空白行的数量 1awk '/^$/&#123;sum++&#125;END&#123;printf \"%d\\n\",sum&#125;' /etc/services 计算下列每个同学的平均分数，将其打印在最后一列后 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 1awk 'BEGIN&#123;FS=\",\"&#125;&#123;sum=$2+$3+$4+$5;avg=sum/(NF-1);printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;' ./student.txt 条件语句123456if(条件表达式) 动作1else if(条件表达式) 动作2else 动作3 条件实例 以:为分隔符，只打印/etc/passwd中第3个字段的数值在50-100范围内的行信息 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;if($3&lt;=100&amp;&amp;$3&gt;=50)print $0&#125;' /etc/passwd 计算下列每个学生的平均分数，并且只打印平均分大于90的学生姓名和分数信息 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 12345678910111213#过长，写在scripts.awk中BEGIN&#123; FS=\",\" &#125;&#123; sum=$2+$3+$4+$5; avg=sum/(NF-1); if(avg&gt;90) printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;#用-f选项调用awk -f ./scripts.awk ./student.txt 循环语句-while12while(条件表达式) 动作 循环语句-do while123do 动作while(条件表达式) 循环语句-for12for(初始化计数器;测试计数器;计数器变更) 动作 循环实例 计算1+2+…+100的和，使用while、do while、for三种实现 1234567891011121314151617181920212223242526272829#whileBEGIN&#123; while(i&lt;=100) &#123; sum+=i; i++; &#125; print sum&#125;#do-whileBEGIN&#123; i=0; do &#123; i++ sum+=i &#125;while(i&lt;100) print sum&#125;#forBEGIN&#123; for(i=0;i&lt;=100;i++) &#123; sum+=i; &#125; print sum&#125; 字符串函数 函数名 解释 函数返回值 length 计算字符串长度 整数长度值 index(str1,str2) 在str1中找str2位置 返回索引，从1开始 tolower(str) 转换为小写 转换后的字符串 toupper(str) 转换为大写 转换后的字符串 substr(str,m,n) 从str的m个字符开始，截取n位 截取后的子串 match(str,RE) 在str中按RE查找 返回索引 split(str,arr,fs) 按fs切割字符串，结果存arr中 切割后的子串个数 sub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换一个 替换个数 gsub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换所有 替换个数 字符串处理实例 以:为分隔符，返回/etc/passwd中每行每个字段的长度 1234567891011121314151617BEGIN&#123; FS=\":\" &#125;&#123; for(i=1;i&lt;=NF;i++) &#123; if(i!=NF) &#123; printf \"%d:\",length($i) &#125; if(i==NF) &#123; printf \"%d\",length($i) printf \"\\n\" &#125; &#125;&#125; 搜索字符串”I have a dream”中出现”ea”字符串的位置 1234567891011#indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125;#match,可见match功能包含了indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为小写 1234BEGIN&#123; str=tolower(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为大写 1234BEGIN&#123; str=toupper(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop Kafka Spark Storm HDFS YARN Zookeeper”分割保存到数组arr中 12345678910BEGIN&#123; str=\"Hadoop Kafka Spark Storm HDFS YARN Zookeeper\" len=split(str,arr,\" \") i=1 while(i&lt;=len) &#123; print arr[i] i++ &#125;&#125; 搜素字符串”Transaction 2345 Start:Select * from master”第一个数字出现的位置 12345BEGIN&#123; str=\"Transaction 2345 Start:Select * from master\" i=match(str,\"[0-9]\") print i&#125; 截取字符串”Transaction start”的子串，截取条件从第4个字符开始，截取5位 12345BEGIN&#123; str=\"Transaction start\" str1=substr(str,4,5) print str1&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中第一个匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" sub(\"[0-9]+\",\"$\",str) print str&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中所有匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" gsub(\"[0-9]+\",\"$\",str) print str&#125; 选项 选项 解释 -v 参数传递 -f 指定脚本文件 -F 指定分隔符 -V 查看awk版本号 注意1234567#在使用参数传递时，引用变量建议全部使用\"\"，否则如果引用的字符串内出现空格则会报错。num=20var=\"Hello World\"#下面命令会报错，原因在于var变量字符串包含空格awk -v num2=$num -v var1=$var 'BEGIN&#123;print num2,var1&#125;'#遇到上述问题需要将引用用\"\"包含起来awk -v \"num2=$num\" -v \"var1=$var\" 'BEGIN&#123;print num2,var1&#125;' 数组shell中数组的用法1234567#定义,各元素用空格或tab分隔array=(\"Allen\" \"Mike\" \"Messi\")#遍历for a in $&#123;array[@]&#125;do echo $adone 命令 含义 echo ${array[2]} 打印元素 echo ${ #array[@]} 打印元素个数 echo ${ #array[3]} 打印元素长度 array[3]=”Li” 数组元素赋值 unset array[2];unset array 删除元素 echo ${array[@]:1:3} 分片访问 ${array[@]/e/E} 替换第一个e为E ${array[@]//e/E} 替换所有的e为E awk中数组的用法既可以数字作为数组下标也可以字符串作为数组下标 12345678910111213141516#检测数组第i+1下标是否存在if i in array#删除某个数组元素delete array[i]#删除整个数组delete array#for循环语法格式1for(初始化; 布尔表达式; 更新) &#123;//代码语句&#125; #for循环语法格式2for(变量 in 数组) &#123;//代码语句&#125; 数组实例 统计主机上所有的TCP连接状态数，按照每个TCP状态分类 1netstat -an | grep tcp | awk '&#123;array[$6]++&#125;END&#123;for(a in array) print a,array[a]&#125;' 计算横向数据总和，计算纵向数据总和 allen 80 90 87 91 mike 78 86 93 96 Kobe 66 92 82 78 Jerry 98 74 66 54 Wang 87 21 100 43 1234567891011121314151617BEGIN&#123; printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Yuwen\",\"Math\",\"English\",\"Physical\",\"total\"&#125;&#123; total=$2+$3+$4+$5 sum+=total i=2 while(i&lt;=NF) &#123; array[i]+=$i i++ &#125; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total&#125;END&#123; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",\"sum_c\",array[2],array[3],array[4],array[5],sum&#125; 实战演练模拟脚本123456789101112131415161718192021222324#!/bin/bash#数据生成脚本，模拟大型数据function create_random&#123; min=$1 max=$(($2-$min+1)) num=`date +%s%N` echo $(($num%$max+$min))&#125;INDEX=1while truedo for user in allen mike jerry tracy han lilei do COUNT=$RANDOM NUM1=`create_random 1 $COUNT` NUM2=`expr $COUNT - $NUM1` echo \"`date '+%Y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into database:product table:detal, insert $NUM1 records successfully,failed $NUM2 records\" &gt;&gt; ./db.log.`date +%Y%m%d` INDEX=`expr $INDEX + 1` donedone 需求及解决方案 统计每个人分别插入多少条record进数据库 1234567&#123; array[$6]+=$8&#125;END&#123; for (i in array) printf \"%-10s%-10d\\n\",i,array[i]&#125; 统计每个人分别插入成功多少record，失败多少record 12345678910&#123; array[$6]+=$14 array1[$6]+=$17&#125;END&#123; for (i in array) printf \"%-10s %-10d successed!\\n\",i,array[i] for (j in array1) printf \"%-10s %-10d Failed!\\n\",j,array[j]&#125; 将1和2结合起来一起输出 1234567891011121314BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125;&#125; 在3结尾加上统计全部插入记录、失败记录数、成功记录数 123456789101112131415161718BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; total_sum+=array[i] total_successed+=array1[i] total_failed+=array2[i] printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125; printf \"%-20s%-20d%-20d%-20d\\n\",\"total\",total_sum,total_successed,total_failed&#125; 查找丢失数据的现象(成功+失败不等于插入的记录数) 1234&#123; if($8!=$14+$17) print $0&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"awk","slug":"awk","permalink":"http://yoursite.com/tags/awk/"}],"author":"Frdqy"},{"title":"Shell编程之（四）：sed","slug":"Shell编程之（四）：sed","date":"2019-12-28T12:48:41.000Z","updated":"2019-12-30T07:58:21.222Z","comments":true,"path":"2019/12/28/Shell编程之（四）：sed/","link":"","permalink":"http://yoursite.com/2019/12/28/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Ased/","excerpt":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行","text":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行 sed选项 选项 含义 -n 只打印模式匹配行(静默模式) -e 直接在命令行进行sed编辑,默认选项;适用于多个匹配模式和命令 -f 编辑动作保存在文件中，指定文件执行 -r 支持扩展正则表达式 -i 直接修改文件内容 pattern用法 匹配模式 含义 10command 匹配到第10行 10,20command 匹配从第10行开始，到第20行结束 10,+5command 匹配从第10行开始，到第16行结束 /pattern1/command 匹配到pattern1的行 /pattern1/,/pattern2/command 匹配到pattern1开始，pattern2结束的行 10,/pattern1/command 匹配从第10行开始，到匹配到pattern1的行结束 /pattern1/,10command 匹配到pattern1的行开始到第10行结束 编辑命令对照表查询 编辑命令 含义 p 打印 增加 编辑命令 含义 a 往后追加 i 往前追加 r 外部文件读入，行后追加 w 匹配行写入外部文件 删除 编辑命令 含义 d 删除 修改 编辑命令 含义 s/old/new 将行内第一个old替换为new s/old/new/g 将行内全部的old替换为new s/old/new/2g 将行内从第两个old开始到最后所有的old替换为new s/old/new/ig 将行内old全部替换为new，忽略大小写 其他 编辑命令 含义 = 显示行号 后向引用12345&amp; #引用匹配的整个串\\1 #引用匹配的第一个分组，需要&quot;()&quot;将待匹配括起来#例如： sed &#39;s&#x2F;\\(l..e\\)&#x2F;\\1r&#x2F;g&#39; #表示将以l开头e结尾的四字串替换为结尾加e#注意：&amp;只能匹配整个串，而\\1可以匹配一部分串，更加灵活 注意事项当写脚本时使用sed匹配模式中包含变量时，要用双引号将整个匹配模式括起来。也可以对引用变量使用单引号单独括起来，效果一样。 查询实例 打印/etc/passwd中第20行内容 1sed -n '20p' /etc/passwd 打印/etc/passwd中从第8行开始，到第15行结束的内容 1sed -n '8,15p' /etc/passwd 打印/etc/passwd中从第8行开始，然后+5行结束的内容 1sed -n '8,+5p' /etc/passwd 打印/etc/passwd中开头匹配frdqy字符串的内容 1sed -n '/^frdqy/p' /etc/passwd 打印/etc/passwd中开头为root的行开始，到开头为frdqy的行结束的内容 1sed -n '/^root/,/^frdqy/p' /etc/passwd 打印/etc/passwd中第8行开始，到含有/sbin/nologin的内容的行结束的内容 1sed -n '8,/\\/sbin\\/nologin/p' /etc/passwd 打印/etc/passwd中第一个包含/bin/bash内容的行开始，到第五行结束的内容 1sed -n '/\\/bin\\/bash/,5p' /etc/passwd 删除实例 删除/etc/passwd中的第15行 1sed -i '15d' /etc/passwd 删除/etc/passwd中的第8行到第14行的所有内容 1sed -i '8,14d' /etc/passwd 删除/etc/passwd中的不能登录的用户(/sbin/nologin) 1sed -i '/\\/sbin\\/nologin/d' /etc/passwd 删除/etc/passwd中以mail开头的行，到以backup开头的行的所有内容 1sed -i '/^mail/,/^backup/d' /etc/passwd 删除/etc/passwd中第一个不能登录的用户，到第13行的所有内容 1sed -i '/\\/sbin\\/nologin/,13d' /etc/passwd 删除/etc/passwd中第5行到以ftp开头的所有行的内容 1sed -i '5,/^ftp/d' /etc/passwd 删除/etc/passwd中以backup开头的行到最后行的所有内容 1sed -i '/^backup/,$d' /etc/passwd 删除配置文件的注释行和空行 1234sed -i '/^#/d;/^$/d'#只能删除#在开头的注释，例如代码内部注释就删不了。sed -i '/^[:blank:]*#/d' ./nginx#只删除代码内部的注释 在配置文件中所有不以#开头的行前面添加*符号，注意：以#开头的行不添加 12sed -i 's/^[^#]/\\*&amp;/g' ./nginx#中括号外的^表示行首，中括号内的^表示取反，即不取中括号内的值。 修改实例 修改/etc/passwd中第1行中第一个root为ROOT 1sed -i '1s/root/ROOT/' /etc/passwd 修改/etc/passwd中第5行到第10行中所有的/sbin/nologin为/bin/bash 1sed -i '5,10/\\/sbin\\/nologin/\\/bin\\/bash/g' /etc/passwd 修改/etc/passwd中匹配到/sbin/nologin的行，将匹配到行中的login改为大写LOGIN 1sed -i 's/\\(\\/sbin\\/no\\)login/\\1LOGIN/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到匹配到行中包括mail的所有行，将bin改为dqy 1sed -i '/^root/,/mail/s/bin/dqy/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到第15行中所有行的nologin修改为frdqy 1sed -i '/^root/,15s/nologin/frdqy/g' /etc/passwd 修改/etc/passwd从第15行开始，到匹配到以frdqy开头的所有行的bin修改为BIN 1sed -i '15,/^frdqy/s/bin/BIN/g' /etc/passwd 追加实例 在/etc/passwd文件第10行后面追加”Add Line Behind” 1sed -i '10a Add Line Behind' /etc/passwd 在/etc/passwd文件第10行到第20行，每行后面追加”Test Line Behind” 1sed -i '10,20a Test Line Behind' /etc/passwd 在/etc/passwd文件匹配到/bin/bash的行后追加”Insert Line For /bin/bash Behind” 1sed -i '/\\/bin\\/bash/a Insert Line For /bin/bash Behind' /etc/passwd 在/etc/passwd文件匹配到以gdm开头的行，在匹配行前面追加”Add Line Before” 1sed -i '/^gdm/i Add Line Before' /etc/passwd 在/etc/passwd文件每一行前面都追加”Insert Line Before Every Line” 1sed -i 'i Insert Line Before Every Line' /etc/passwd 将/etc/fstab文件内容追加到/etc/passwd文件第 20行后 1sed -i '20r /etc/fstab' /etc/passwd 将/etc/inittab文件内容追加到/etc/passwd文件匹配/sbin/nologin行后 1sed -i '/\\/sbin\\/nologin/r /etc/inittab' /etc/passwd 将/etc/vconsole.conf文件内容追加到/etc/passwd文件匹配以sync开头到18行的所有行后 1sed -i '/^sync/,18r /etc/vconsole.conf' /etc/passwd 将/etc/passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt中 1sed -i '/\\/bin\\/bash/w /tmp/sed.txt' /etc/passwd 将/etc/passwd文件从第10行开始到匹配到frdqy开头的所有行追加到/tmp/sed_1.txt中 1sed -i '10,/^frdqy/w /tmp/sed_1.txt' /etc/passwd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"sed","slug":"sed","permalink":"http://yoursite.com/tags/sed/"}],"author":"Frdqy"},{"title":"正则知识补充","slug":"正则知识补充","date":"2019-12-27T14:19:00.000Z","updated":"2019-12-28T00:46:28.925Z","comments":true,"path":"2019/12/27/正则知识补充/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界","text":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# #表示前面的字符连续出现任意次，包括0次。. #表示任意单个字符。.* #表示任意长度的任意字符，与通配符中的*的意思相同。\\? #表示匹配其前面的字符0或1次\\+ #表示匹配其前面的字符至少1次，或者连续多次，连续次数上不封顶。\\&#123;n\\&#125; #表示前面的字符连续出现n次，将会被匹配到。\\&#123;x,y\\&#125; #表示之前的字符至少连续出现x次，最多连续出现y次，都能被匹配到，换句话说，只要之前的字符连续出现的次数在x与y之间，即可被匹配到。\\&#123;,n\\&#125; #表示之前的字符连续出现至多n次，最少0次，都会陪匹配到。\\&#123;n,\\&#125; #表示之前的字符连续出现至少n次，才会被匹配到.. #表示匹配任意单个字符S* #表示匹配前面的字符任意次，包括0次[ ] #表示匹配指定范围内的任意单个字符[^ ] #表示匹配指定范围外的任意单个字符 [[:alpha:]] #表示任意大小写字母[[:lower:]] #表示任意小写字母[[:upper:]] #表示任意大写字母[[:digit:]] #表示0到9之间的任意单个数字（包括0和9）[[:alnum:]] #表示任意数字或字母[[:space:]] #表示任意空白字符，包括&quot;空格&quot;、&quot;tab键&quot;等。[[:punct:]] #表示任意标点符号 [0-9]与[[:digit:]]等效[a-z]与[[:lower:]]等效[A-Z]与[[:upper:]]等效[a-zA-Z]与[[:alpha:]]等效[a-zA-Z0-9]与[[:alnum:]]等效 [^0-9]与[^[:digit:]]等效[^a-z]与[^[:lower:]]等效[^A-Z]与[^[:upper:]]等效[^a-zA-Z]与[^[:alpha:]]等效[^a-zA-Z0-9]与[^[:alnum:]]等效 #简短格式并非所有正则表达式解析器都可以识别\\d #表示任意单个0到9的数字\\D #表示任意单个非数字字符\\t #表示匹配单个横向制表符（相当于一个tab键）\\s #表示匹配单个空白字符，包括&quot;空格&quot;，&quot;tab制表符&quot;等\\S #表示匹配单个非空白字符\\(\\) #表示分组，且可以嵌套\\(ab\\) #表示将ab作为一个整体处理\\1 #表示引用整个表达式中第一个分组中的正则表达式\\2 #表示引用整个表达式中第二个分组中的正则表达式#若分组嵌套，以左括号为基准判断是第几个分组","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}],"author":"Frdqy"},{"title":"Shell编程之（三）：常用查找工具","slug":"Shell编程之（三）：常用查找工具","date":"2019-12-27T14:16:02.000Z","updated":"2019-12-30T07:58:04.759Z","comments":true,"path":"2019/12/27/Shell编程之（三）：常用查找工具/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n","text":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n 操作： -print(默认) -ok(与exec相似，会给用户提示) -exec 删除etc下conf结尾的文件 find ./etc -name &apos;*.conf&apos; -exec rm -rf {} \\; 复制 find ./etc -size +1M -exec cp {} ./test/ \\; 删除/var/log下以.log结尾的7天以前的文件 find /var/log -name &apos;*.log&apos; -mtime +7 -exec rm -rf {} \\; 搜素etc下以conf结尾的且大于10k的文件，复制到root/conf目录下 find /etc/ -name &apos;*.conf&apos; -size +10k -exec cp {} /root/conf/ \\; locate locate在数据库文件中查找，而find在整个磁盘中查找 由系统定时任务负责更新数据库 find默认全部匹配，locate默认部分匹配 updatedb命令： 更新/var/lib/mlocate/mlocate.db 配置文件为：/etc/updatedb.conf whereis -b查找二进制文件 -m查找帮助文件 -s查找源代码文件 which 查找二进制文件(查用于查找程序绝对路径) grep 形式一：grep [option] [pattern] [file1,file2...] 形式二：command | grep [option] [pattern] 参数： -v 不显示匹配行 -i 忽略大小写 -n 显示行号 -r 递归搜索(当前目录下搜索所有文件) -E 支持扩展正则 -F 不按正则 -c 输出匹配行的数量 -w 匹配整个单词 -x 匹配整行 -l 只列出匹配的文件名 逻辑运算：123-a #与-o #或-not|! #非","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"find","slug":"find","permalink":"http://yoursite.com/tags/find/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}],"author":"Frdqy"},{"title":"Shell编程之（二）：函数的使用","slug":"Shell编程之（二）：函数的使用","date":"2019-12-27T14:15:17.000Z","updated":"2019-12-28T00:47:27.317Z","comments":true,"path":"2019/12/27/Shell编程之（二）：函数的使用/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2","text":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2 函数传参12345function name&#123; echo $1 #第一个参数 echo $2 #第二个参数&#125; 函数调用1name zhangsan lisi 函数返回值 返回0：成功返回1~255：失败 echo返回单一字符串或数据列表 echo $$：返回脚本执行的进程pid，用于解决脚本自身名字包含所要管 理的服务引起冲突的情况。守护进程(daemon)：通过脚本判断某个服务是否正常，不正常就启动 netstat -tnlp：查看网络状态 全局变量与局部变量的定义 不做特殊说明，shell中变量都是全局变量(不建议在大型脚本中使用全 局变量) 定义变量时使用local关键字函数内外若存在同名变量，则函数内部变量覆盖外部变量 库函数：用于封装常用函数，后缀通常以.lib结尾。引用库函数时，用. base_function即可，推荐用绝对路径(点后有一个 空格)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（一）：变量的用法","slug":"Shell编程之（一）：变量的用法","date":"2019-12-27T14:13:36.000Z","updated":"2019-12-28T00:47:16.246Z","comments":true,"path":"2019/12/27/Shell编程之（一）：变量的用法/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个","text":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个 计算子串长度1expr match $String subString 抽取子串12345$&#123;string:position:length&#125;#从position取length个$&#123;String:position&#125; #从String中的position开始$&#123;String: -position&#125; #从右往左(注意空格)$&#123;String:(position)&#125; #从左往右$expr substr $String $position $length #与二类似 变量替换：1234567$&#123;变量名#正则&#125; #从开头匹配最短删除$&#123;变量名##正则&#125; #从开头匹配最长删除$&#123;变量名%正则&#125; #从尾部匹配最短删除$&#123;变量名%%正则&#125; #从尾部匹配最长删除$&#123;变量名/旧字符串/新字符串&#125; #第一个字符串替换$&#123;变量名//旧字符串/新字符串&#125; #全部字符串替换#注意：使用expr索引计数从1开始，使用$&#123;&#125;索引计数从0开始 命令替换12``$() 数学运算1$(()) #注意与命令替换区分 应用1234ps -ef #完整格式显示所有进程grep -v #不输出查询内容，用于过滤grep本身wc -l #统计有多少行ps -ef | grep nginx | grep -v grep | wc -l #判断nginx是否存活 有类型变量1234567891011declare -r #声明变量为只读类型declare -i #声明变量为整型declare -f #在脚本中显示定义的函数和内容declare -F #在脚本中显示定义的函数declare -a #声明数组arr=(\"jones\" \"mike\" \"kobe\" \"jordan\") #以空格分隔echo $&#123;arr[@]&#125; #获取整个数组echo $&#123;#arr[@]&#125; #获取整个数组长度echo $&#123;#arr[i]&#125; #获取某个数组元素长度declare -x #声明环境变量#取消某个设置只需要“-”改为“+”即可 expr语法格式1234567expr $num1 operator $num2#操作符对照表(注意转义)num1 | num2 num1 #不为空且非0，返回num1；否则返回num2num1 &amp; num2 num1 #不为空且非0，返回num1；否则返回0#判断整数expr $num + 1 #如果执行成功则为整数(成功返回1) bc进行浮点数计算123echo \"23 + 5\" | bcecho \"23.15 + 4.3\" | bcecho \"scale=4;23.5/3.5\" | bc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Hello World","slug":"hello-world","date":"2019-12-27T05:38:00.000Z","updated":"2019-12-27T15:36:33.873Z","comments":true,"path":"2019/12/27/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}