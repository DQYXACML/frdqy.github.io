{"meta":{"title":"Frdqy的博客","subtitle":"记录默默到无闻的学习路","description":"","author":"Frdqy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-12-28T00:30:05.000Z","updated":"2019-12-28T00:30:38.637Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-28T00:23:37.000Z","updated":"2019-12-28T00:26:11.438Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-28T00:25:13.000Z","updated":"2019-12-28T00:25:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux网络属性配置","slug":"Linux网络属性配置","date":"2020-01-04T12:03:23.000Z","updated":"2020-01-04T12:04:36.753Z","comments":true,"path":"2020/01/04/Linux网络属性配置/","link":"","permalink":"http://yoursite.com/2020/01/04/Linux%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/","excerpt":"ifcfg系列ifconfig接口及地址查看和管理","text":"ifcfg系列ifconfig接口及地址查看和管理 1234567ifconfig [interface] -a：显示所有接口，包括非激活状态ifconfig INTERFACE [aftype] option | address...#启用网卡,其中大写的需要替换成具体接口名以及ip地址、子网掩码等信息ifconfig INTERFACE_NAME IP/MASK [up]ifconfig INTERFACE_NAME netmask NETMASK route路由查看和管理 查看12route [option] -n：直接显示数字信息，不进行主机名解析，效率比较高 添加123456route add [-net|-host] target [netmask Nm] [gw GW] [dev]#实例#添加条目，经由192.168.10.1访问10.10.10.0网络route add -net 10.10.10.0/8 gw 192.168.10.1#添加默认网关route add -net 0.0.0.0/0.0.0.0 gw 192.168.10.1 删除123456route del [-net|-host] target [gw GW] [dev]#实例#删除上面创建的条目route del -net 10.10.10.0/8 gw 192.168.10.1#删除默认网关route del default netstat网络连接、路由表、接口信息等网络信息查看 1234567891011121314151617#显示路由表netstat -rn -r：路由表 -n：数字格式#显示网络连接netstat [option] -t：tcp相关连接 -u：UDP相关连接 -w：raw socket相关连接 -l：处于监听状态的连接 -a：所有状态 -n：以数字格式显示 -e：扩展格式 -p：显示相关进程pid -i：显示接口信息#常用组合 -tan、-uan、-tnl、-unl、-tnlp ifup/ifdown通过读取/etc/sysconfig/network-scripts/下网卡的配置文件进行网卡的开启和禁用 hostnamectl配置主机名 1234hostnamectl status：显示当前主机名设定 set-hostname NAME：设定主机名，永久有效#centos6中需要修改/etc/sysconfig/network来修改主机名才能永久有效 DNS配置1234#在配置文件/etc/resolov.conf中修改即可，最多可以同时添加3个#nameserver为关键字，后面ip地址只能以数字形式，不能使用域名nameserver 192.168.163.2#注意/etc/hosts优先于dns配置文件，如果本地有host，那么host内的设置优先 iproute2系列ip查看和管理路由、设备、策略路由以及隧道等信息，主要用来逐渐取代ifcfg系列。 1234567891011121314151617181920212223242526272829303132333435ip [option] OBJECT &#123;COMMAND|help&#125; link：网络设备配置 show/list：显示设备的属性 set：设置设备的属性 dev NAME：指明要管理的设备 up/down：启用和关闭设备 multicast on/off：启用关闭多播 name NAME：重命名网络接口 mtu NUMBER：设置MTU大小，默认1500 netns NAME：ns为命名空间，用于将指定接口移到某个netns中，常用于构建虚拟网络 help：显示简要帮助 netns：管理网络命名空间 add NAME：增加一个网络命名空间 del NAME：删除一个网络命名空间 list：列出所有的netns exec NAME COMMAND：在netns中执行COMMAND命令 addr：管理网络接口的ip地址 add IP dev INTERFACE：指定接口增加IP地址 label NAME：为指定接口添加接口别名。用于解决ifconig命令不显示多个地址的问题 broadcast ADDRESS：广播地址，一般自动获得 scope SCOPE_VALUE：指定接口作用范围 global：全局可用 link：接口可用 host：仅本机可用 delete IP dev INTERFACE：删除指定设备的地址 show：显示地址信息 flush dev INTERFACE：清空指定接口地址 route：路由管理 add 目标网络/掩码长度 via GW dev 设备 [src]：添加路由 change：同上 repalce：同上 delete 网络：删除到指定网络的路由 show：显示路由信息 get 目标网络：获取某单个路由信息 flush：清空路由信息 ss用来取代netstat的命令 1234567891011121314151617181920ss [option] [filter] -t：tcp相关连接 -u：UDP相关连接 -w：raw socket相关连接 -l：处于监听状态的连接 -a：所有状态 -n：以数字格式显示 -e：扩展格式 -p：显示相关进程pid -i：显示接口信息 -m：显示内存用量 -o：显示计时器信息 [fileter] state [TCP-STATE] [EXPRESSION]#实例#过滤出目标端口和源端口均为22的信息ss -tan '( dport = :22 or sport = :22 )'#过滤出TCP状态为ESTABLISHED的连接ss -tan state ESTABLISHED#常见TCP状态：LISTEN,ESTABLISHED,FIN_WAIT_1,FIN_WAIT_@,SYN_SENT,SYN_RECV,CLOSED 配置文件ip上述命令修改的信息都是临时有效，若想重启后仍然有效需要修改配置文件。配置文件一般放在/etc/sysconfig/network-scripts/目录下。 参数 含义 DEVICE 此配置文件的设备名 ONBOOT 开机时是否激活 UUID 设备唯一标识 IPV6INIT 是否初始化IPV6 BOOTPROTO 激活此接口时使用什么协议配置接口属性，常用dhcp、static TYPE 接口类型 DNS1 定义第一DNS服务器指向 DNS2 定义备用DNS服务器指向 DOMAIN DNS搜索域 GATEWAY 网关 IPADDR ip地址，静态是要填写 NETMASIK/PREFIX 以长度方式指明子网掩码 USERCTL 是否允许普通用户控制此设备 PEERDNS 是否允许dhcp的dns指向覆盖本地的dns NM_CONTROLLED 是否使用nm工具 12345#centos6service SERVICE_NAME &#123;start|stop|statues|restart&#125;#centos7/8systemctl &#123;start|stop|statues|restart&#125; SERVICE_NAMEnmcli SERVICE_NAME &#123;start|stop|statues|restart&#125; route配置文件放在/etc/sysconfig/network-scripts/route-INTERFACE，有两种配置方式，不可混用。 每行一个路由条目 1TARGET via GW 每三行一个路由条目 123ADDRESS#&#x3D;TARGETNETMASK#&#x3D;MASKGATEWAY#&#x3D;NEXTHOP","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"网络配置","slug":"网络配置","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}],"author":"Frdqy"},{"title":"IF常见检测选项补充","slug":"IF常见检测选项补充","date":"2020-01-03T11:39:30.000Z","updated":"2020-01-03T11:45:54.526Z","comments":true,"path":"2020/01/03/IF常见检测选项补充/","link":"","permalink":"http://yoursite.com/2020/01/03/IF%E5%B8%B8%E8%A7%81%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9%E8%A1%A5%E5%85%85/","excerpt":"常用选项","text":"常用选项 123456789101112131415161718192021222324[ -f \"somefile\" ] ：判断是否是一个文件[ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限[ -n \"$var\" ] ：判断$var变量是否有值[ \"$a\" = \"$b\" ] ：判断$a和$b是否相等-r file 用户可读为真-w file 用户可写为真-x file 用户可执行为真-f file 文件为正规文件为真-d file 文件为目录为真-c file 文件为字符特殊文件为真-b file 文件为块特殊文件为真-s file 文件大小非0时为真-t file 当文件描述符(默认为1)指定的设备为终端时为真含条件选择的shell脚本 对于不含变量的任务简单shell脚本一般能胜任。但在执行一些决策任务时，就需要包含if/then的条件判断了。shell脚本编程支持此类运算，包括比较运算、判断文件是否存在等。基本的if条件命令选项有： - eq —比较两个参数是否相等（例如，if [ 2 –eq 5 ]）-ne —比较两个参数是否不相等-lt —参数1是否小于参数2-le —参数1是否小于等于参数2-gt —参数1是否大于参数2-ge —参数1是否大于等于参数2-f — 检查某文件是否存在（例如，if [ -f \"filename\" ]）-d — 检查目录是否存在几乎所有的判断都可以用这些比较运算符实现。脚本中常用-f命令选项在执行某一文件之前检查它是否存在。 其他选项123456789101112131415161718192021222324252627282930313233343536373839404142434445[-a file] 如果file存在则为真[-b file] 如果file存在且是一个块特殊文件则为真[-c file] 如果file存在且是一个字特殊文件则为真[-d file] 如果file文件存在且是一个目录则为真-d前的!是逻辑非例如：if [ ! -d $lcd_path/$par_date ]表示后面的那个目录不存在，则执行后面的then操作[-e file] 如果file文件存在则为真[-f file] 如果file存在且是一个普通文件则为真[-g file] 如果file存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思）[-h file] 如果file存在且是一个符号连接则为真[-k file] 如果file存在且已经设置粘制位则为真当一个目录被设置为\"粘制位\"(用chmod a+t),则该目录下的文件只能由一、超级管理员删除二、该目录的所有者删除三、该文件的所有者删除也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。具体例子如下：#ls -dl /tmpdrwxrwxrwt 4 root root .........注意other位置的t，这便是粘连位。[-p file] 如果file存在且是一个名字管道（F如果O）则为真管道是linux里面进程间通信的一种方式，其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等。[-r file] 如果file存在且是可读的则为真[-s file] 如果file存在且大小不为0则为真[-t FD] 如果文件描述符FD打开且指向一个终端则为真[-u file] 如果file存在且设置了SUID（set userID）则为真[-w file] 如果file存在且是可写的则为真[-x file] 如果file存在且是可执行的则为真[-O file] 如果file存在且属有效用户ID则为真[-G file] 如果file存在且属有效用户组则为真[-L file] 如果file存在且是一个符号连接则为真[-N file] 如果file存在and has been mod如果ied since it was last read则为真[-S file] 如果file存在且是一个套接字则为真[file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真[file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真[file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真[-o optionname] 如果shell选项“optionname”开启则为真[-z string] “string”的长度为零则为真[-n string] or [string] “string”的长度为非零non-zero则为真[sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真[string1!=string2] 如果字符串不相等则为真[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真[arg1 OP arg2] “OP”is one of –eq,-ne,-lt,-le,-gt or –ge.These arithmetic binary oprators return true if “arg1”is equal to,not equal to,less than,less than or equal to,greater than,or greater than or equal to“agr2”,respectively.“arg1”and “agr2”are integers.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"IF选项","slug":"IF选项","permalink":"http://yoursite.com/tags/IF%E9%80%89%E9%A1%B9/"}],"author":"Frdqy"},{"title":"Linux程序包管理","slug":"Linux程序包管理","date":"2020-01-03T11:38:49.000Z","updated":"2020-01-03T11:41:23.510Z","comments":true,"path":"2020/01/03/Linux程序包管理/","link":"","permalink":"http://yoursite.com/2020/01/03/Linux%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"概念将源代码编译后变成目标二进制格式，然后需要将二进制程序和其库文件、配置文件、帮助文件等打包形成一个或多个方便用户使用管理的包，这个包叫做程序包，实现这个过程的工具叫做程序包管理器。他可以帮助用户实现程序的安装、升级、卸载、查询、校验的等。","text":"概念将源代码编译后变成目标二进制格式，然后需要将二进制程序和其库文件、配置文件、帮助文件等打包形成一个或多个方便用户使用管理的包，这个包叫做程序包，实现这个过程的工具叫做程序包管理器。他可以帮助用户实现程序的安装、升级、卸载、查询、校验的等。 包管理器组成格式 程序包的组成清单。每个程序包单独实现。包括文件清单、安装或卸载脚本 数据库。整个系统维护一个数据库，存放各个包的名称版本、依赖关系、功能说明、文件路径和校验码等，数据库存放在/var/lib/rpm下，每个文件都存放不同侧重点的信息。 dpkg待补充 rpm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950rpm [option] package -i：安装 -h：hash marks输出进度条，每个'#'表示2%进度 --test：只检测不安装，通常检测依赖 --replacepkgs：重新安装 --nosignature：不检查签名，即不检查来源合法性 --nodigest：不检查包完整性信息 -U：升级或安装 -h：hash marks输出进度条，每个'#'表示2%进度 --oldpackage：程序包降级 --force：强制升级 -e：卸载 --allmatches：卸载所有匹配到的指定程序包各版本 --test：只测试卸载，检测依赖 -q：查询 #rpm &#123;-q|--query&#125; [select-options] [query-options] [select options] package_name：查询指定的程序包是否安装及其版本 -a：查询所有已安装包 -f file：查询指定的文件由哪个程序包安装生成 -p package：对未安装的程序包查询 --whatprovides capability：查询指定capability由哪个包提供 --whatrequiers capability：查询指定capability被哪个包依赖 [query-options] --changelog：查询rpm包的changelog -l：列出程序包安装生成的所有文件 -i：查询程序包相关的信息，版本号、大小等 -c：查询指定程序包的配置文件 -d：查询指定程序包文档 --provides：列出指定程序包的所有capability -R：查询指定程序包的依赖关系 --scripts：查询程序包自带的脚本 -V：校验 #校验位含义 S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P caPabilities differ -v：详细信息 -K：不安装直接检验程序合法性与完整性 --nosignature：不检查签名，即不检查来源合法性 --nodigest：不检查包完整性信息 #注意：不要对内核做升级操作，直接安装，支持多内核共存#程序包原配置文件被改动过，那么安装新版本时不会覆盖，而是将新的配置文件重命名后提供 包命名格式name-version-release.arch.rpm version：major.minor.release release.arch：rpm包的发行号 拆包由于程序打包后并不是所有功能都被用户所需要，因此引进拆包的概念。拆包后包分为主包和支包。 主包：name-version-release.arch.rpm 支包：name-function-version-release.arch.rpm ​ function：devel，utils，libs等各种开发或者插件包 依赖关系每个rpm包之间可能存在安装A就要先安装B这种情况，这叫做依赖关系。 12#查询指定程序包的依赖关系rpm -qr package 前端工具用来自动解决依赖关系。rhel系列上rpm包前端工具为yum、dnf。centos8中dnf已取代yum，不过大体命令使用格式没变，下文均使用习惯的yum来表示dnf。 仓库yum的仓库就是yum repository，它存储了大量的rpm包以及包的相关源数据，通常放置于特定目录下repodata 12345678910111213141516#仓库定义#&#123;A|B&#125;其中A为默认选项[repositoryid]name=some name for repobaseurl=url://pathenable=&#123;1|0&#125;#该仓库是否启用gpgcheck=&#123;1|0&#125;#是否启用校验gpgkey=url#指明gpg的密钥文件mirrorlist=url#镜像url文件enablegroups=&#123;1|0&#125;#是否使用组批量管理程序包failovermethod=&#123;roundrobin|priority&#125;#多个仓库的选用顺序定义#创建repo，即在指定目录下创建仓库#执行后会在指定目录下创建repodata目录，里面存放了有关各个rpm的信息#其中repmod.xml存放了各个文件的校验码，用于检查上述文件是否合法，不合法则丢弃cachecreaterepo 目录 配置文件 /etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置 12345#repo文件中的变量$releasever：当前OS的发型版的主版本号$arch：平台$basearch：基础平台$YUM0-9：自定义变量 yum命令1234567891011121314151617181920212223242526272829yum [option] &lt;commands&gt; [args...] repolist &#123;all|enable|disable&#125;：显示仓库列表 list &#123;available|installed|updates&#125;：显示程序包 install package：安装指定包，可以指定具体版本 reinstall package：重新安装 downgrade package：降级 update package：升级指定程序包 check-update：检查可用升级 remove|erase package：卸载程序包，依赖也会被卸载 info package：显示指定package详细信息 provides|whatprovides feature：查看指定特性由哪个程序包提供 clean &#123;package|all|plugins...&#125;：清理本地缓存 makecache：生成缓存 search string：根据关键字模糊搜索程序包名和summary信息 deplist package：显示指定包的依赖关系 history：查看安装、卸载等信息 groupinstall group：安装包组 groupupdate group：更新包组 grouplist：查询所有包组信息 groupinfo group：查询指定包组信息 groupremove group：删除包组 #命令行选项 --nogpgcheck：禁止进行gpgcheck -y：自动回答yes -q：静默模式 --disablerepo=repoidglob：临时禁用指定的repo --enablerepo=repoidglob：临时启用指定的repo --noplugins：禁用所有插件 安装脚本rpm包可以自带安装脚本，主要分为四类： preinstall：安装之前执行的脚本，用%pre定义，用–nopre取消 postinstall：安装之后执行的脚本，用%post定义，用–nopost取消 preuninstall：卸载真正执行前执行的脚本，用%preun定义，用–nopreun取消 postuninstall：卸载完成后执行的脚本，用%postun定义，用–nopostun取消 完整性验证数字签名的含义是指制作者首先用单向加密算法对数据进行加密并得到特征码，然后使用自己的私钥对特征码进行加密，这样别人只能使用制作者的公钥才能对文件解密，然后再使用相同的单向加密算法计算特征码，相同则文件没有问题。 12345#获取并导入信任的包制作者密钥，centos发行版的密钥通常保存在/etc/pki/rpm-gpg/目录下rpm --import /etc/pki/rpm-gpg/#不安装直接检查完整性与合法性rpm -K package 数据库重建rpm数据库放在/var/lib/rpm/下，其中存放各个包的信息。 1234#使用rpmdb命令，本身还是rpmrpm &#123;--initdb|--rebuilddb&#125; [-v] [--dbpath DIRECTORY] [--root DIRECTORY] --initdb：初始化数据库，若没有数据库则创建一个新的 --rebuilddb：重新构建数据库，构建后的数据库没有rpm事务文件，即__db.001等文件 程序包编译安装形如testname-version-release.src.rpm的包成为源程序包，需要使用rpmbuild命令制作成二进制格式的rpm包后再进行安装。 组织格式源代码一般由多个文件组成，且文件中的代码之间很有可能存在跨文件的依赖关系。因此需要使用make来管理源代码的编译。 编译安装步骤 ./configure 通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户指定的Makefile.in文件生成makefile 检查各指定功能依赖到的外部环境 一般由autoconf系列命令根据开发者的需要生成configure脚本；由automake系列命令根据用户需要生成Makefile.in文件(一般源代码文件都会提供) 1234#configure脚本，一般可以指定安装位置、指定启用的特性 --help：获取帮助 --prefix=path：指明默认安装位置，默认为/usr/local/ --sysconfdir=path：指明配置文件安装位置 make 根据makefile文件构建应用程序 make install 导出二进制程序至PATH环境变量中。即编辑文件/etc/profile.d/name.sh添加export PATH=$PATH:/yourpath 导出库文件路径。即编辑/etc/ld.so.conf.d/name.conf，添加新的库文件所在目录至此文件中。之后使用ldconfig命令让系统重新生成缓存 导出头文件。可以导出整个目录的符号链接到/usr/include/目录下即可。 导出帮助手册。编辑/etc/man.conf，添加一条MANPATH路径即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"rpm","slug":"rpm","permalink":"http://yoursite.com/tags/rpm/"},{"name":"yum","slug":"yum","permalink":"http://yoursite.com/tags/yum/"},{"name":"dnf","slug":"dnf","permalink":"http://yoursite.com/tags/dnf/"}],"author":"Frdqy"},{"title":"任务计划crontab","slug":"任务计划crontab","date":"2020-01-02T14:21:35.000Z","updated":"2020-01-02T14:26:20.789Z","comments":true,"path":"2020/01/02/任务计划crontab/","link":"","permalink":"http://yoursite.com/2020/01/02/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab/","excerpt":"概念用于设定系统定时处理某件事情的功能，例如设定数据库定时备份等。","text":"概念用于设定系统定时处理某件事情的功能，例如设定数据库定时备份等。 工具at、batch、crontab 其中at和batch是在未来的某个时间点执行一次任务，crontab是周期性的运行某任务 上述命令的执行结果会通过邮件发送给用户。这里说的邮件是本机邮件，不是互联网邮件。 at在未来某个时间点执行一次某个任务 1234567891011at [option] time -l：查看已有的任务 -f file：从file中读取作业内容，不用交互输入 -d #：删除指明作业号的作业 -c #：查看指定作业号的具体内容 -q QUEUE：指明任务执行队列，默认队列为a#运行结果以邮件方式发给提交作业的用户#时间格式为：HH:MM[YYYY-mm-dd]#模糊时间表示：noon、midnight、teatime、tomorrow#相对时间表示：now+#mins/hours/days/weeks crontab实现周期性执行某任务。需要服务程序来监控，该服务为cronle，提供了crond守护进程及相关辅助工具 12345678#注意：如果拒绝接收邮件可以用command &gt; /dev/null，还会接收错误输出#若使用command &amp;&gt; /dev/null则连错误输出也过滤掉，不推荐crontab [option] -e：编辑任务；可用于删除单个任务 -l：列出所有任务 -r：移除所有任务；即删除/var/spool/cron/下的用户文件 -i：交互式 -u user：root用户用于管理其他用户的任务，与其他命令组合使用 系统cron任务主要用于实现系统自身的维护，编辑时直接手动编辑配置文件/etc/crontab 1234567891011121314151617#cat /etc/crontab#注意：每一行定义一个周期任务；命令建议使用绝对路径；执行结果发送给MAILTO指定的用户；共7个字段[root@localhost ~]# cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 用户cron任务使用命令crontab编辑任务 12345678910111213141516171819#确保crond运行systemctl status crond.service#定义于/var/spool/cron/username中，只能用命令crontab修改，且只有6个字段(无用户名)#注意：每一行定义一个周期任务；命令建议使用绝对路径；结果发给定义文件的用户SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 注意 *表示“每…执行一次”； 在时间点上使用逗号分隔的多个值可以表示多个时间实现离散取值 在时间点上使用#-#表示连续时间取值； 可以在指定时间上定义步长*/#，#就是步长，且步长需要能整除时间； 最小单位为分钟，不能完成秒级任务(可以通过脚本每分钟循环实现) 实例 3 * * * *：每小时执行一次；每小时的第3分钟执行 3 4 * * 5：每周执行一次；每周5的4点3分执行 5 6 7 * *：每月执行一次；每月的7号的6点5分执行 7 8 9 10 *：每年执行一次；每年10月9号8点7分执行 9 8 * * 3,7：每周3和周日执行一次 0 8,20 * * 3,7：每周3和周日的8点和20点执行一次，注意前面的min位必须指定，否则每分钟都执行 0 9-18 * * 1-5：周1到周5的9点到18点每小时执行一次 */5 * * * *：每5分钟执行一次 本地电子邮件服务smtpsimple mail transmission protocol，简单邮件投递服务，只能发邮件不能收邮件 pop3post office protocol，邮局协议，用于接收邮件 mail命令1234mail [-s 'SUBJECT'] 用户 &lt; 邮件正文#邮件正文一般用输入重定向即可#注意，初次实验可能对面没有收到，因为配置文件/etc/postfix/main.cf文件中的inet_interfaces = all一开始没有设置成all而是localhost，修改后即可正常发送。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"定时任务","slug":"定时任务","permalink":"http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}],"author":"Frdqy"},{"title":"压缩与归档","slug":"压缩与归档","date":"2020-01-02T14:20:58.000Z","updated":"2020-01-02T14:26:05.361Z","comments":true,"path":"2020/01/02/压缩与归档/","link":"","permalink":"http://yoursite.com/2020/01/02/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%BD%92%E6%A1%A3/","excerpt":"目的CPU时间换磁盘空间 压缩工具compress/uncompress .z gzip/gunzip .gz bzip2/bunzip2 .bz2 xz/unxz .xz 上述工具不支持压缩目录，要压缩目录需要先归档。","text":"目的CPU时间换磁盘空间 压缩工具compress/uncompress .z gzip/gunzip .gz bzip2/bunzip2 .bz2 xz/unxz .xz 上述工具不支持压缩目录，要压缩目录需要先归档。 gzip123456789#压缩文件并删除源文件gzip [option] file -d：解压缩，相当于gunzip -#：指定压缩比，默认6，数字越大压缩比越大(1-9) -c：将压缩结果输出至标准输出例如：gzip -c file &gt; file.gz#解压缩文件，结尾必须是.gz结尾gunzip [option] file.gz#不解压直接查看压缩文件zcat file.gz bzip2123456bizip2 [option] file -d：解压缩，相当于bunzip -#：指定压缩比，默认为6，数字越大压缩比越大(1-9) -k：保留源文件#不解压直接查看压缩文件bzcat file.bz xz/unxz123456xz [option] file -d：解压缩 -#：指定压缩比，默认为6，数字越大压缩比越大(1-9) -k：保留源文件#不解压直接查看压缩文件xzcat file.xz 归档工具用于将目录内所有文件都归档成一个文件再指行压缩 tar12345678910111213141516171819202122tar [option] file -c：创建归档 -x：展开归档 -t：查看归档文件列表，不展开归档 -f path：指明要归档的文件目录 -C path：指明归档文件展开到何处 -z：使用gizp2压缩/解压缩 -j：使用bzip2压缩/解压缩 -J：使用xz压缩/解压缩 -v：显示压缩详细信息 -A：新增文件到已压缩文件中 #常用搭配#使用gzip压缩和解压缩目录文件tar zcvf 保存文件.tar.gz ./test/tar zxvf 保存文件.tar.gz ./test/#使用bzip2压缩和解压缩目录文件tar jcvf 保存文件.tar.bz ./test/tar jxvf 保存文件.tar.bz ./test/#使用xz压缩和解压缩目录文件tar Jcvf 保存文件.tar.xz ./test/tar Jxvf 保存文件.tar.xz ./test/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"tar","slug":"tar","permalink":"http://yoursite.com/tags/tar/"},{"name":"压缩","slug":"压缩","permalink":"http://yoursite.com/tags/%E5%8E%8B%E7%BC%A9/"}],"author":"Frdqy"},{"title":"磁盘管理与文件系统","slug":"磁盘管理与文件系统","date":"2020-01-02T14:20:26.000Z","updated":"2020-01-02T14:25:47.253Z","comments":true,"path":"2020/01/02/磁盘管理与文件系统/","link":"","permalink":"http://yoursite.com/2020/01/02/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"设备类型块随机访问，数据交换单位是块 字符线性访问，数据交换单位是字符","text":"设备类型块随机访问，数据交换单位是块 字符线性访问，数据交换单位是字符 设备文件关联至设备的驱动程序；设备的访问入口 命名12/dev/sd[a-z]##其中\"#\"表示任意数字 设备号 major：主设备号，区分设备类型，用于标明设备所需要的驱动程序 minor：次设备号，区分同种设备类型下的不同设备，是特定设备的访问路口 mknod命令123#用于创建块或字符设备mknod [OPTION]... NAME TYPE [MAJOR MINOR] -m MODE:创建后的设备文件的访问权限 引用方式 设备文件名 卷标 UUID 磁盘分区MBR主引导记录，处于0号扇区(每个扇区512B)。 组成部分 446B：bootloader程序，是引导启动操作系统的程序 64B：分区表，每16B标识一个分区，一共只能有4个分区，其中第四个分区使用拓展分区即可超过4个分区的限制 2B：MBR区域的有效性标识，一般为55AA GPT待补充 fdisk命令12345678910111213#用于管理磁盘分区fdisk [options] device#fdisk /dev/dev_name后将进入交互式管理接口#交互常用命令 n:创建新分区 d:删除已有分区 t:修改分区类型 l:查看已有id w:保存修改到磁盘 q:不保存直接退出 m:查看帮助信息 p:显示现有分区信息 注意：在已经分区且已经挂载其中某个分区的磁盘上创建新的分区，内核可能在创建完成后无法直接识别，使用以下命令解决 12345678#查看内核分区cat /proc/partitions#通知内核强制重读磁盘分区CentOS 5：partprobe [device]CentOS 6/7： partx -a [device] kpartx -af [device] 文件系统格式化低级格式化分区之前进行，主要划分磁道 高级格式化分区之后对分区进行，主要是创建文件系统 元数据元数据主要是文件的属性例如大小、权限、时间戳、数据块指针等信息的存放区域(不包括文件名)，一般一个文件的元数据叫做一个inode(index node)索引节点，在创建操作系统时就已经分配了一段区域作为元数据的存储区域。另外，元数据区域包括一个位图，用于标识inode节点的分配情况。 123456789101112131415#文件前的编号即为inode编号[root@localhost ~]# ls -i 34214878 anaconda-ks.cfg 34214891 initial-setup-ks.cfg#stat命令查看具体文件的inode信息[root@localhost ~]# stat ./anaconda-ks.cfg File: ./anaconda-ks.cfg Size: 1467 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 34214878 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2019-12-23 08:02:55.976905697 -0500Modify: 2019-12-23 07:16:53.042026882 -0500Change: 2019-12-23 07:16:53.042026882 -0500 Birth: - 目录目录本身也是文件，他所在的块存贮的是他的一级目录下的文件名和对于的inode映射。因此在每次查找路径时都会先查找/的inode，然后查找/的块，从/的块中的映射查找需要的文件再依次查找下去，直到找到目标文件。 12345#free查看内存看出cache占用，里面存储的就包含路径的缓存，用于加快查找映射[root@localhost ~]# free total used free shared buff/cache availableMem: 817272 522836 91996 1804 202440 140784Swap: 2097148 216064 1881084 VFS虚拟文件系统，是一个中间层，用于将各种文件系统的差异性屏蔽而向上层统一输出一个接口。 Linux文件系统：ext2~4、xfs、btrfs等 网络文件系统：nfs、cifs等 集群文件系统：gfs2、ocfs2等 内核级分布式文件系统：ceph等 伪文件系统：proc、sysfs、tmpfs等 交换文件系统：swap等 用户空间分布式文件系统：mogiles、moosefs等 管理工具创建文件系统工具mkfs：它包括一系列指令，如mkfs.ext2、mkfs.ext3、mkfs.xfs等 12345678910#ext系列专用管理工具mke2fs [option] device -t &#123;ext2|3|4&#125;：指明文件系统类型 -b &#123;1024|2048|4096&#125;：指明文件系统的块大小 -L LABLE：指明卷标 -j：创建有日志的文件系统 -i #：指明inode的比率，即每多少字节创建一个inode -N #：直接指明要给此文件系统创建的inode数量 -O [^]feature：以指定的特性创建文件系统(或取消某种特性) -m #：指定预留空间百分比，直接根数字即可 检测及修复文件系统工具fsck：它包括一系列指令，如fsck.ext2、fsck.ext3、fsck.xfs等 12345678910#e2fsck用于检查ext系列文件系统e2fsck [option] device -y：对所有问题自动回复yes -f：即使文件系统clean也要强制检测 #fsck用于通用的linux文件系统检查fsck -t type：指明文件系统类型 -a：无须交互而自动修复所有错误 -r：交互式修复(推荐) 查看管理属性工具dumpe2fs、tune2fs、blkid、e2label 1234567891011121314151617181920212223#e2label用于查看与设置ext系列的卷标e2label devicee2label device LABEL#blkid打印块属性blkid [option] device -L LABEL；根据LABEL定位设备 -U UUID：根据UUID定位设备 #tune2fs用于调整ext系列系统中可调整的参数，例如卷标和系统类型等tune2fs [option] device -l：查看超级块信息 -j：将ext2升级为ext3 -L LABEL：修改卷标 -m #：修改预留空间百分比，直接跟数字即可 -O [^]feature：开启或关闭某种特性 -o [^]mount_option：开启或关闭某种默认挂载选项，常用设置acl #dumpe2fs用于显示文件系统属性信息，包括每个块组和超级块信息dumpe2fs [option] device#修改ext系列文件系统的大小，主要用于扩展lv后扩展文件系统使用resize2fs lvname 日志主要是解决当写文件发生错误导致系统重启后恢复哪些文件而设置的机制。在磁盘上会单独分一块日志区，写文件时先写在日志区，然后再写回文件系统中。虽然会有性能损失，但是利大于弊。 文件操作删除文件将此文件指向的所有数据块标记为未使用状态并将此文件的inode标记为未使用，即只修改inode位图和数据块位图即可，因此速度很快。 移动文件当处于同一文件系统时，移动文件仅仅是改变其路径。即将当前目录的条目移到另一目录即可，文件本身并不做改变。 当处于不同文件系统时，移动文件相当于复制数据至目标文件并删除源文件，因此比较慢。 链接文件硬链接指向同一inode的不同路径 其中目录不支持硬链接；硬链接不能跨文件系统；创建硬链接会增加inode引用计数；硬链接大小相同 1234567891011121314151617181920212223#硬链接inode相同[root@localhost ~]# ls -i34214878 anaconda-ks.cfg 34214891 initial-setup-ks.cfg34214878 anaconda-ks.cfg_bak 34214894 test#第二列的“1”就是引用计数[root@localhost ~]# ls -ltotal 8-rw-------. 1 root root 1467 Dec 23 07:16 anaconda-ks.cfg-rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg#创建一个硬链接，可以看到引用计数加1#删除一个硬链接不影响另一个[root@localhost ~]# ln anaconda-ks.cfg anaconda-ks.cfg_bak[root@localhost ~]# ls -ltotal 12-rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg-rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg_bak-rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg#不能链接目录[root@localhost ~]# ln test test_1ln: test: hard link not allowed for directory 符号链接inode数据保存的指针区域保存的不是指向磁盘块的指针，而是指向那个真正文件的路径 其中，符号链接和文件是两个独立的文件，他们有各自的inode；可以对目录进行符号链接，且可以跨文件系统；删除符号链接不影响源文件，但是删除源文件影响符号链接；符号链接大小为路径字符串长度。 符号链接本身权限是777，因为用户对符号链接的访问本质还是要看源文件的权限。 123456789101112131415161718#可以看到符号链接的文件inode与硬链接和源文件不同#且源文件和符号链接的引用计数也不同，源文件引用计数不变[root@localhost ~]# ln -s anaconda-ks.cfg anaconda-ks.cfg_symbolic[root@localhost ~]# ls -litotal 1234214878 -rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg34214878 -rw-------. 2 root root 1467 Dec 23 07:16 anaconda-ks.cfg_bak34214895 lrwxrwxrwx. 1 root root 15 Jan 1 06:15 anaconda-ks.cfg_symbolic -&gt; anaconda-ks.cfg34214891 -rw-r--r--. 1 root root 1622 Dec 23 08:03 initial-setup-ks.cfg34214894 drwxr-xr-x. 2 root root 6 Jan 1 06:09 test#可以对目录进行符号链接[root@localhost ~]# ln -s test test_symbolic[root@localhost ~]# ls -li test*34214899 lrwxrwxrwx. 1 root root 4 Jan 1 06:17 test_symbolic -&gt; testtest:total 0 swap交换分区Linux上的交换分区必须使用独立的文件系统，且文件系统的system_ID必须为82 创建swap分区123mkswap [option] device -L：指明卷标 -f：强制创建 启用swap12swapon [option] device -a：启用定义在/etc/fstab文件中的所有swap设备 禁用swap1swapoff device 挂载根文件系统以外的其他文件系统想要被访问就必须先关联到根文件系统上的某个目录来实现，这个关联操作称为“挂载”，挂载目录成为”挂载点“，即用于另一个文件系统的访问入口。 此外，挂载点必须实现存在；应该使用不会被或未被其他进程使用的目录；挂载点下原有的文件会被隐藏 mount使用1234567891011121314151617181920212223242526272829303132333435#mount实现挂载mount [-fnrsvw] [-t fstype] [-o options] device dir -a：自动挂载 -r：只读挂载 -w：读写挂载 -n：默认情况下，挂载卸载会同步更新到/etc/mtab中，该选项用于禁止该功能 -t：指明挂载文件系统类型，可省略，默认通过blkid识别 -L LABEL：挂载时以卷标的方式指明设备 -U UUID：挂载时以UUID方式指明设 -o options挂载选项 sync/async：同步/异步操作 atime/noatime：文件在被访问时是否更新其访问时间戳，不启用更好 diratime/nodiratime：同上，对目录操作 remount：重新挂载，不用卸载再挂载 acl：支持使用facl ro：只读类似-r rw：读写类似-w dev/nodev：此设备上是否允许创建设备文件 exec/noexec：是否允许运行此设备上的程序文件 auto/noauto：是否允许自动挂载 user/nouser：是否允许普通用户挂载 suid/nosuid：是否允许suid和sgid特殊权限生效 defaults：rw, suid, dev, exec, auto, nouser, and async --bind 源目录 目标目录：实现目录的绑定，用作某目录临时入口 #查看当前已挂载设备mountcat /etc/mtabcat /proc/mounts#挂载光盘mount -r /dev/cdrom mount_point#挂载本地回环设备(iso等映像)mount -o loop 回环设备 mount_point umount使用123456789#umount实现卸载umount [-dflnrv] &#123;directory|device&#125;#正在被访问时无法卸载,查看被谁访问使用lsof mount_pointfuser -v mount_point#终止所有访问挂载点的进程fuser -km mount_point fstab用于定义开机自动挂载的目录。其每行定义一个要挂载的文件系统及其相关属性 属性从左自右分别为：挂载设备、挂载点、文件系统类型、挂载选项、转储频率、自检次序 挂载设备：LAEBL、UUID、伪文件系统均可 挂载选项：defaults表示默认选项，若自定义多个选项，则每个选项之间使用”，“分隔 转储频率：0表示不备份；1表示每天备份、2表示每隔一天备份 自检次序：0表示不自检；1表示首先自检，通常为根文件系统；2.3.4….依次自检 其余命令df12345#显示文件系统使用情况df [option] -l：仅显示本地文件的相关信息 -h：以人可读的形式显示，即单位换算 -i：显示inode使用状态 du1234#显示文件使用情况而非文件系统du [option] file -h：以人可读的形式显示，即单位换算 -s：显示目录下所有文件的大小总和 dd1234567891011121314#底层的复制工具#表示从path1复制文件到path2dd if=/path1 of=/path2 bs=#：表示复制单元大小 count=#：表示复制多少个bs #备份MBRdd if=/dev/sda of=/tmp/mbr.bck bs=512 count=1#破坏MBR的bootloaderdd if=/dev/zero of=/dev/sda bs=256 count=1#特殊设备/dev/null/dev/zero","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"磁盘管理","slug":"磁盘管理","permalink":"http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"},{"name":"文件系统","slug":"文件系统","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"author":"Frdqy"},{"title":"LVM2","slug":"LVM2","date":"2020-01-02T14:19:49.000Z","updated":"2020-01-03T11:43:14.672Z","comments":true,"path":"2020/01/02/LVM2/","link":"","permalink":"http://yoursite.com/2020/01/02/LVM2/","excerpt":"概念Logical Volume Manager，逻辑卷管理器。在硬盘之上创建一个逻辑层用于管理硬盘分区系统。主要用于实现文件系统的动态增加与减少，类似于btrfs的动态扩展和收缩。","text":"概念Logical Volume Manager，逻辑卷管理器。在硬盘之上创建一个逻辑层用于管理硬盘分区系统。主要用于实现文件系统的动态增加与减少，类似于btrfs的动态扩展和收缩。 术语PVphysical volume 在物理层面组成的磁盘卷，是在硬件磁盘分区基础上加上了lVM相关的管理参数，可以理解为对硬盘的划分，与分区类似。PV可以是一个磁盘也可以是一个分区。 VGvolume group 将多个PV组合而成抽象出的一个逻辑卷组，用以对外提供PE(physical extend)，即PV在逻辑上组合成VG后再经过逻辑划分成PE来使用。 PEphysical extend 在VG里划分的对外提供的块，一般为M单位大小。 LVlogical volume 由多个PE组成的逻辑卷，对LV可以进行挂载和建立文件系统操作。此时可以通过增加或删除PE实现文件系统的动态增加与减少。 管理工具PV管理工具123456#简要pv信息显示pvs#显示pv详细信息pvdisplay device#创建pv。新创建的pv没有加入VG，所以不知道PE大小pvcreate device VG管理工具123456789101112#简要vg信息显示vgs#显示vg详细信息vgdisplay#创建vg，其中device必须是已被创建的pvvgcreate [option] vgname device#扩展vg，device必须是已创建的pvvgextend vgname device#缩减vg，device必须是已创建的pv，且删除前要使用pvmove移走pv中的数据到同一vg的其他pv上vgreduce vgname device#删除vgvgremove vgname LV管理工具123456789101112131415161718#简要lv信息显示lvs#显示lv详细信息lvdisplay#创建lvlvcreate [option] lvname vgname -L：指明卷大小 -n：指明卷名称#扩展逻辑卷#注意：修改逻辑卷后要修改文件系统大小resize2fs lvnamelvextend [option] lvnam -L：指明目标大小#缩减逻辑卷#注意：缩减逻辑卷前要先卸载逻辑卷，然后做文件系统强制检测修复fsck -f lvname，之后修改文件系统大小resize2fs lvname 大小，最后再挂载即可lvreduce [option] lvname -L：指明目标大小#逻辑卷删除lvremove lvname 快照快照是LVM提供对lv上文件系统做备份的一个功能。快照也是一个或多个逻辑卷区域，只是文件类型与正常文件不同而已。快照使用写时复制，本质是一个指向要备份数据的inode的硬链接，当没有数据改变时快照和目标数据相同。当目标数据发生变化时，会把要修改的文件先拷贝到快照区域，然后再修改需要修改的目标文件，这样快照里保存的就是未修改前的文件了，这方便备份与还原。 1234567#创建快照#-p r：指明只读lvcreate -L 大小 -p r -s snapshot_name original_lv_name#利用lvconvert合并快照与源数据#注意：合并前源数据和快照都需要卸载才可以合并，且合并结束后会自动删除快照lvconvert --merge original_lv_name","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"lvm","slug":"lvm","permalink":"http://yoursite.com/tags/lvm/"}],"author":"Frdqy"},{"title":"RAID","slug":"RAID","date":"2020-01-02T14:19:14.000Z","updated":"2020-01-03T11:45:30.396Z","comments":true,"path":"2020/01/02/RAID/","link":"","permalink":"http://yoursite.com/2020/01/02/RAID/","excerpt":"概念Redundant Arrays Of Independent Disks，独立磁盘冗余阵列","text":"概念Redundant Arrays Of Independent Disks，独立磁盘冗余阵列 级别RAID-0概念条带卷(stripe) 将要存储的数据分块然后并行存储到RAID的不同的磁盘下叫做条带。 特点 读、写性能提升 可用空间：N*min(S1,S2…) 无容错能力 最小磁盘数：2,2+ RAID-1概念镜像卷(mirror) 将要存储的数据分块然后在RAID的每个磁盘上都存储一份，即镜像。 特点 读性能提升，写性能下降 可用空间：1*min(S1,S2…) 有冗余能力 最小磁盘数：2,2+ RAID-5概念使用异或校验的形式且校验码依次存储在每个磁盘上，即每个磁盘轮流当校验码，目前主要以左对称为主 特点 读写性能提升 可用空间：(N-1)*min(S1,S2…) 用冗余能力，最多坏一块 最小磁盘数：3,3+ RAID-6概念在RAID-5基础上增加一块校验盘 特点 读写性能提升 可用空间：(N-2)*min(S1,S2…) 有冗余能力，最多坏2块 最少磁盘数：4,4+ RAID-10概念先两两做成RAID-1再做成RAID-0。存储时先按RAID-0条带后再镜像存储到RAID-1中。 特点 读写性能提升 可用空间：N*(S1,S2…)/2 有冗余能力，每组镜像最多只能坏一块 RAID-01概念先两两做成RAID-0再做成RAID-1。存储时先按RAID-1镜像后再条带到RAID-0中。 特点 读写性能提升 可用空间：N*(S1,S2…)/2 有冗余能力，每组镜像最多只能坏一块 JBODJust a Bunch Of Disks 功能：将多块磁盘空间合并一个大的连续空间使用，可用空间一般为磁盘容量总和","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"raid","slug":"raid","permalink":"http://yoursite.com/tags/raid/"}],"author":"Frdqy"},{"title":"文件特殊权限","slug":"文件特殊权限","date":"2020-01-01T11:23:25.000Z","updated":"2020-01-01T11:55:55.319Z","comments":true,"path":"2020/01/01/文件特殊权限/","link":"","permalink":"http://yoursite.com/2020/01/01/%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/","excerpt":"文件特殊权限SUID、SGID、STICKY","text":"文件特殊权限SUID、SGID、STICKY 安全上下文 进程以某用户的身份运行：进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作 权限匹配模型： 判断进程的属主是否为被访问文件的属主 ，如果是则使用属主权限访问，否则进入2 判断进程的属主是否属于被访问文件的属组，如果是就使用属组权限，否则进入3 应用other模型 SUID默认情况下用户发起的进程其属主是其发起者。而设置SUID的进程执行时，其属主为进程自己的属主。 1234567891011121314151617181920#/etc/shadow无访问权限[frdqy@localhost ~]$ ls -l /etc/shadow----------. 1 root root 1434 Dec 31 22:26 /etc/shadow#以frdqy身份无法访问/etc/shadow，因为此时以使用cat的发起者权限来访问/etc/shadow，即other[frdqy@localhost ~]$ cat /etc/shadowcat: /etc/shadow: Permission denied#此时cat并没有设置SUID权限[frdqy@localhost ~]$ ls -l /bin/cat-rwxr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#用root给cat设置SUID权限后[root@localhost frdqy]# chmod u+s /bin/cat[root@localhost frdqy]# ls -l /bin/cat-rwsr-xr-x. 1 root root 51856 May 11 2019 /bin/cat#frdqy用户即可用cat查看/etc/shadow内容，因为此时cat进程使用的是其属主root权限，而不是进程的发起者[frdqy@localhost ~]$ cat /etc/shadowroot:$6$RsZ/8mPpOXX17jO8$yeL/BOfROjigWhsFEEwvF6ZDe3ldr/FJX9vvQFtzJCIWZngO5RhjLVRRgAeSg13ymfLWELIyl5R.sTBbGtP390::0:99999:7::: 注意： 如果进程属主原本有执行权限，那么加了SUID后就变成s；如果进程属主原本没有执行权限，那么加SUID后就变成S。 SGID通常对目录设置，这样其他用户在该目录下创建文件时，文件的属组全都是目录的属组，主要为了方便同组用户的修改。 1chmod g+|g- /dir STICKY用于解决某一目录下每个用户都可以删除同组其他用户的文件问题，在该目录上设置STICKY后用户只能新建和删除自己的文件，不能删除同组其他用户的文件。 12chmod o+t|o-t /dir#/tmp和/var/tmp默认具有STICKY权限 FACLfacl是文件的额外赋权机制，在原来的ugo之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制 getfacl1234getfacl fileuser:USERNAME:MODEgroup:GROUPNAME:MODE#若username为空则为属主的权限，若groupname为空则为默认属组的权限 setfacl1234567#赋权给用户setfacl -m u:USERNAME:MODE file#赋权给组setfacl -m g:GROUPNAME:MODE file#撤销赋权setfacl -x u:USERNAME:MODE filesetfacl -x g:GROUPNAME:MODE file 访问控制顺序首先，检查进程属主与被访问文件属主是否相同，相同则使用属主权限；否则检查被访问文件是否定义关于该用户的访问控制链表(facl)，有则应用该访问链表权限；否则检查此进程的属主是否是被访问文件的属组，是则应用属组访问权限，否则检查访问控制链表是否有该用属组的定义，若有则应用该属组权限。最后还不匹配就按other访问。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"}],"author":"Frdqy"},{"title":"Shell编程之（七）：脚本实战","slug":"Shell编程之（七）：脚本实战","date":"2019-12-31T08:27:45.000Z","updated":"2019-12-31T08:28:45.979Z","comments":true,"path":"2019/12/31/Shell编程之（七）：脚本实战/","link":"","permalink":"http://yoursite.com/2019/12/31/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98/","excerpt":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态","text":"脚本需求 实现一个脚本工具，该脚本提供类似supervisor功能 一键查看所有进程运行状态 按分组查看进程运行状态 拆分脚本功能app_statuesfunction get_all_process123456789101112#返回进程名称列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125; function get_all_group1234567891011121314#返回进程租列表字符串# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function get_all_group&#123; if [ ! -e $HOME_DIR/$CONFIG_FILE ];then echo \"$CONFIG_FILE is not exit.\" exit 1 else G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $G_LIST fi&#125; function get_process_pid_by_name12345678910#参数为进程pid根据进程名称查pidfunction get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $0 | awk '&#123;print $2&#125;'` echo $pids fi&#125; function get_process_info_by_pid1234567891011121314#参数为pid，根据pid查询进程状#详细信息包括：运行状态，PID，MEM信息，CPU信息，时间信息#此处不能根据进程名查，会有很多无关信息function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 \"$2==pid&#123;print &#125;\" | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $3&#125;\"` pro_mem=`ps aux | awk -v pid=$1 \"$2==pid&#123;print $4&#125;\"` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125; function is_group_in_config1234567891011121314#参数为group，判断group是否在config中# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125; function get_all_process_group1234567891011#参数为group，根据group获取processfunction get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125; function get_group_by_process12345678910111213#根据进程获取组名，参数为processfunction get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125; function format_print12345678910111213#接收两个参数，第一个为process，第二个为groupfunction format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_status=$pro_stat_time -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=$pro_stat_time 'BEGIN&#123;printf \"%-10s%-10s%-5s%-5s%-5s%-5s%-15s\\n\",p_name,g_name,p_status,p_cpu,p_mem,p_start_time&#125;' done fi &#125; function is_process_in_config123456789101112#参数为process#坑点：此处一开始将return1写在循环里导致直接跳出function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125; 主函数流程 无参数 列出配置文件中所有经常的运行信息 -g GroupName 列出GroupName组内的所有进程 process_name1 列出指定进程的运行信息 代码实现1234567891011121314151617181920212223242526if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/bin/bash## Func:Get process statues in process.cfg# define variablesHOME_DIR=\"/home/frdqy/shell/day_06/\"CONFIG_FILE=\"process.cfg\"this_pid=$$function get_all_group&#123; G_LIST=`sed -n '/\\[GROUP_LIST\\]/,/\\[/p' $HOME_DIR/$CONFIG_FILE| egrep -v \"(^$|^\\[)\"` echo $G_LIST&#125;function get_all_process&#123; for g in `get_all_group`; do P_LIST=`sed -n '/\\['$g'/,/^\\[/p' $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^\\[)\"` echo $P_LIST done&#125;function get_process_pid_by_name&#123; if [ $# -ne 1 ];then return 1 else pids=`ps -ef | grep $1 | grep -v grep |grep -v $this_pid | awk '&#123;print $2&#125;'` echo $pids fi&#125;function get_process_info_by_pid&#123; if [ `ps -ef | awk -v pid=$1 '$2==pid&#123;print&#125;' | wc -l` -eq 1 ];then proc_statues=\"RUNNING\" else proc_statues=\"STOPED\" fi pro_cpu=`ps aux | awk -v pid=$1 '$2==pid&#123;print $3&#125;'` pro_mem=`ps aux | awk -v pid=$1 '$2==pid&#123;print $4&#125;'` pro_stat_time=`ps -p $1 -o lstart | grep -v STARTED`&#125;function is_group_in_config&#123; for gn in `get_all_group`; do if [ \"$gn\" == \"$1\" ];then return fi done return 1&#125;function get_all_process_group&#123; is_group_in_config $1 if [ $? -eq 0 ];then p_list=`sed -n \"/\\[$1/,/\\[/p\" $HOME_DIR/$CONFIG_FILE | egrep -v \"(^$|^#|^\\[)\"` echo $p_list else echo \"GroupName $1 is not in process.cfg\" fi&#125;function get_group_by_process&#123; for gn in `get_all_group` do for pn in `get_all_process_group $gn` do if [ \"$pn\" == \"$1\" ];then echo $gn fi done done&#125;function format_print&#123; ps -ef | grep $1 | grep -v grep | grep -v $this_pid &amp;&gt; /dev/null if [ $? -eq 0 ];then pids=`get_process_pid_by_name $1` for pid in $pids do get_process_info_by_pid $pid awk -v p_name=$1 -v g_name=$2 -v p_id=$pid -v p_status=$proc_statues -v p_cpu=$pro_cpu -v p_mem=$pro_mem -v p_start_time=\"$pro_stat_time\" 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,p_id,p_status,p_cpu,p_mem,p_start_time&#125;' done else awk -v p_name=$1 -v g_name=$2 'BEGIN&#123;printf \"%-20s%-15s%-15s%-15s%-15s%-15s%-15s\\n\",p_name,g_name,\"NULL\",\"NULL\",\"NULL\",\"NULL\",\"NULL\"&#125;' fi &#125;function is_process_in_config&#123; for pn in `get_all_process` do if [ \"$pn\" == \"$1\" ];then return fi done return 1&#125;if [ $# -gt 0 ];then if [ \"$1\" == \"-g\" ];then shift for gn in $@; do for pn in `get_all_process_group $gn` do is_process_in_config $pn &amp;&amp; format_print $pn $gn done done else for pn in $@ do gn=`get_group_by_process $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn done fielse for pn in `get_all_process` do gn=`get_group_by_process $pn` #echo `is_process_in_config $pn` is_process_in_config $pn &amp;&amp; format_print $pn $gn donefi 小结至此，shell编程的专项学习告一段落，下面的练习都将在学习其他知识时进行巩固。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（六）：mysql","slug":"Shell编程之（六）：mysql","date":"2019-12-30T07:54:12.000Z","updated":"2019-12-30T07:57:06.178Z","comments":true,"path":"2019/12/30/Shell编程之（六）：mysql/","link":"","permalink":"http://yoursite.com/2019/12/30/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9Amysql/","excerpt":"安装mariadb1sudo apt-get install mariadb-server","text":"安装mariadb1sudo apt-get install mariadb-server 测试实例建表脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--student.sql--create tables--student tablescreate table &#96;student&#96;( &#96;s_id&#96; varchar(20), &#96;s_name&#96; varchar(20) not null default &#39;&#39;, &#96;s_birth&#96; varchar(20)not null default &#39;&#39;, &#96;s_sex&#96; varchar(20) not null default &#39;&#39;, primary key(&#96;s_id&#96;));--course tablescreate table &#96;course&#96;( &#96;c_id&#96; varchar(20), &#96;c_name&#96; varchar(20)not null default &#39;&#39;, &#96;t_id&#96; varchar(20) not null, primary key(&#96;c_id&#96;));--teacher tablecreate table &#96;teacher&#96;( &#96;t_id&#96; varchar(20), &#96;t_name&#96; varchar(20)not null default &#39;&#39;, primary key(&#96;t_id&#96;));--score tablecreate table &#96;score&#96;( &#96;s_id&#96; varchar(20), &#96;c_id&#96; varchar(20), &#96;s_score&#96; int(3), primary key(&#96;s_id&#96;,&#96;c_id&#96;));--insert student tableinsert into student values(&#39;1001&#39;,&#39;zhaolei&#39;,&#39;1990-1001-1001&#39;,&#39;male&#39;);insert into student values(&#39;1002&#39;,&#39;lihang&#39;,&#39;1990-12-21&#39;,&#39;male&#39;);insert into student values(&#39;1003&#39;,&#39;yanwen&#39;,&#39;1990-1005-20&#39;,&#39;male&#39;);insert into student values(&#39;1004&#39;,&#39;hongfei&#39;,&#39;1990-1008-1006&#39;,&#39;male&#39;);insert into student values(&#39;1005&#39;,&#39;ligang&#39;,&#39;1991-12-1001&#39;,&#39;female&#39;);insert into student values(&#39;1006&#39;,&#39;zhousheng&#39;,&#39;1992-1003-1001&#39;,&#39;female&#39;);insert into student values(&#39;1007&#39;,&#39;wangjun&#39;,&#39;1989-1007-1001&#39;,&#39;female&#39;);insert into student values(&#39;1008&#39;,&#39;zhoufei&#39;,&#39;1990-1001-20&#39;,&#39;female&#39;);--insert course tableinsert into teacher values(&#39;1001&#39;,&#39;aidisheng&#39;);insert into teacher values(&#39;1002&#39;,&#39;aiyinsitan&#39;);insert into teacher values(&#39;1003&#39;,&#39;qiansanqiang&#39;);--insert score tableinsert into score values(&#39;1001&#39;,&#39;1001&#39;,80);insert into score values(&#39;1001&#39;,&#39;1002&#39;,90);insert into score values(&#39;1001&#39;,&#39;1003&#39;,99);insert into score values(&#39;1002&#39;,&#39;1001&#39;,70);insert into score values(&#39;1002&#39;,&#39;1002&#39;,60);insert into score values(&#39;1002&#39;,&#39;1003&#39;,80);insert into score values(&#39;1003&#39;,&#39;1001&#39;,80);insert into score values(&#39;1003&#39;,&#39;1002&#39;,80);insert into score values(&#39;1003&#39;,&#39;1003&#39;,50);insert into score values(&#39;1004&#39;,&#39;1001&#39;,20);insert into score values(&#39;1004&#39;,&#39;1002&#39;,30); 建数据库1create database school; 导入数据1mysql school &lt; student.sql 授权用户1234--授予dbuser用户在所有网段都可以对school数据库进行操作，密码为123456grant all on school.* to dbuser@&#39;%&#39; identified by &#39;123456&#39;grant all on school.* to dbuser@&#39;localhost&#39; identified by &#39;123456&#39;--&#39;%&#39;表示所有主机都可以访问 使用授权用户登录12--u和p与参数间可以省略mysql -udbuser -p123456 -h localhost mysql命令参数 命令 含义 -u 用户名 -p 用户密码 -h 服务器ip地址 -D 链接的数数据库 -N 不输出列信息 -B 使用tab键代替默认交互分隔符 -e 执行sql语句 -E 垂直输出 -H 以HTML格式输出 -X 以XML格式输出 注意 -B用来不显示周围一圈分隔符时建议放在选项最后，在-e之前。 查询实例 写一个脚本，该脚本可以接收一个参数，参数为需要执行的sql语句 123#!/bin/bash#mysql -u dbuser -p123456 -D school -e \"$1\" 查询mysql任意表的数据，并将查询到的结果保存到HTML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -H -e \"$1\" &gt; $2 查询mysql任意表的数据，并将查询到的结果保存到XML文件中 123#!/bin/bash#mysql -u dbuser -p123456 -D school -X -e \"$1\" &gt; $2 导入实例需求一处理文本中的数据，将文本中的数据插入mysql ​ 1010 jerry 1991-12-13 male ​ 1011 mike 1991-12-13 female ​ 1012 tracy 1991-12-13 male ​ 1013 kobe 1991-12-13 female ​ 1014 allen 1991-12-13 male ​ 1015 curry 1991-12-13 male ​ 1016 tom 1991-12-13 female 123456789101112#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"cat data.txt | while read id name birth sexdo $mysql_conn -D $database -e \"insert into student1 values('$id','$name','$birth','$sex')\"done 需求二同上，但是分隔符变了 ​ 1010|jerry|1991-12-13|male ​ 1011|mike|1991-12-13|female ​ 1012|tracy|1991-12-13|male ​ 1013|kobe|1991-12-13|female ​ 1014|allen|1991-12-13|male ​ 1015|curry|1991-12-13|male ​ 1016|tom|1991-12-13|female 123456789101112131415#!/bin/bash#user=\"dbuser\"passwd=\"123456\"database=\"school\"#mysql_conn=\"mysql -u\"$user\" -p\"$passwd\"\"#输入分隔符指定IFS=\"|\"cat data2.txt | while read id name birth sexdo mysql -u \"dbuser\" -p\"$passwd\" -D $database -e \"insert into student2 values('$id','$name','$birth','$sex')\"done 注意需求二有一个坑，在于注释的sql语句那样写在变量里会提示找不到命令，可能时管道符号冲突问题，shll真不规范！！ mysqldump备份语法格式1mysqldump [OPTIONS] database [tables] 命令参数 命令 含义 -u 用户名 -p 密码 -h 服务器IP地址 -d 等价于–no-data，只导出表结构 -t 等价于–no-create-info，只导出数据，不导出建表语句 -A 等价于–all-databases -B 等价于–databases，导出一个或多个数据库 需求将school中的score备份，并且将备份数据通过ftp传输到xxx.xxx.xxx.xxx的/data/backup目录下 补充知识 open xxx.xxx.xxx.xxx：用于打开远端连接 user 用户名 密码：用于登录 -i：不交互 -n：自动登录 -v：显示详细信息 &lt;&lt; EOF：表示下面将输入长命令，直到遇到EOF结束，且EOF最后一行必须顶格写 12345678910111213141516171819202122232425262728#!/bin/bash#db_user=\"dbuser\"db_passwd=\"123456\"ftp_user=\"ftp_user\"ftp_passwd=\"redhat\"ftp_host=\"192.168.184.3\"dst_dir=\"/data/backup\"time_date=\"`date +%Y%m%d%H%M%S`\"file_name=\"school_score_$&#123;time_date&#125;.sql\"function auto_ftp&#123; ftp -niv &lt;&lt; EOF open $ftp_host user $ftp_user $ftp_passwd cd $dst_dir put $1 byeEOF&#125;mysqldump -u\"$db_user\" -p\"$db_passwd\" school score &gt; ./$file_name &amp;&amp; auto_ftp ./$file_name","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"Frdqy"},{"title":"Shell编程之（五）：awk","slug":"Shell编程之（五）：awk","date":"2019-12-29T13:09:12.000Z","updated":"2019-12-30T07:58:27.704Z","comments":true,"path":"2019/12/29/Shell编程之（五）：awk/","link":"","permalink":"http://yoursite.com/2019/12/29/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aawk/","excerpt":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'","text":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' 语法格式说明 语法格式 解释 BEGIN{} 正式处理数据之前执行 pattern 匹配模式 {commands} 处理命令，可能多行 END{} 处理完所有匹配数据后执行 内置变量对照表 内置变量 含义 $0 整行内容 $1-$n 当前行的第1-n个字段 NF(Number Field) 当前行的字段个数 NR(Number Row) 当前行行号，从1开始 FNR(File Number Row) 多文件每个文件行号单独计数，从0开始 FS(Field Separator) 输入字段分隔符，默认空格或tab RS(Row Separator) 输入行分隔符，默认回车换行 OFS(Output Field Separator) 输出字段分隔符，默认空格 ORS(Output Row Separator) 输出行分隔符，默认回车换行 FILENAME 当前输入的文件名字 ARGC 命令行参数个数 ARGV 命令行参数数组 printf详解printf格式说明符 格式符 含义 %s 打印字符串 %d 打印十进制数 %f 打印浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字科学计数法形式 %c 打印单个字符的ASCII printf修饰符 修饰符 含义 - 左对齐 + 右对齐 # 八进制加0，十六进制加0x 格式符实例 以字符串格式打印/etc/passwd中的第7个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以10进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以浮点数进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符，小数点保留2位 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%0.2f\\n\",$3&#125;' /etc/passwd 以16进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#x\\n\",$3&#125;' /etc/passwd 以8进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#o\\n\",$3&#125;' /etc/passwd 以科学技术格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%e\\n\",$3&#125;' /etc/passwd 模式匹配语法格式 语法格式 含义 /RegExp/ 按正则匹配 关系运算 按关系匹配 正则实例 匹配/etc/passwd文件行中包含有root字符串的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/root/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 匹配/etc/passwd文件行中以frdqy开头的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/^frdqy/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 关系实例 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段大于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&gt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7==\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段不为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7!=\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段包含3个以上数字的所有行信息 12awk 'BEGIN&#123;FS=\":\"&#125;$3~/[0-9]&#123;3,&#125;/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd#~表示匹配正则，!~表示不匹配正则 布尔实例 以:为分隔符，匹配/etc/passwd文件中包含root或frdqy的所有 1awk 'BEGIN&#123;FS=\":\"&#125;$1==\"root\" || $1==\"frdqy\"&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50并且第4个字段大于50的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50 &amp;&amp; $4&gt;50&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 动作算术运算符 运算符 含义 + 加 - 减 * 乘 除 / % 模 ^或** 乘方 ++x 返回变量x之前+1 x++ 返回变量x之后+1 x+=y x=x+y 算数实例 使用awk计算/etc/services中空白行的数量 1awk '/^$/&#123;sum++&#125;END&#123;printf \"%d\\n\",sum&#125;' /etc/services 计算下列每个同学的平均分数，将其打印在最后一列后 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 1awk 'BEGIN&#123;FS=\",\"&#125;&#123;sum=$2+$3+$4+$5;avg=sum/(NF-1);printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;' ./student.txt 条件语句123456if(条件表达式) 动作1else if(条件表达式) 动作2else 动作3 条件实例 以:为分隔符，只打印/etc/passwd中第3个字段的数值在50-100范围内的行信息 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;if($3&lt;=100&amp;&amp;$3&gt;=50)print $0&#125;' /etc/passwd 计算下列每个学生的平均分数，并且只打印平均分大于90的学生姓名和分数信息 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 12345678910111213#过长，写在scripts.awk中BEGIN&#123; FS=\",\" &#125;&#123; sum=$2+$3+$4+$5; avg=sum/(NF-1); if(avg&gt;90) printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;#用-f选项调用awk -f ./scripts.awk ./student.txt 循环语句-while12while(条件表达式) 动作 循环语句-do while123do 动作while(条件表达式) 循环语句-for12for(初始化计数器;测试计数器;计数器变更) 动作 循环实例 计算1+2+…+100的和，使用while、do while、for三种实现 1234567891011121314151617181920212223242526272829#whileBEGIN&#123; while(i&lt;=100) &#123; sum+=i; i++; &#125; print sum&#125;#do-whileBEGIN&#123; i=0; do &#123; i++ sum+=i &#125;while(i&lt;100) print sum&#125;#forBEGIN&#123; for(i=0;i&lt;=100;i++) &#123; sum+=i; &#125; print sum&#125; 字符串函数 函数名 解释 函数返回值 length 计算字符串长度 整数长度值 index(str1,str2) 在str1中找str2位置 返回索引，从1开始 tolower(str) 转换为小写 转换后的字符串 toupper(str) 转换为大写 转换后的字符串 substr(str,m,n) 从str的m个字符开始，截取n位 截取后的子串 match(str,RE) 在str中按RE查找 返回索引 split(str,arr,fs) 按fs切割字符串，结果存arr中 切割后的子串个数 sub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换一个 替换个数 gsub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换所有 替换个数 字符串处理实例 以:为分隔符，返回/etc/passwd中每行每个字段的长度 1234567891011121314151617BEGIN&#123; FS=\":\" &#125;&#123; for(i=1;i&lt;=NF;i++) &#123; if(i!=NF) &#123; printf \"%d:\",length($i) &#125; if(i==NF) &#123; printf \"%d\",length($i) printf \"\\n\" &#125; &#125;&#125; 搜索字符串”I have a dream”中出现”ea”字符串的位置 1234567891011#indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125;#match,可见match功能包含了indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为小写 1234BEGIN&#123; str=tolower(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为大写 1234BEGIN&#123; str=toupper(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop Kafka Spark Storm HDFS YARN Zookeeper”分割保存到数组arr中 12345678910BEGIN&#123; str=\"Hadoop Kafka Spark Storm HDFS YARN Zookeeper\" len=split(str,arr,\" \") i=1 while(i&lt;=len) &#123; print arr[i] i++ &#125;&#125; 搜素字符串”Transaction 2345 Start:Select * from master”第一个数字出现的位置 12345BEGIN&#123; str=\"Transaction 2345 Start:Select * from master\" i=match(str,\"[0-9]\") print i&#125; 截取字符串”Transaction start”的子串，截取条件从第4个字符开始，截取5位 12345BEGIN&#123; str=\"Transaction start\" str1=substr(str,4,5) print str1&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中第一个匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" sub(\"[0-9]+\",\"$\",str) print str&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中所有匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" gsub(\"[0-9]+\",\"$\",str) print str&#125; 选项 选项 解释 -v 参数传递 -f 指定脚本文件 -F 指定分隔符 -V 查看awk版本号 注意1234567#在使用参数传递时，引用变量建议全部使用\"\"，否则如果引用的字符串内出现空格则会报错。num=20var=\"Hello World\"#下面命令会报错，原因在于var变量字符串包含空格awk -v num2=$num -v var1=$var 'BEGIN&#123;print num2,var1&#125;'#遇到上述问题需要将引用用\"\"包含起来awk -v \"num2=$num\" -v \"var1=$var\" 'BEGIN&#123;print num2,var1&#125;' 数组shell中数组的用法1234567#定义,各元素用空格或tab分隔array=(\"Allen\" \"Mike\" \"Messi\")#遍历for a in $&#123;array[@]&#125;do echo $adone 命令 含义 echo ${array[2]} 打印元素 echo ${ #array[@]} 打印元素个数 echo ${ #array[3]} 打印元素长度 array[3]=”Li” 数组元素赋值 unset array[2];unset array 删除元素 echo ${array[@]:1:3} 分片访问 ${array[@]/e/E} 替换第一个e为E ${array[@]//e/E} 替换所有的e为E awk中数组的用法既可以数字作为数组下标也可以字符串作为数组下标 12345678910111213141516#检测数组第i+1下标是否存在if i in array#删除某个数组元素delete array[i]#删除整个数组delete array#for循环语法格式1for(初始化; 布尔表达式; 更新) &#123;//代码语句&#125; #for循环语法格式2for(变量 in 数组) &#123;//代码语句&#125; 数组实例 统计主机上所有的TCP连接状态数，按照每个TCP状态分类 1netstat -an | grep tcp | awk '&#123;array[$6]++&#125;END&#123;for(a in array) print a,array[a]&#125;' 计算横向数据总和，计算纵向数据总和 allen 80 90 87 91 mike 78 86 93 96 Kobe 66 92 82 78 Jerry 98 74 66 54 Wang 87 21 100 43 1234567891011121314151617BEGIN&#123; printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Yuwen\",\"Math\",\"English\",\"Physical\",\"total\"&#125;&#123; total=$2+$3+$4+$5 sum+=total i=2 while(i&lt;=NF) &#123; array[i]+=$i i++ &#125; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total&#125;END&#123; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",\"sum_c\",array[2],array[3],array[4],array[5],sum&#125; 实战演练模拟脚本123456789101112131415161718192021222324#!/bin/bash#数据生成脚本，模拟大型数据function create_random&#123; min=$1 max=$(($2-$min+1)) num=`date +%s%N` echo $(($num%$max+$min))&#125;INDEX=1while truedo for user in allen mike jerry tracy han lilei do COUNT=$RANDOM NUM1=`create_random 1 $COUNT` NUM2=`expr $COUNT - $NUM1` echo \"`date '+%Y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into database:product table:detal, insert $NUM1 records successfully,failed $NUM2 records\" &gt;&gt; ./db.log.`date +%Y%m%d` INDEX=`expr $INDEX + 1` donedone 需求及解决方案 统计每个人分别插入多少条record进数据库 1234567&#123; array[$6]+=$8&#125;END&#123; for (i in array) printf \"%-10s%-10d\\n\",i,array[i]&#125; 统计每个人分别插入成功多少record，失败多少record 12345678910&#123; array[$6]+=$14 array1[$6]+=$17&#125;END&#123; for (i in array) printf \"%-10s %-10d successed!\\n\",i,array[i] for (j in array1) printf \"%-10s %-10d Failed!\\n\",j,array[j]&#125; 将1和2结合起来一起输出 1234567891011121314BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125;&#125; 在3结尾加上统计全部插入记录、失败记录数、成功记录数 123456789101112131415161718BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; total_sum+=array[i] total_successed+=array1[i] total_failed+=array2[i] printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125; printf \"%-20s%-20d%-20d%-20d\\n\",\"total\",total_sum,total_successed,total_failed&#125; 查找丢失数据的现象(成功+失败不等于插入的记录数) 1234&#123; if($8!=$14+$17) print $0&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"awk","slug":"awk","permalink":"http://yoursite.com/tags/awk/"}],"author":"Frdqy"},{"title":"Shell编程之（四）：sed","slug":"Shell编程之（四）：sed","date":"2019-12-28T12:48:41.000Z","updated":"2020-01-03T11:35:41.973Z","comments":true,"path":"2019/12/28/Shell编程之（四）：sed/","link":"","permalink":"http://yoursite.com/2019/12/28/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Ased/","excerpt":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。","text":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 pattern space模式空间，每一个被pattern所匹配到的行都放到pattern space中等待进一步处理 hold space保持空间，内存中另一块可以存放sed匹配行的空间，可以使操作更灵活。但主要是用来炫技，实际很少使用。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行 sed选项 选项 含义 -n 只打印模式匹配行(静默模式) -e 直接在命令行进行sed编辑,默认选项;适用于多个匹配模式和命令 -f 编辑动作保存在文件中，指定文件执行 -r 支持扩展正则表达式 -i 直接修改文件内容 pattern用法 匹配模式 含义 10command 匹配到第10行 10,20command 匹配从第10行开始，到第20行结束 10,+5command 匹配从第10行开始，到第16行结束 /pattern1/command 匹配到pattern1的行 /pattern1/,/pattern2/command 匹配到pattern1开始，pattern2结束的行 10,/pattern1/command 匹配从第10行开始，到匹配到pattern1的行结束 /pattern1/,10command 匹配到pattern1的行开始到第10行结束 1~2command 步长为2：从第一行开始每两行执行一次 编辑命令对照表查询 编辑命令 含义 p 打印 增加 编辑命令 含义 a 往后追加 i 往前追加 r 外部文件读入，行后追加 w 匹配行写入外部文件 删除 编辑命令 含义 d 删除 修改 编辑命令 含义 s/old/new 将行内第一个old替换为new s/old/new/g 将行内全部的old替换为new s/old/new/2g 将行内从第两个old开始到最后所有的old替换为new s/old/new/ig 将行内old全部替换为new，忽略大小写 其他 编辑命令 含义 = 显示行号 n 覆盖读取下一行 N 追加读取下一行 h 把模式空间的内容覆盖至保持空间 H 把模式空间的内容追加至保持空间 g 把保持空间的内容覆盖至模式空间 G 把保持空间的内容追加至模式空间 x 把模式空间与保持空间内容互换 ！ 条件取反，例如！1表示除了第一行 后向引用12345&amp; #引用匹配的整个串\\1 #引用匹配的第一个分组，需要&quot;()&quot;将待匹配括起来#例如： sed &#39;s&#x2F;\\(l..e\\)&#x2F;\\1r&#x2F;g&#39; #表示将以l开头e结尾的四字串替换为结尾加e#注意：&amp;只能匹配整个串，而\\1可以匹配一部分串，更加灵活 注意事项当写脚本时使用sed匹配模式中包含变量时，要用双引号将整个匹配模式括起来。也可以对引用变量使用单引号单独括起来，效果一样。 查询实例 打印/etc/passwd中第20行内容 1sed -n '20p' /etc/passwd 打印/etc/passwd中从第8行开始，到第15行结束的内容 1sed -n '8,15p' /etc/passwd 打印/etc/passwd中从第8行开始，然后+5行结束的内容 1sed -n '8,+5p' /etc/passwd 打印/etc/passwd中开头匹配frdqy字符串的内容 1sed -n '/^frdqy/p' /etc/passwd 打印/etc/passwd中开头为root的行开始，到开头为frdqy的行结束的内容 1sed -n '/^root/,/^frdqy/p' /etc/passwd 打印/etc/passwd中第8行开始，到含有/sbin/nologin的内容的行结束的内容 1sed -n '8,/\\/sbin\\/nologin/p' /etc/passwd 打印/etc/passwd中第一个包含/bin/bash内容的行开始，到第五行结束的内容 1sed -n '/\\/bin\\/bash/,5p' /etc/passwd 删除实例 删除/etc/passwd中的第15行 1sed -i '15d' /etc/passwd 删除/etc/passwd中的第8行到第14行的所有内容 1sed -i '8,14d' /etc/passwd 删除/etc/passwd中的不能登录的用户(/sbin/nologin) 1sed -i '/\\/sbin\\/nologin/d' /etc/passwd 删除/etc/passwd中以mail开头的行，到以backup开头的行的所有内容 1sed -i '/^mail/,/^backup/d' /etc/passwd 删除/etc/passwd中第一个不能登录的用户，到第13行的所有内容 1sed -i '/\\/sbin\\/nologin/,13d' /etc/passwd 删除/etc/passwd中第5行到以ftp开头的所有行的内容 1sed -i '5,/^ftp/d' /etc/passwd 删除/etc/passwd中以backup开头的行到最后行的所有内容 1sed -i '/^backup/,$d' /etc/passwd 删除配置文件的注释行和空行 1234sed -i '/^#/d;/^$/d'#只能删除#在开头的注释，例如代码内部注释就删不了。sed -i '/^[:blank:]*#/d' ./nginx#只删除代码内部的注释 在配置文件中所有不以#开头的行前面添加*符号，注意：以#开头的行不添加 12sed -i 's/^[^#]/\\*&amp;/g' ./nginx#中括号外的^表示行首，中括号内的^表示取反，即不取中括号内的值。 修改实例 修改/etc/passwd中第1行中第一个root为ROOT 1sed -i '1s/root/ROOT/' /etc/passwd 修改/etc/passwd中第5行到第10行中所有的/sbin/nologin为/bin/bash 1sed -i '5,10/\\/sbin\\/nologin/\\/bin\\/bash/g' /etc/passwd 修改/etc/passwd中匹配到/sbin/nologin的行，将匹配到行中的login改为大写LOGIN 1sed -i 's/\\(\\/sbin\\/no\\)login/\\1LOGIN/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到匹配到行中包括mail的所有行，将bin改为dqy 1sed -i '/^root/,/mail/s/bin/dqy/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到第15行中所有行的nologin修改为frdqy 1sed -i '/^root/,15s/nologin/frdqy/g' /etc/passwd 修改/etc/passwd从第15行开始，到匹配到以frdqy开头的所有行的bin修改为BIN 1sed -i '15,/^frdqy/s/bin/BIN/g' /etc/passwd 追加实例 在/etc/passwd文件第10行后面追加”Add Line Behind” 1sed -i '10a Add Line Behind' /etc/passwd 在/etc/passwd文件第10行到第20行，每行后面追加”Test Line Behind” 1sed -i '10,20a Test Line Behind' /etc/passwd 在/etc/passwd文件匹配到/bin/bash的行后追加”Insert Line For /bin/bash Behind” 1sed -i '/\\/bin\\/bash/a Insert Line For /bin/bash Behind' /etc/passwd 在/etc/passwd文件匹配到以gdm开头的行，在匹配行前面追加”Add Line Before” 1sed -i '/^gdm/i Add Line Before' /etc/passwd 在/etc/passwd文件每一行前面都追加”Insert Line Before Every Line” 1sed -i 'i Insert Line Before Every Line' /etc/passwd 将/etc/fstab文件内容追加到/etc/passwd文件第 20行后 1sed -i '20r /etc/fstab' /etc/passwd 将/etc/inittab文件内容追加到/etc/passwd文件匹配/sbin/nologin行后 1sed -i '/\\/sbin\\/nologin/r /etc/inittab' /etc/passwd 将/etc/vconsole.conf文件内容追加到/etc/passwd文件匹配以sync开头到18行的所有行后 1sed -i '/^sync/,18r /etc/vconsole.conf' /etc/passwd 将/etc/passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt中 1sed -i '/\\/bin\\/bash/w /tmp/sed.txt' /etc/passwd 将/etc/passwd文件从第10行开始到匹配到frdqy开头的所有行追加到/tmp/sed_1.txt中 1sed -i '10,/^frdqy/w /tmp/sed_1.txt' /etc/passwd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"sed","slug":"sed","permalink":"http://yoursite.com/tags/sed/"}],"author":"Frdqy"},{"title":"正则知识补充","slug":"正则知识补充","date":"2019-12-27T14:19:00.000Z","updated":"2019-12-28T00:46:28.925Z","comments":true,"path":"2019/12/27/正则知识补充/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界","text":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# #表示前面的字符连续出现任意次，包括0次。. #表示任意单个字符。.* #表示任意长度的任意字符，与通配符中的*的意思相同。\\? #表示匹配其前面的字符0或1次\\+ #表示匹配其前面的字符至少1次，或者连续多次，连续次数上不封顶。\\&#123;n\\&#125; #表示前面的字符连续出现n次，将会被匹配到。\\&#123;x,y\\&#125; #表示之前的字符至少连续出现x次，最多连续出现y次，都能被匹配到，换句话说，只要之前的字符连续出现的次数在x与y之间，即可被匹配到。\\&#123;,n\\&#125; #表示之前的字符连续出现至多n次，最少0次，都会陪匹配到。\\&#123;n,\\&#125; #表示之前的字符连续出现至少n次，才会被匹配到.. #表示匹配任意单个字符S* #表示匹配前面的字符任意次，包括0次[ ] #表示匹配指定范围内的任意单个字符[^ ] #表示匹配指定范围外的任意单个字符 [[:alpha:]] #表示任意大小写字母[[:lower:]] #表示任意小写字母[[:upper:]] #表示任意大写字母[[:digit:]] #表示0到9之间的任意单个数字（包括0和9）[[:alnum:]] #表示任意数字或字母[[:space:]] #表示任意空白字符，包括&quot;空格&quot;、&quot;tab键&quot;等。[[:punct:]] #表示任意标点符号 [0-9]与[[:digit:]]等效[a-z]与[[:lower:]]等效[A-Z]与[[:upper:]]等效[a-zA-Z]与[[:alpha:]]等效[a-zA-Z0-9]与[[:alnum:]]等效 [^0-9]与[^[:digit:]]等效[^a-z]与[^[:lower:]]等效[^A-Z]与[^[:upper:]]等效[^a-zA-Z]与[^[:alpha:]]等效[^a-zA-Z0-9]与[^[:alnum:]]等效 #简短格式并非所有正则表达式解析器都可以识别\\d #表示任意单个0到9的数字\\D #表示任意单个非数字字符\\t #表示匹配单个横向制表符（相当于一个tab键）\\s #表示匹配单个空白字符，包括&quot;空格&quot;，&quot;tab制表符&quot;等\\S #表示匹配单个非空白字符\\(\\) #表示分组，且可以嵌套\\(ab\\) #表示将ab作为一个整体处理\\1 #表示引用整个表达式中第一个分组中的正则表达式\\2 #表示引用整个表达式中第二个分组中的正则表达式#若分组嵌套，以左括号为基准判断是第几个分组","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}],"author":"Frdqy"},{"title":"Shell编程之（三）：常用查找工具","slug":"Shell编程之（三）：常用查找工具","date":"2019-12-27T14:16:02.000Z","updated":"2019-12-30T07:58:04.759Z","comments":true,"path":"2019/12/27/Shell编程之（三）：常用查找工具/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n","text":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n 操作： -print(默认) -ok(与exec相似，会给用户提示) -exec 删除etc下conf结尾的文件 find ./etc -name &apos;*.conf&apos; -exec rm -rf {} \\; 复制 find ./etc -size +1M -exec cp {} ./test/ \\; 删除/var/log下以.log结尾的7天以前的文件 find /var/log -name &apos;*.log&apos; -mtime +7 -exec rm -rf {} \\; 搜素etc下以conf结尾的且大于10k的文件，复制到root/conf目录下 find /etc/ -name &apos;*.conf&apos; -size +10k -exec cp {} /root/conf/ \\; locate locate在数据库文件中查找，而find在整个磁盘中查找 由系统定时任务负责更新数据库 find默认全部匹配，locate默认部分匹配 updatedb命令： 更新/var/lib/mlocate/mlocate.db 配置文件为：/etc/updatedb.conf whereis -b查找二进制文件 -m查找帮助文件 -s查找源代码文件 which 查找二进制文件(查用于查找程序绝对路径) grep 形式一：grep [option] [pattern] [file1,file2...] 形式二：command | grep [option] [pattern] 参数： -v 不显示匹配行 -i 忽略大小写 -n 显示行号 -r 递归搜索(当前目录下搜索所有文件) -E 支持扩展正则 -F 不按正则 -c 输出匹配行的数量 -w 匹配整个单词 -x 匹配整行 -l 只列出匹配的文件名 逻辑运算：123-a #与-o #或-not|! #非","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"find","slug":"find","permalink":"http://yoursite.com/tags/find/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}],"author":"Frdqy"},{"title":"Shell编程之（二）：函数的使用","slug":"Shell编程之（二）：函数的使用","date":"2019-12-27T14:15:17.000Z","updated":"2019-12-28T00:47:27.317Z","comments":true,"path":"2019/12/27/Shell编程之（二）：函数的使用/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2","text":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2 函数传参12345function name&#123; echo $1 #第一个参数 echo $2 #第二个参数&#125; 函数调用1name zhangsan lisi 函数返回值 返回0：成功返回1~255：失败 echo返回单一字符串或数据列表 echo $$：返回脚本执行的进程pid，用于解决脚本自身名字包含所要管 理的服务引起冲突的情况。守护进程(daemon)：通过脚本判断某个服务是否正常，不正常就启动 netstat -tnlp：查看网络状态 全局变量与局部变量的定义 不做特殊说明，shell中变量都是全局变量(不建议在大型脚本中使用全 局变量) 定义变量时使用local关键字函数内外若存在同名变量，则函数内部变量覆盖外部变量 库函数：用于封装常用函数，后缀通常以.lib结尾。引用库函数时，用. base_function即可，推荐用绝对路径(点后有一个 空格)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（一）：变量的用法","slug":"Shell编程之（一）：变量的用法","date":"2019-12-27T14:13:36.000Z","updated":"2019-12-28T00:47:16.246Z","comments":true,"path":"2019/12/27/Shell编程之（一）：变量的用法/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个","text":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个 计算子串长度1expr match $String subString 抽取子串12345$&#123;string:position:length&#125;#从position取length个$&#123;String:position&#125; #从String中的position开始$&#123;String: -position&#125; #从右往左(注意空格)$&#123;String:(position)&#125; #从左往右$expr substr $String $position $length #与二类似 变量替换：1234567$&#123;变量名#正则&#125; #从开头匹配最短删除$&#123;变量名##正则&#125; #从开头匹配最长删除$&#123;变量名%正则&#125; #从尾部匹配最短删除$&#123;变量名%%正则&#125; #从尾部匹配最长删除$&#123;变量名/旧字符串/新字符串&#125; #第一个字符串替换$&#123;变量名//旧字符串/新字符串&#125; #全部字符串替换#注意：使用expr索引计数从1开始，使用$&#123;&#125;索引计数从0开始 命令替换12``$() 数学运算1$(()) #注意与命令替换区分 应用1234ps -ef #完整格式显示所有进程grep -v #不输出查询内容，用于过滤grep本身wc -l #统计有多少行ps -ef | grep nginx | grep -v grep | wc -l #判断nginx是否存活 有类型变量1234567891011declare -r #声明变量为只读类型declare -i #声明变量为整型declare -f #在脚本中显示定义的函数和内容declare -F #在脚本中显示定义的函数declare -a #声明数组arr=(\"jones\" \"mike\" \"kobe\" \"jordan\") #以空格分隔echo $&#123;arr[@]&#125; #获取整个数组echo $&#123;#arr[@]&#125; #获取整个数组长度echo $&#123;#arr[i]&#125; #获取某个数组元素长度declare -x #声明环境变量#取消某个设置只需要“-”改为“+”即可 expr语法格式1234567expr $num1 operator $num2#操作符对照表(注意转义)num1 | num2 num1 #不为空且非0，返回num1；否则返回num2num1 &amp; num2 num1 #不为空且非0，返回num1；否则返回0#判断整数expr $num + 1 #如果执行成功则为整数(成功返回1) bc进行浮点数计算123echo \"23 + 5\" | bcecho \"23.15 + 4.3\" | bcecho \"scale=4;23.5/3.5\" | bc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Hello World","slug":"hello-world","date":"2019-12-27T05:38:00.000Z","updated":"2019-12-27T15:36:33.873Z","comments":true,"path":"2019/12/27/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}