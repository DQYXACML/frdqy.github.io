{"meta":{"title":"Frdqy的博客","subtitle":"记录默默到无闻的学习路","description":"","author":"Frdqy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-12-28T00:30:05.000Z","updated":"2019-12-28T00:30:38.637Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-28T00:25:13.000Z","updated":"2019-12-28T00:25:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-28T00:23:37.000Z","updated":"2019-12-28T00:26:11.438Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Shell编程之（五）：awk","slug":"Shell编程之（五）：awk","date":"2019-12-29T13:09:12.000Z","updated":"2019-12-29T13:13:46.852Z","comments":true,"path":"2019/12/29/Shell编程之（五）：awk/","link":"","permalink":"http://yoursite.com/2019/12/29/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aawk/","excerpt":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'","text":"简介awk是一个文本处理工具，通常用于处理数据并生成结果报告。 语法格式12awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_namestdout | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' 语法格式说明 语法格式 解释 BEGIN{} 正式处理数据之前执行 pattern 匹配模式 {commands} 处理命令，可能多行 END{} 处理完所有匹配数据后执行 内置变量对照表 内置变量 含义 $0 整行内容 $1-$n 当前行的第1-n个字段 NF(Number Field) 当前行的字段个数 NR(Number Row) 当前行行号，从1开始 FNR(File Number Row) 多文件每个文件行号单独计数，从0开始 FS(Field Separator) 输入字段分隔符，默认空格或tab RS(Row Separator) 输入行分隔符，默认回车换行 OFS(Output Field Separator) 输出字段分隔符，默认空格 ORS(Output Row Separator) 输出行分隔符，默认回车换行 FILENAME 当前输入的文件名字 ARGC 命令行参数个数 ARGV 命令行参数数组 printf详解printf格式说明符 格式符 含义 %s 打印字符串 %d 打印十进制数 %f 打印浮点数 %x 打印十六进制数 %o 打印八进制数 %e 打印数字科学计数法形式 %c 打印单个字符的ASCII printf修饰符 修饰符 含义 - 左对齐 + 右对齐 # 八进制加0，十六进制加0x 格式符实例 以字符串格式打印/etc/passwd中的第7个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以10进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以浮点数进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符，小数点保留2位 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%0.2f\\n\",$3&#125;' /etc/passwd 以16进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#x\\n\",$3&#125;' /etc/passwd 以8进制格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%#o\\n\",$3&#125;' /etc/passwd 以科学技术格式打印/etc/passwd中的第3个字段，以”:”作为分隔符 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;printf \"%e\\n\",$3&#125;' /etc/passwd 模式匹配语法格式 语法格式 含义 /RegExp/ 按正则匹配 关系运算 按关系匹配 正则实例 匹配/etc/passwd文件行中包含有root字符串的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/root/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 匹配/etc/passwd文件行中以frdqy开头的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;/^frdqy/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 关系实例 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段大于50的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$3&gt;50&#123;printf \"%d\\n\",$3&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7==\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第7个字段不为/bin/bash的所有行信息 1awk 'BEGIN&#123;FS=\":\"&#125;$7!=\"/bin/bash\"&#123;printf \"%s\\n\",$7&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段包含3个以上数字的所有行信息 12awk 'BEGIN&#123;FS=\":\"&#125;$3~/[0-9]&#123;3,&#125;/&#123;printf \"%s\\n\",$0&#125;' /etc/passwd#~表示匹配正则，!~表示不匹配正则 布尔实例 以:为分隔符，匹配/etc/passwd文件中包含root或frdqy的所有 1awk 'BEGIN&#123;FS=\":\"&#125;$1==\"root\" || $1==\"frdqy\"&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 以:为分隔符，匹配/etc/passwd文件中第3个字段小于50并且第4个字段大于50的所有行 1awk 'BEGIN&#123;FS=\":\"&#125;$3&lt;50 &amp;&amp; $4&gt;50&#123;printf \"%s\\n\",$0&#125;' /etc/passwd 动作算术运算符 运算符 含义 + 加 - 减 * 乘 除 / % 模 ^或** 乘方 ++x 返回变量x之前+1 x++ 返回变量x之后+1 x+=y x=x+y 算数实例 使用awk计算/etc/services中空白行的数量 1awk '/^$/&#123;sum++&#125;END&#123;printf \"%d\\n\",sum&#125;' /etc/services 计算下列每个同学的平均分数，将其打印在最后一列后 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 1awk 'BEGIN&#123;FS=\",\"&#125;&#123;sum=$2+$3+$4+$5;avg=sum/(NF-1);printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;' ./student.txt 条件语句123456if(条件表达式) 动作1else if(条件表达式) 动作2else 动作3 条件实例 以:为分隔符，只打印/etc/passwd中第3个字段的数值在50-100范围内的行信息 1awk 'BEGIN&#123;FS=\":\"&#125;&#123;if($3&lt;=100&amp;&amp;$3&gt;=50)print $0&#125;' /etc/passwd 计算下列每个学生的平均分数，并且只打印平均分大于90的学生姓名和分数信息 Allen,80,90,96,98 Mike,93,98,92,91 Zhang,78,76,87,92 Jerry,86,89,68,92 Li,78,88,98,100 12345678910111213#过长，写在scripts.awk中BEGIN&#123; FS=\",\" &#125;&#123; sum=$2+$3+$4+$5; avg=sum/(NF-1); if(avg&gt;90) printf \"%-8s%-8d%-8d%-8d%-8d%-0.2f\\n\",$1,$2,$3,$4,$5,avg&#125;#用-f选项调用awk -f ./scripts.awk ./student.txt 循环语句-while12while(条件表达式) 动作 循环语句-do while123do 动作while(条件表达式) 循环语句-for12for(初始化计数器;测试计数器;计数器变更) 动作 循环实例 计算1+2+…+100的和，使用while、do while、for三种实现 1234567891011121314151617181920212223242526272829#whileBEGIN&#123; while(i&lt;=100) &#123; sum+=i; i++; &#125; print sum&#125;#do-whileBEGIN&#123; i=0; do &#123; i++ sum+=i &#125;while(i&lt;100) print sum&#125;#forBEGIN&#123; for(i=0;i&lt;=100;i++) &#123; sum+=i; &#125; print sum&#125; 字符串函数 函数名 解释 函数返回值 length 计算字符串长度 整数长度值 index(str1,str2) 在str1中找str2位置 返回索引，从1开始 tolower(str) 转换为小写 转换后的字符串 toupper(str) 转换为大写 转换后的字符串 substr(str,m,n) 从str的m个字符开始，截取n位 截取后的子串 match(str,RE) 在str中按RE查找 返回索引 split(str,arr,fs) 按fs切割字符串，结果存arr中 切割后的子串个数 sub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换一个 替换个数 gsub(RE,repStr,str) 在str中找符合RE的子串，将其换为repStr，换所有 替换个数 字符串处理实例 以:为分隔符，返回/etc/passwd中每行每个字段的长度 1234567891011121314151617BEGIN&#123; FS=\":\" &#125;&#123; for(i=1;i&lt;=NF;i++) &#123; if(i!=NF) &#123; printf \"%d:\",length($i) &#125; if(i==NF) &#123; printf \"%d\",length($i) printf \"\\n\" &#125; &#125;&#125; 搜索字符串”I have a dream”中出现”ea”字符串的位置 1234567891011#indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125;#match,可见match功能包含了indexBEGIN&#123; i=index(\"I have a dream\",\"ea\") print i&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为小写 1234BEGIN&#123; str=tolower(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop is a bigdata Framework”全部转换为大写 1234BEGIN&#123; str=toupper(\"Hadoop is a bigdata Framework\") print str&#125; 将字符串”Hadoop Kafka Spark Storm HDFS YARN Zookeeper”分割保存到数组arr中 12345678910BEGIN&#123; str=\"Hadoop Kafka Spark Storm HDFS YARN Zookeeper\" len=split(str,arr,\" \") i=1 while(i&lt;=len) &#123; print arr[i] i++ &#125;&#125; 搜素字符串”Transaction 2345 Start:Select * from master”第一个数字出现的位置 12345BEGIN&#123; str=\"Transaction 2345 Start:Select * from master\" i=match(str,\"[0-9]\") print i&#125; 截取字符串”Transaction start”的子串，截取条件从第4个字符开始，截取5位 12345BEGIN&#123; str=\"Transaction start\" str1=substr(str,4,5) print str1&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中第一个匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" sub(\"[0-9]+\",\"$\",str) print str&#125; 替换字符串”Transaction 243 Start,Event ID:9002”中所有匹配到数字串替换为$符号 12345BEGIN&#123; str=\"Transaction 243 Start,Event ID:9002\" gsub(\"[0-9]+\",\"$\",str) print str&#125; 选项 选项 解释 -v 参数传递 -f 指定脚本文件 -F 指定分隔符 -V 查看awk版本号 注意1234567#在使用参数传递时，引用变量建议全部使用\"\"，否则如果引用的字符串内出现空格则会报错。num=20var=\"Hello World\"#下面命令会报错，原因在于var变量字符串包含空格awk -v num2=$num -v var1=$var 'BEGIN&#123;print num2,var1&#125;'#遇到上述问题需要将引用用\"\"包含起来awk -v \"num2=$num\" -v \"var1=$var\" 'BEGIN&#123;print num2,var1&#125;' 数组shell中数组的用法1234567#定义,各元素用空格或tab分隔array=(\"Allen\" \"Mike\" \"Messi\")#遍历for a in $&#123;array[@]&#125;do echo $adone 命令 含义 echo ${array[2]} 打印元素 echo ${ #array[@]} 打印元素个数 echo ${ #array[3]} 打印元素长度 array[3]=”Li” 数组元素赋值 unset array[2];unset array 删除元素 echo ${array[@]:1:3} 分片访问 ${array[@]/e/E} 替换第一个e为E ${array[@]//e/E} 替换所有的e为E awk中数组的用法既可以数字作为数组下标也可以字符串作为数组下标 12345678910111213141516#检测数组第i+1下标是否存在if i in array#删除某个数组元素delete array[i]#删除整个数组delete array#for循环语法格式1for(初始化; 布尔表达式; 更新) &#123;//代码语句&#125; #for循环语法格式2for(变量 in 数组) &#123;//代码语句&#125; 数组实例 统计主机上所有的TCP连接状态数，按照每个TCP状态分类 1netstat -an | grep tcp | awk '&#123;array[$6]++&#125;END&#123;for(a in array) print a,array[a]&#125;' 计算横向数据总和，计算纵向数据总和 allen 80 90 87 91 mike 78 86 93 96 Kobe 66 92 82 78 Jerry 98 74 66 54 Wang 87 21 100 43 1234567891011121314151617BEGIN&#123; printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Yuwen\",\"Math\",\"English\",\"Physical\",\"total\"&#125;&#123; total=$2+$3+$4+$5 sum+=total i=2 while(i&lt;=NF) &#123; array[i]+=$i i++ &#125; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total&#125;END&#123; printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",\"sum_c\",array[2],array[3],array[4],array[5],sum&#125; 实战演练模拟脚本123456789101112131415161718192021222324#!/bin/bash#数据生成脚本，模拟大型数据function create_random&#123; min=$1 max=$(($2-$min+1)) num=`date +%s%N` echo $(($num%$max+$min))&#125;INDEX=1while truedo for user in allen mike jerry tracy han lilei do COUNT=$RANDOM NUM1=`create_random 1 $COUNT` NUM2=`expr $COUNT - $NUM1` echo \"`date '+%Y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into database:product table:detal, insert $NUM1 records successfully,failed $NUM2 records\" &gt;&gt; ./db.log.`date +%Y%m%d` INDEX=`expr $INDEX + 1` donedone 需求及解决方案 统计每个人分别插入多少条record进数据库 1234567&#123; array[$6]+=$8&#125;END&#123; for (i in array) printf \"%-10s%-10d\\n\",i,array[i]&#125; 统计每个人分别插入成功多少record，失败多少record 12345678910&#123; array[$6]+=$14 array1[$6]+=$17&#125;END&#123; for (i in array) printf \"%-10s %-10d successed!\\n\",i,array[i] for (j in array1) printf \"%-10s %-10d Failed!\\n\",j,array[j]&#125; 将1和2结合起来一起输出 1234567891011121314BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125;&#125; 在3结尾加上统计全部插入记录、失败记录数、成功记录数 123456789101112131415161718BEGIN&#123; printf \"%-20s%-20s%-20s%-20s\\n\",\"Name\",\"Sum\",\"Successed\",\"Failed\"&#125;&#123; array[$6]+=$8 array1[$6]+=$14 array2[$6]+=$17&#125;END&#123; for (i in array) &#123; total_sum+=array[i] total_successed+=array1[i] total_failed+=array2[i] printf \"%-20s%-20d%-20d%-20d\\n\",i,array[i],array1[i],array2[i] &#125; printf \"%-20s%-20d%-20d%-20d\\n\",\"total\",total_sum,total_successed,total_failed&#125; 查找丢失数据的现象(成功+失败不等于插入的记录数) 1234&#123; if($8!=$14+$17) print $0&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（四）：sed","slug":"Shell编程之（四）：sed","date":"2019-12-28T12:48:41.000Z","updated":"2019-12-28T12:54:24.791Z","comments":true,"path":"2019/12/28/Shell编程之（四）：sed/","link":"","permalink":"http://yoursite.com/2019/12/28/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Ased/","excerpt":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行","text":"基础介绍sed(Stream Editor)，流编辑器。对标准输出或文件逐行进行处理(修改、删除、打印等)。 语法格式123sed [option] \"pattern command\" file #对文件逐行操作stdout | sed [option] \"pattern command\" #对标注输出逐行操作#sed用parttern来匹配每一行，如果某一行符合pattern模式被匹配到，就用command对那一行进行执行 sed选项 选项 含义 -n 只打印模式匹配行(静默模式) -e 直接在命令行进行sed编辑,默认选项;适用于多个匹配模式和命令 -f 编辑动作保存在文件中，指定文件执行 -r 支持扩展正则表达式 -i 直接修改文件内容 pattern用法 匹配模式 含义 10command 匹配到第10行 10,20command 匹配从第10行开始，到第20行结束 10,+5command 匹配从第10行开始，到第16行结束 /pattern1/command 匹配到pattern1的行 /pattern1/,/pattern2/command 匹配到pattern1开始，pattern2结束的行 10,/pattern1/command 匹配从第10行开始，到匹配到pattern1的行结束 /pattern1/,10command 匹配到pattern1的行开始到第10行结束 编辑命令对照表查询 编辑命令 含义 p 打印 增加 编辑命令 含义 a 往后追加 i 往前追加 r 外部文件读入，行后追加 w 匹配行写入外部文件 删除 编辑命令 含义 d 删除 修改 编辑命令 含义 s/old/new 将行内第一个old替换为new s/old/new/g 将行内全部的old替换为new s/old/new/2g 将行内从第两个old开始到最后所有的old替换为new s/old/new/ig 将行内old全部替换为new，忽略大小写 其他 编辑命令 含义 = 显示行号 后向引用12345&amp; #引用匹配的整个串\\1 #引用匹配的第一个分组，需要&quot;()&quot;将待匹配括起来#例如： sed &#39;s&#x2F;\\(l..e\\)&#x2F;\\1r&#x2F;g&#39; #表示将以l开头e结尾的四字串替换为结尾加e#注意：&amp;只能匹配整个串，而\\1可以匹配一部分串，更加灵活 注意事项当写脚本时使用sed匹配模式中包含变量时，要用双引号将整个匹配模式括起来。也可以对引用变量使用单引号单独括起来，效果一样。 查询实例 打印/etc/passwd中第20行内容 1sed -n '20p' /etc/passwd 打印/etc/passwd中从第8行开始，到第15行结束的内容 1sed -n '8,15p' /etc/passwd 打印/etc/passwd中从第8行开始，然后+5行结束的内容 1sed -n '8,+5p' /etc/passwd 打印/etc/passwd中开头匹配frdqy字符串的内容 1sed -n '/^frdqy/p' /etc/passwd 打印/etc/passwd中开头为root的行开始，到开头为frdqy的行结束的内容 1sed -n '/^root/,/^frdqy/p' /etc/passwd 打印/etc/passwd中第8行开始，到含有/sbin/nologin的内容的行结束的内容 1sed -n '8,/\\/sbin\\/nologin/p' /etc/passwd 打印/etc/passwd中第一个包含/bin/bash内容的行开始，到第五行结束的内容 1sed -n '/\\/bin\\/bash/,5p' /etc/passwd 删除实例 删除/etc/passwd中的第15行 1sed -i '15d' /etc/passwd 删除/etc/passwd中的第8行到第14行的所有内容 1sed -i '8,14d' /etc/passwd 删除/etc/passwd中的不能登录的用户(/sbin/nologin) 1sed -i '/\\/sbin\\/nologin/d' /etc/passwd 删除/etc/passwd中以mail开头的行，到以backup开头的行的所有内容 1sed -i '/^mail/,/^backup/d' /etc/passwd 删除/etc/passwd中第一个不能登录的用户，到第13行的所有内容 1sed -i '/\\/sbin\\/nologin/,13d' /etc/passwd 删除/etc/passwd中第5行到以ftp开头的所有行的内容 1sed -i '5,/^ftp/d' /etc/passwd 删除/etc/passwd中以backup开头的行到最后行的所有内容 1sed -i '/^backup/,$d' /etc/passwd 删除配置文件的注释行和空行 1234sed -i '/^#/d;/^$/d'#只能删除#在开头的注释，例如代码内部注释就删不了。sed -i '/^[:blank:]*#/d' ./nginx#只删除代码内部的注释 在配置文件中所有不以#开头的行前面添加*符号，注意：以#开头的行不添加 12sed -i 's/^[^#]/\\*&amp;/g' ./nginx#中括号外的^表示行首，中括号内的^表示取反，即不取中括号内的值。 修改实例 修改/etc/passwd中第1行中第一个root为ROOT 1sed -i '1s/root/ROOT/' /etc/passwd 修改/etc/passwd中第5行到第10行中所有的/sbin/nologin为/bin/bash 1sed -i '5,10/\\/sbin\\/nologin/\\/bin\\/bash/g' /etc/passwd 修改/etc/passwd中匹配到/sbin/nologin的行，将匹配到行中的login改为大写LOGIN 1sed -i 's/\\(\\/sbin\\/no\\)login/\\1LOGIN/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到匹配到行中包括mail的所有行，将bin改为dqy 1sed -i '/^root/,/mail/s/bin/dqy/g' /etc/passwd 修改/etc/passwd从匹配到以root开头的行，到第15行中所有行的nologin修改为frdqy 1sed -i '/^root/,15s/nologin/frdqy/g' /etc/passwd 修改/etc/passwd从第15行开始，到匹配到以frdqy开头的所有行的bin修改为BIN 1sed -i '15,/^frdqy/s/bin/BIN/g' /etc/passwd 追加实例 在/etc/passwd文件第10行后面追加”Add Line Behind” 1sed -i '10a Add Line Behind' /etc/passwd 在/etc/passwd文件第10行到第20行，每行后面追加”Test Line Behind” 1sed -i '10,20a Test Line Behind' /etc/passwd 在/etc/passwd文件匹配到/bin/bash的行后追加”Insert Line For /bin/bash Behind” 1sed -i '/\\/bin\\/bash/a Insert Line For /bin/bash Behind' /etc/passwd 在/etc/passwd文件匹配到以gdm开头的行，在匹配行前面追加”Add Line Before” 1sed -i '/^gdm/i Add Line Before' /etc/passwd 在/etc/passwd文件每一行前面都追加”Insert Line Before Every Line” 1sed -i 'i Insert Line Before Every Line' /etc/passwd 将/etc/fstab文件内容追加到/etc/passwd文件第 20行后 1sed -i '20r /etc/fstab' /etc/passwd 将/etc/inittab文件内容追加到/etc/passwd文件匹配/sbin/nologin行后 1sed -i '/\\/sbin\\/nologin/r /etc/inittab' /etc/passwd 将/etc/vconsole.conf文件内容追加到/etc/passwd文件匹配以sync开头到18行的所有行后 1sed -i '/^sync/,18r /etc/vconsole.conf' /etc/passwd 将/etc/passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt中 1sed -i '/\\/bin\\/bash/w /tmp/sed.txt' /etc/passwd 将/etc/passwd文件从第10行开始到匹配到frdqy开头的所有行追加到/tmp/sed_1.txt中 1sed -i '10,/^frdqy/w /tmp/sed_1.txt' /etc/passwd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"正则知识补充","slug":"正则知识补充","date":"2019-12-27T14:19:00.000Z","updated":"2019-12-28T00:46:28.925Z","comments":true,"path":"2019/12/27/正则知识补充/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界","text":"123456^ #行首$ #行尾\\&lt; #词首\\&gt; #词尾\\b #单词边界\\B #单词非边界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# #表示前面的字符连续出现任意次，包括0次。. #表示任意单个字符。.* #表示任意长度的任意字符，与通配符中的*的意思相同。\\? #表示匹配其前面的字符0或1次\\+ #表示匹配其前面的字符至少1次，或者连续多次，连续次数上不封顶。\\&#123;n\\&#125; #表示前面的字符连续出现n次，将会被匹配到。\\&#123;x,y\\&#125; #表示之前的字符至少连续出现x次，最多连续出现y次，都能被匹配到，换句话说，只要之前的字符连续出现的次数在x与y之间，即可被匹配到。\\&#123;,n\\&#125; #表示之前的字符连续出现至多n次，最少0次，都会陪匹配到。\\&#123;n,\\&#125; #表示之前的字符连续出现至少n次，才会被匹配到.. #表示匹配任意单个字符S* #表示匹配前面的字符任意次，包括0次[ ] #表示匹配指定范围内的任意单个字符[^ ] #表示匹配指定范围外的任意单个字符 [[:alpha:]] #表示任意大小写字母[[:lower:]] #表示任意小写字母[[:upper:]] #表示任意大写字母[[:digit:]] #表示0到9之间的任意单个数字（包括0和9）[[:alnum:]] #表示任意数字或字母[[:space:]] #表示任意空白字符，包括&quot;空格&quot;、&quot;tab键&quot;等。[[:punct:]] #表示任意标点符号 [0-9]与[[:digit:]]等效[a-z]与[[:lower:]]等效[A-Z]与[[:upper:]]等效[a-zA-Z]与[[:alpha:]]等效[a-zA-Z0-9]与[[:alnum:]]等效 [^0-9]与[^[:digit:]]等效[^a-z]与[^[:lower:]]等效[^A-Z]与[^[:upper:]]等效[^a-zA-Z]与[^[:alpha:]]等效[^a-zA-Z0-9]与[^[:alnum:]]等效 #简短格式并非所有正则表达式解析器都可以识别\\d #表示任意单个0到9的数字\\D #表示任意单个非数字字符\\t #表示匹配单个横向制表符（相当于一个tab键）\\s #表示匹配单个空白字符，包括&quot;空格&quot;，&quot;tab制表符&quot;等\\S #表示匹配单个非空白字符\\(\\) #表示分组，且可以嵌套\\(ab\\) #表示将ab作为一个整体处理\\1 #表示引用整个表达式中第一个分组中的正则表达式\\2 #表示引用整个表达式中第二个分组中的正则表达式#若分组嵌套，以左括号为基准判断是第几个分组","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}],"author":"Frdqy"},{"title":"Shell编程之（三）：常用查找工具","slug":"Shell编程之（三）：常用查找工具","date":"2019-12-27T14:16:02.000Z","updated":"2019-12-28T00:53:51.327Z","comments":true,"path":"2019/12/27/Shell编程之（三）：常用查找工具/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n","text":"find命令： 语法格式：find [路径] [选项] [操作] 选项： -name(大小写敏感) -iname(忽略大小写) -perm -prune(排除某些目录，通常与path一起使用) 如：find . -path ./test -prune -o -type f(-o表示或者) -user -group -mtime -n | +n -nogroup(无效组) -nouser(无效用户) -newer file1 ! file2 -type -size -n | +n -mindepth n -maxdepth n 操作： -print(默认) -ok(与exec相似，会给用户提示) -exec 删除etc下conf结尾的文件 find ./etc -name &apos;*.conf&apos; -exec rm -rf {} \\; 复制 find ./etc -size +1M -exec cp {} ./test/ \\; 删除/var/log下以.log结尾的7天以前的文件 find /var/log -name &apos;*.log&apos; -mtime +7 -exec rm -rf {} \\; 搜素etc下以conf结尾的且大于10k的文件，复制到root/conf目录下 find /etc/ -name &apos;*.conf&apos; -size +10k -exec cp {} /root/conf/ \\; locate locate在数据库文件中查找，而find在整个磁盘中查找 由系统定时任务负责更新数据库 find默认全部匹配，locate默认部分匹配 updatedb命令： 更新/var/lib/mlocate/mlocate.db 配置文件为：/etc/updatedb.conf whereis -b查找二进制文件 -m查找帮助文件 -s查找源代码文件 which 查找二进制文件(查用于查找程序绝对路径) grep 形式一：grep [option] [pattern] [file1,file2...] 形式二：command | grep [option] [pattern] 参数： -v 不显示匹配行 -i 忽略大小写 -n 显示行号 -r 递归搜索(当前目录下搜索所有文件) -E 支持扩展正则 -F 不按正则 -c 输出匹配行的数量 -w 匹配整个单词 -x 匹配整行 -l 只列出匹配的文件名 逻辑运算：123-a #与-o #或-not|! #非","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（二）：函数的使用","slug":"Shell编程之（二）：函数的使用","date":"2019-12-27T14:15:17.000Z","updated":"2019-12-28T00:47:27.317Z","comments":true,"path":"2019/12/27/Shell编程之（二）：函数的使用/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2","text":"函数命名格式12345678910111213name() &#123; command1 command2 &#125;function name &#123; command1 command2 &#125;#调用函数时直接用函数名调用即可，像一条shell命令一样#函数内部参数使用$1,$2...$n#调用函数例子：function_name $1 $2 函数传参12345function name&#123; echo $1 #第一个参数 echo $2 #第二个参数&#125; 函数调用1name zhangsan lisi 函数返回值 返回0：成功返回1~255：失败 echo返回单一字符串或数据列表 echo $$：返回脚本执行的进程pid，用于解决脚本自身名字包含所要管 理的服务引起冲突的情况。守护进程(daemon)：通过脚本判断某个服务是否正常，不正常就启动 netstat -tnlp：查看网络状态 全局变量与局部变量的定义 不做特殊说明，shell中变量都是全局变量(不建议在大型脚本中使用全 局变量) 定义变量时使用local关键字函数内外若存在同名变量，则函数内部变量覆盖外部变量 库函数：用于封装常用函数，后缀通常以.lib结尾。引用库函数时，用. base_function即可，推荐用绝对路径(点后有一个 空格)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Shell编程之（一）：变量的用法","slug":"Shell编程之（一）：变量的用法","date":"2019-12-27T14:13:36.000Z","updated":"2019-12-28T00:47:16.246Z","comments":true,"path":"2019/12/27/Shell编程之（一）：变量的用法/","link":"","permalink":"http://yoursite.com/2019/12/27/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个","text":"计算字符串长度1$&#123;#String&#125; 1expr length \"$String\" 获取子串在字符串中的索引位置1expr index $String $subString #切片,字符查找，返回第一个 计算子串长度1expr match $String subString 抽取子串12345$&#123;string:position:length&#125;#从position取length个$&#123;String:position&#125; #从String中的position开始$&#123;String: -position&#125; #从右往左(注意空格)$&#123;String:(position)&#125; #从左往右$expr substr $String $position $length #与二类似 变量替换：1234567$&#123;变量名#正则&#125; #从开头匹配最短删除$&#123;变量名##正则&#125; #从开头匹配最长删除$&#123;变量名%正则&#125; #从尾部匹配最短删除$&#123;变量名%%正则&#125; #从尾部匹配最长删除$&#123;变量名/旧字符串/新字符串&#125; #第一个字符串替换$&#123;变量名//旧字符串/新字符串&#125; #全部字符串替换#注意：使用expr索引计数从1开始，使用$&#123;&#125;索引计数从0开始 命令替换12``$() 数学运算1$(()) #注意与命令替换区分 应用1234ps -ef #完整格式显示所有进程grep -v #不输出查询内容，用于过滤grep本身wc -l #统计有多少行ps -ef | grep nginx | grep -v grep | wc -l #判断nginx是否存活 有类型变量1234567891011declare -r #声明变量为只读类型declare -i #声明变量为整型declare -f #在脚本中显示定义的函数和内容declare -F #在脚本中显示定义的函数declare -a #声明数组arr=(\"jones\" \"mike\" \"kobe\" \"jordan\") #以空格分隔echo $&#123;arr[@]&#125; #获取整个数组echo $&#123;#arr[@]&#125; #获取整个数组长度echo $&#123;#arr[i]&#125; #获取某个数组元素长度declare -x #声明环境变量#取消某个设置只需要“-”改为“+”即可 expr语法格式1234567expr $num1 operator $num2#操作符对照表(注意转义)num1 | num2 num1 #不为空且非0，返回num1；否则返回num2num1 &amp; num2 num1 #不为空且非0，返回num1；否则返回0#判断整数expr $num + 1 #如果执行成功则为整数(成功返回1) bc进行浮点数计算123echo \"23 + 5\" | bcecho \"23.15 + 4.3\" | bcecho \"scale=4;23.5/3.5\" | bc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"Frdqy"},{"title":"Hello World","slug":"hello-world","date":"2019-12-27T05:38:00.000Z","updated":"2019-12-27T15:36:33.873Z","comments":true,"path":"2019/12/27/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StratCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}