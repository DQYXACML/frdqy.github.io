<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="虚拟化虚拟化技术可以实现将多台物理主机虚拟为一个逻辑主机或者将一台物理主机虚拟为多台逻辑主机，其中后者现在被广泛运用。虚拟化技术可以分为完全虚拟化和半虚拟化，其中完全虚拟化又分为硬件辅助虚拟化和软件辅助虚拟化。">
<meta property="og:type" content="article">
<meta property="og:title" content="docker详解">
<meta property="og:url" content="http://yoursite.com/2020/01/28/docker%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Frdqy的博客">
<meta property="og:description" content="虚拟化虚拟化技术可以实现将多台物理主机虚拟为一个逻辑主机或者将一台物理主机虚拟为多台逻辑主机，其中后者现在被广泛运用。虚拟化技术可以分为完全虚拟化和半虚拟化，其中完全虚拟化又分为硬件辅助虚拟化和软件辅助虚拟化。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-01-28T10:02:04.000Z">
<meta property="article:modified_time" content="2020-01-28T10:03:04.307Z">
<meta property="article:author" content="Frdqy">
<meta property="article:tag" content="docker">
<meta property="article:tag" content="容器">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/01/28/docker%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>docker详解 | Frdqy的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Frdqy的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Frdqy的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录默默到无闻的学习路</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">75</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">48</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/28/docker%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Frdqy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frdqy的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-28 18:02:04 / 修改时间：18:03:04" itemprop="dateCreated datePublished" datetime="2020-01-28T18:02:04+08:00">2020-01-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>虚拟化技术可以实现将多台物理主机虚拟为一个逻辑主机或者将一台物理主机虚拟为多台逻辑主机，其中后者现在被广泛运用。虚拟化技术可以分为完全虚拟化和半虚拟化，其中完全虚拟化又分为硬件辅助虚拟化和软件辅助虚拟化。</p>
<a id="more"></a>
<h4 id="软件辅助全虚拟化"><a href="#软件辅助全虚拟化" class="headerlink" title="软件辅助全虚拟化"></a>软件辅助全虚拟化</h4><p>该虚拟化方式是将虚拟化管理器(VMM)运行在用户态中。当虚拟机里的程序需要执行系统调用时，CPU并不知道它是虚拟机的指令还是真正物理机的指令，因此需要VMM来实现对每条虚拟机指令的捕获和翻译，此时VMM充当一个中间人的角色，虚拟机通过VMM来调用真正的物理资源，而实际上是VMM来向物理机的内核申请使用物理资源。对于物理机内核来说，VMM只是一个用户空间的普通进程；对于虚拟机内核来说，它认为自己就是真正内核，这就是软件辅助虚拟化。这个过程由于需要VMM参与，导致其效率不高，现在逐渐被硬件辅助全虚拟化取代。</p>
<h4 id="硬件辅助全虚拟化"><a href="#硬件辅助全虚拟化" class="headerlink" title="硬件辅助全虚拟化"></a>硬件辅助全虚拟化</h4><p>该虚拟化是在CPU硬件层面支持虚拟化技术后实现的新技术。对于虚拟内核来说，只需要将标志位设置为虚拟状态，那么就可以直接在CPU上执行大部分指令，不需要VMM作转述。因为开启了虚拟化技术的CPU有两个新的执行状态，他们是Non-Root和Root。VMM运行在Root模式(装载在物理内核中，相当于本身就是物理内核)，虚拟机运行在Non-Root模式的Ring0状态，这就意味这它可以直接执行特权指令，不需要VMM转述，从而大大提高虚拟机的执行效率。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是虚拟化的一种方案，但它不是主机级别的虚拟化，而是应用级别的虚拟化。它将操作系统虚拟化，把物理上的操作系统虚拟为逻辑上的多个操作系统，不同的操作系统有自己的用户空间，用户空间相互隔离，彼此意识不到对方的存在，整个容器中只运行它本身一个进程。</p>
<h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>是内核实现的修改进程视图的机制，它实现了容器间资源的隔离。Namespaces包含种资源，分别是：Mount、UTS、IPC、PID、Network和User。每次创建并启动一个容器时，就指定了Namespaces的参数(通过clone()系统调用实现)，每个容器只能看到当前分配给他们的Namespaces内的内容。</p>
<table>
<thead>
<tr>
<th>namespace</th>
<th>系统调用参数</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名和域名</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、共享内存、消息队列等</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、端口、网络栈等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>文件系统挂载点</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和组</td>
</tr>
</tbody></table>
<h4 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h4><p>cgroup，即Control group。该机制实现的是将系统资源分配到指定的内存中进程组上。和Namespaces类似，但是实现的目的是为了对各组进程进行统一的资源监控和限制(Namespces是为了实现隔离)。它将进程分组，将有限的资源对这些组进行分配。每个进程组可以再细分组，分配给该组的系统资源在组内共享。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#extra仓库版本较老，使用镜像安装</span></span><br><span class="line"><span class="comment">#首先下载repo仓库进行本地制作，放在本地/etc/yum.repo.d/目录下</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#仓库中指向的仍然是docker官方，速度很慢，此处在vim中修改为清华镜像(全局替换)</span></span><br><span class="line">%s@https://download.docker.com/@https://mirrors.tuna.tsinghua.edu.cn/docker-ce/@</span><br><span class="line"><span class="comment">#更新本地repo缓存</span></span><br><span class="line">yum repolist</span><br><span class="line"><span class="comment">#指向安装</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment">#若之前安装过extra仓库的docker，需要卸载如下包，否则会冲突导致docker-ce无法安装</span></span><br><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>docker配置文件为：/etc/docker/daemon.json，该文件初始并未创建，需要手动创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#编辑该文件，添加阿里云镜像加速，该链接在阿里云容器云上获取</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://pjfb83d0.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#如果docker已运行需要重载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="image"><a href="#image" class="headerlink" title="image"></a>image</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker image COMMANDS</span><br><span class="line">	build：根据Dockerfile创建一个镜像</span><br><span class="line">	<span class="built_in">history</span>：显示image使用历史</span><br><span class="line">	import：</span><br><span class="line">	inspect：显示image的详细信息</span><br><span class="line">	load：从标准输入或者归档文件创建一个image</span><br><span class="line">		-i：指明输入文件</span><br><span class="line">	ls：显示所有image</span><br><span class="line">	prune：删除没有使用的image</span><br><span class="line">	pull：从docker hub上拉去指定image</span><br><span class="line">	push：将image推送到docker hub上，或指定的docker镜像服务器</span><br><span class="line">	rm：删除指定镜像</span><br><span class="line">	save：保存指定image到归档文件中</span><br><span class="line">		-o：指明保存文件</span><br><span class="line">	tag：创建一个image的tag标签</span><br></pre></td></tr></table></figure>

<h5 id="container"><a href="#container" class="headerlink" title="container"></a>container</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker container COMMANDS</span><br><span class="line">	attach</span><br><span class="line">	commit：将最上层的可写层创建为image的一层，相当于基于容器制作镜像</span><br><span class="line">	cp：在本地文件系统和容器内的文件系统中复制文件</span><br><span class="line">	create：根据image创建一个容器</span><br><span class="line">	diff</span><br><span class="line">	<span class="built_in">exec</span>：在容器中运行命令</span><br><span class="line">	<span class="built_in">export</span></span><br><span class="line">	inspect：显示容器的详细信息</span><br><span class="line">	<span class="built_in">kill</span>：杀死一个运行的容器，相当于<span class="built_in">kill</span> -9</span><br><span class="line">	logs：获取容器运行进程的日志</span><br><span class="line">	ls：显示容器</span><br><span class="line">	pause：暂停所有容器</span><br><span class="line">	port</span><br><span class="line">	prune：删除所有停止状态的容器</span><br><span class="line">	rename：重命名容器</span><br><span class="line">	restart：重启容器</span><br><span class="line">	rm：删除容器</span><br><span class="line">	run：在容器中运行命令，需要指明image</span><br><span class="line">		-i：保持交互式连接</span><br><span class="line">		-t：启动终端</span><br><span class="line">	start：启动容器</span><br><span class="line">	stats</span><br><span class="line">	stop：停止运行的容器，相当于<span class="built_in">kill</span> -15</span><br><span class="line">	top：基于资源消耗比率显示容器</span><br><span class="line">	unpause：继续暂停的容器</span><br><span class="line">	update</span><br><span class="line">	<span class="built_in">wait</span></span><br></pre></td></tr></table></figure>

<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>Docker镜像含有启动容器所需要的文件系统及其内容。因此，其用于创建并启动docker容器。</p>
<p>Docker镜像采用分层构建机制，最底层为bootfs，上层为rootfs</p>
<ul>
<li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约资源</li>
<li>rootfs：位于bootfs之上，表现为docker容器的根文件系统。在传统模式中系统启动时内核挂载rootfs时会首先将其挂载为只读模式，完成一系列自检操作后将其重新挂载为读写模式。而在docker中，rootfs由内核挂载为只读模式，而后通过联合挂载技术额外挂载一个可写层。因此由镜像创建容器时，实际就是在基础镜像层上添加一个可写的image层，所有的写操作都在此层。因此在删除容器时实际也是删除该可写image层，源镜像保持不变。</li>
</ul>
<p>一个完整的镜像是由多个镜像分层联合挂载而来。bootfs作为最底层在引导出用户空间的根文件系统后就自动卸载。之后有Base image基本镜像层，该层主要是封装各种操作系统；其次是各种应用程序层，比如vim编辑器层、nginx服务层等。这些多个镜像一层一层叠加形成完整的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从指定镜像仓库中拉取镜像</span></span><br><span class="line">docker pull &lt;registry&gt;[:&lt;port&gt;]/[&lt;namespace&gt;/]&lt;name&gt;:&lt;tag&gt;</span><br><span class="line">	&lt;registry&gt;[:&lt;port&gt;]：指明仓库服务器和端口(默认443https)，如果是docker hub则可省略(一般都省略)</span><br><span class="line">	&lt;namespace&gt;：指明用户空间(可以是用户名、组织名等)，如果是顶层仓库可以省略</span><br><span class="line">	&lt;name&gt;:&lt;tag&gt;：仓库名和标签名</span><br></pre></td></tr></table></figure>

<h5 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h5><p>镜像的制作有三种途径：</p>
<p>基于容器的制作，即在<strong>运行</strong>的容器中使用commit命令将镜像最上层的可写层合并到原始镜像中变成新镜像；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建镜像</span></span><br><span class="line">docker commit [options] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">	[REPOSITORY[:TAG]]：指定仓库名和标签名，不指明则为none</span><br><span class="line">	-p：在制作镜像时暂停容器</span><br><span class="line"></span><br><span class="line"><span class="comment">#打标签</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录docker仓库，阿里云比较快</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#push镜像，如果不是dockerhub需要指明服务器地址、仓库名等</span></span><br><span class="line">docker push IMAGE_NAME[:TAG]</span><br></pre></td></tr></table></figure>

<p>基于Dockerfile的build命令制作；</p>
<p>基于Docker Hub的automated build制作，它本质也是基于Dockerfile来制作，它需要监视联合github，每次用户对Dockerfile的修改先推送到github上，然后Docker Hub会不断监视Github是否发生改动，如果有改动就拉取过来基于Dockerfile进行镜像制作。</p>
<h5 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先登录Registry，默认不指定SERVER为docker hub</span></span><br><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">	-p password：指明密码</span><br><span class="line">	-u username：指明用户名</span><br><span class="line">	SERVER：指定Registry地址</span><br><span class="line"></span><br><span class="line"><span class="comment">#给指定镜像打标签，注意username必须是顶层仓库名，如果不是顶层仓库还需要依次指明仓库名</span></span><br><span class="line">docker tag image username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送，按照打标签的格式推上去即可</span></span><br><span class="line">docker push username/repository:tag</span><br></pre></td></tr></table></figure>

<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>docker网络通信主要有四种方式：bridge、host、none、container</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Bridge</td>
<td>使用虚拟网卡和虚拟交换机实现</td>
</tr>
<tr>
<td>Host</td>
<td>namespace不分配网络资源，公用物理主机网络资源</td>
</tr>
<tr>
<td>None</td>
<td>没有网卡，不能进行网络通信</td>
</tr>
<tr>
<td>Container</td>
<td>和已存在的运行的容器共享网络资源</td>
</tr>
</tbody></table>
<h5 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h5><p>该模式是docker的默认模式，它使用模拟网卡和模拟交换机实现。可以理解为将网卡分成两半即每个网卡都是成对出现的，一半在docker上，一半在软件模拟的交换机上(网卡名称一样)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模拟的虚拟交换机(有ip时也当作模拟网卡)，在物理机使用如下命令查看</span></span><br><span class="line"><span class="comment">#可以看出编号为3的docker0的设备即为虚拟交换机，编号为9的vethcf37621@if8的网卡设备为虚拟网卡，且该设备连接在docker0上</span></span><br><span class="line">ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:b1:56:1d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:6c:8a:31:24 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">9: vethcf37621@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 66:17:df:67:22:31 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    </span><br><span class="line"><span class="comment">#查看docker容器的虚拟网卡</span></span><br><span class="line"><span class="comment">#其中eth0@if9表示的就是上述vethcf37621@if8的另一半虚拟网卡，相当于连接到docker0上(类似于一根网线)</span></span><br><span class="line">ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>

<p>另外，在bridge模式下，不仅容器间可以正常通信(处于同一个虚拟交换机上)，容器也可以同外部主机进行通信。实现方法是通过iptables的nat规则实现SNAT，使用如下命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t NAT -vnL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 567 packets, 44852 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#上述条目标明从本机发出报文时，如果不是发往docker0网卡的且源地址为172.17网段的，都要做源地址转换，转换后与外界通信时使用的是物理机的网卡信息</span></span><br></pre></td></tr></table></figure>

<p>最后，既然本机的docker容器可以访问外网地址，那么外网地址是否可以访问本机呢，答案是肯定的。当本机启动一个进程后(监听在某个端口上)，这是会添加一条新的iptables规则，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行nginx的docker映射到本地80端口，前者为主机端口，后者为容器内端口，-d表示后台运行docker</span></span><br><span class="line">docker run -p 80:80 -d nginx</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">iptables -t nat -vnL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br><span class="line">    </span><br><span class="line"><span class="comment">#可以看出，任何以目标端口为80的请求都会做DNAT，将其地址改为172.17.0.2，因此可以实现通信</span></span><br><span class="line"><span class="comment">#也可以使用如下命令查看端口映射</span></span><br><span class="line">docker port c6849e28cea7</span><br></pre></td></tr></table></figure>

<h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>该模式下，docker和物理主机共用网络资源，换句话说没有对docker容器进行namespace的网络资源隔离。通信的话就直接使用物理网卡进行通信即可。</p>
<h5 id="None"><a href="#None" class="headerlink" title="None"></a>None</h5><p>不具有网络功能，主要用于实现一些计算等不用网络的docker容器。</p>
<h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><p>其实和host很像。但是该模式并不是没有隔离网络资源，而是仅设置为该模式的两个共享网络资源，即共享的是分配的namespace的网络资源，而host是共享的物理主机的资源，根本不存在namespace概念(单指网络，其他资源依旧隔离)。可以理解为一台主机上的两各进程间通信，但是有一定隔离。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示nginx容器和infracon容器使用Container模式网络</span></span><br><span class="line">docker run --name nginx --network container:infracon -it busybox</span><br></pre></td></tr></table></figure>

<h5 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建虚拟交换机mybr1</span></span><br><span class="line">docker network create -d bridge --subnet <span class="string">"192.163.10.0/24"</span> --gateway <span class="string">"192.168.10.1"</span> mybr1</span><br><span class="line"><span class="comment">#运行docker时加入自定义的mybr1</span></span><br><span class="line">docker run -it --network mybr1 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#若想要不同虚拟交换机之间的docker能够通信，只需要开启物理机的核心转发即可</span></span><br><span class="line"><span class="comment">#注意，iptables会添加很多规则，若想实验可以先保存规则再删掉</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<h5 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h5><p>此处使用ip netns命令模拟网络名称空间的设定。此处只是将Net的namespace隔离开，其他五个namespace资源全部共享。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加网络名称空间ns1和ns2</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"><span class="comment">#查看网络空间</span></span><br><span class="line">ip netns list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ns1和ns2内部的网卡，只能看到一个lo回环设备，无网卡</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig -a</span><br><span class="line"><span class="comment">#创建虚拟网卡对</span></span><br><span class="line">ip link add name veth1.1 <span class="built_in">type</span> veth peer name veth1.2</span><br><span class="line"><span class="comment">#查看创建的虚拟网卡对，可以从名字看出是成对的网卡</span></span><br><span class="line">ip link show</span><br><span class="line">24: veth1.2@veth1.1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 4e:20:59:46:17:81 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">25: veth1.1@veth1.2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether a2:a8:b7:cb:4d:8d brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment">#将成对的两个网卡分别移动到不同的netns中</span></span><br><span class="line">ip link <span class="built_in">set</span> dev veth1.2 netns ns1</span><br><span class="line">ip link <span class="built_in">set</span> dev veth1.1 netns ns2</span><br><span class="line"><span class="comment">#激活物理机网卡veth1</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ifconfig veth1.1 192.168.163.120/24 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig veth1.2 192.168.163.121/24 up</span><br></pre></td></tr></table></figure>

<h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><p>修改默认docker0桥地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改/etc/docker/daemon.json，只需要添加bip即可，其他会自动添加，多个项之间使用","隔开</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"bip"</span>: <span class="string">"192.168.163.2/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改docker服务器监听地址，默认是基于本机/var/run/docker.sock通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑/etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"hosts"</span>: [<span class="string">"tcp://0.0.0.0:2375"</span>,<span class="string">"unix:///var/run/docker.sock"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一台主机使用-H选项指明docker服务器地址</span></span><br><span class="line">docker -H IP_ADDR COMMANDS</span><br></pre></td></tr></table></figure>

<h4 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>docker镜像由多个只读层叠加而成，启动容器时docker会加载只读镜像层并在镜像层顶部添加一个读写层，用户所有的对镜像的写操作都在此层中生效。如果运行中的容器修改了一个已存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，这就是所谓的<strong>写时复制</strong>机制。另外，用户在读写层对文件进行删除操作时，只是相当于在该文件上做了删除标记，此后在读写层该文件对用户不可见，在只读层该文件依然存在。</p>
<p>由上可知，docker容器在关闭后全部更改都会丢失，因此会存在容器间数据共享不便、删除容器数据丢失、不利于分布式容器集群管理等问题。因此，为解决以上问题提出了<strong>卷</strong>的概念。实际上卷是容器上的一个或多个目录，此目录与物理机上的某个目录存在绑定关系，这样即使容器删除后，其数据依然存在本地，下次再启动容器时该数据依然存在。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>docker中有两种类型的卷，每种类型都在容器中存在一个挂载点，但其物理主机上的位置有所不同</p>
<ul>
<li>Bind mount volume：容器和物理机的目录都需要手动指定</li>
<li>Docker-managed volume：容器内的目录手动指定，物理机的目录由docker管理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker管理卷，指明容器内目录为/data</span></span><br><span class="line">docker run -it -v /data --name bbox1 busybox</span><br><span class="line"><span class="comment">#Bind挂载，指明物理机目录和容器内目录</span></span><br><span class="line">docker run -it -v HOSTDIR:VOLUMEDIR --name bbox2 busybox</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看挂载属性</span></span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox1</span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox2</span><br></pre></td></tr></table></figure>

<p>另外，可以实现用一个容器单独作为卷，其他容器绑定在该容器上。在实际使用中，使用一个专门做基础容器镜像的容器来代替此处自建的infracon，它只需要实现被其他容器关联即可，不需要启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx --network container:infracon --volumes-from infracon -it busybox</span><br></pre></td></tr></table></figure>

<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>前文创建镜像时提到过dockerfile，它是一个文本描述文件，其内包含了一条条指令来描述如何构建一个镜像文件。编写dockerfile时，需要创建一个目录将dockerfile文件放入该目录中，之后dockerfile内指令需要的所有文件都放到该目录或者该目录的子目录中。.dockerignore文件可以指定哪些文件不需要被build进镜像中。</p>
<p>不同的关键字定义不同的指令功能，dockerfile本身对字符大小写不敏感，但是一般关键字默认使用全大写。</p>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>FROM指令是dockerfile文件第一个非注释行，用于指明镜像文件的构建过程的基准镜像，后续的指令都运行于此基准镜像所提供的运行环境之上。默认情况下docker build时会在docker主机上查找指定的镜像文件，在其不存在时默认从docker hub上拉取镜像文件，也可以从指定的仓库拉取镜像文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line">	&lt;repository&gt;：基准镜像名称</span><br><span class="line">	&lt;tag&gt;：基准镜像的标签，默认为latest</span><br><span class="line"><span class="comment">#另外一种语法</span></span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt;</span><br><span class="line">	&lt;digest&gt;：指明基准镜像的<span class="built_in">hash</span>值</span><br></pre></td></tr></table></figure>

<h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><p>用来取代MAINTAINER关键字。它是用来为镜像添加元数据，如镜像名称、制作时间、作者等信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</span><br></pre></td></tr></table></figure>

<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>用于将dockerfile目录下的文件复制到镜像文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">	&lt;src&gt;：要复制的源文件或目录，支持使用通配符</span><br><span class="line">	&lt;dest&gt;：目标路径，即正在创建的镜像文件系统路径；建议为&lt;dest&gt;使用绝对路径，否则使用关键字WORKDIR指明的路径</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">COPY [<span class="string">"&lt;src&gt;"</span>...<span class="string">"&lt;dest&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">&lt;src&gt;必须是build上下文中的路径(即dockerfile文件所在的目录中的文件)，不能是其父目录中的文件</span><br><span class="line">如果&lt;src&gt;是目录，则其内部文件或子目录会被递归复制，但&lt;src&gt;目录自身不会被复制</span><br><span class="line">如果指定了多个&lt;src&gt;，或在&lt;src&gt;中使用通配符，则&lt;dest&gt;必须是一个目录且必须以/结尾指明是目录</span><br><span class="line">如果&lt;dest&gt;不存在，会自动创建(包括其父目录)</span><br></pre></td></tr></table></figure>

<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>与COPY类似，但是ADD支持tar文件打包和url文件联网下载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">ADD [<span class="string">"&lt;src&gt;"</span>...<span class="string">"&lt;dest&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">COPY有的特性ADD都有</span><br><span class="line">如果&lt;src&gt;为URL且&lt;dest&gt;不以/结尾，则&lt;src&gt;指定的文件将被下载并创建为&lt;dest&gt;；如果&lt;dest&gt;以/结尾，则保存至其目录下</span><br><span class="line">如果&lt;src&gt;是一个本地系统上的压缩格式的tar文件，其将会被展开成目录放在&lt;dest&gt;下；如果是网上下载的tar文件则不会展开</span><br></pre></td></tr></table></figure>

<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>用于为dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY、ADD指明工作目录，可以多次指定且只对该关键字后的指令有效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">WORKDIR &lt;dirpath&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">WORKDIR可以出现多次，若其为相对路径则是相对上一个WORKDIR的相对路径</span><br><span class="line">WORKDIR可以调用由ENV指定定义的变量</span><br></pre></td></tr></table></figure>

<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>用于在镜像中创建挂载卷，用来挂载物理主机或者其他容器的卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">VOLUME &lt;mountpoint&gt;</span><br><span class="line"><span class="comment">#另一种语法，用于路径中有空白字符</span></span><br><span class="line">VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">此处只能指定docker容器中的路径，不能手动指定物理主机的挂载路径，使用的是docker管理的挂载方式</span><br></pre></td></tr></table></figure>

<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>用于为容器打开指定要监听的端口以实现与外部通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">EXPOSE &lt;port&gt;[/&lt;protocol&gt;] [port][/&lt;protocol&gt;]...</span><br><span class="line">	&lt;protocol&gt;：指定传输层协议，默认为tcp协议</span><br><span class="line">	</span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">镜像并不会直接暴露出可暴露的端口，而是当run时使用-P选项才暴露所有设定的端口</span><br></pre></td></tr></table></figure>

<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>用于为镜像定义所需要的环境变量，并可被dockerfile文件中定义于其后的其他指令(如ENV、ADD、COPY等)调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法，一次只能设置一个变量</span></span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line"><span class="comment">#另一种语法，一次可以设置多个变量，多个变量可以使用\续行来定义</span></span><br><span class="line">ENV &lt;key&gt; &lt;value&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用格式</span></span><br><span class="line"><span class="variable">$var_name</span></span><br><span class="line"><span class="variable">$&#123;var_name&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>用于指定docker build过程中运行的程序，可以是多条命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">RUN &lt;<span class="built_in">command</span>&gt; &amp;&amp; &lt;<span class="built_in">command</span>&gt;...</span><br><span class="line"><span class="comment">#另一种语法</span></span><br><span class="line">RUN [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">RUN命令执行的一般是shell命令，其以<span class="string">"/bin/sh -c"</span>来执行这些命令</span><br><span class="line">定义多个RUN时会依次执行</span><br><span class="line">第一种语法格式默认使用shell来解释执行，因此其父进程为shell，则其id不为1，不能接收unix信号</span><br><span class="line">第二种语法格式默认使用内核<span class="built_in">exec</span>来执行，不支持shell特性如通配等，但可以接收unix信号，若想以shell执行可以使用如下命令</span><br><span class="line">RUN [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br></pre></td></tr></table></figure>

<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>类似于RUN，不过该关键字定义的命令运行在docker run过程中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">CMD &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment">#语法2</span></span><br><span class="line">CMD [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param&gt;"</span>]</span><br><span class="line"><span class="comment">#语法3</span></span><br><span class="line">CMD [<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">同RUN</span><br><span class="line">该指令运行于镜像启动为容器时默认要执行的命令，其执行结束后容器也会终止，可以被run选项覆盖</span><br><span class="line">在dockerfile中可以定义多条CMD，但仅最后一条会生效</span><br><span class="line">第三种语法格式用于为ENTRYPOINT指令提供默认参数</span><br></pre></td></tr></table></figure>

<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>类似于CMD指令的功能，用于为容器指定默认运行程序，从而使容器像一个单独的可执行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ENTRYPOINT &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment">#语法2</span></span><br><span class="line">ENTRYPOINT [<span class="string">"&lt;executable&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">同CMD</span><br><span class="line">一般的例如CMD命令，在run执行时可以自己使用命令替换掉，但是ENTRYPOTIN不行，自己后写的命令只会被当作它的参数来运行</span><br><span class="line">同时定义CMD和ENTRYPOINT时，CMD会被当作ENTRYPOINT的参数</span><br></pre></td></tr></table></figure>

<h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>用于指定运行镜像时或运行dockerfile种任何RUN、CMD、ENTRYPOINT等指令指定的程序时的用户名或UID。默认情况下，container的运行身份为root用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">USER &lt;UID&gt;|&lt;UserName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">指明的用户需要在/etc/passwd中有该用户的信息</span><br><span class="line">root用户不需要上述条件，因为root用户属于内核</span><br></pre></td></tr></table></figure>

<h5 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h5><p>用于检查容器工作是否正常</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法，运行脚本检查</span></span><br><span class="line">HEALTHCHECK [options] CMD <span class="built_in">command</span></span><br><span class="line">	options：</span><br><span class="line">		--interval=DUARATION	<span class="comment">#间隔时间，默认30s</span></span><br><span class="line">		--timeout=DURATION		<span class="comment">#超时时长，默认30s</span></span><br><span class="line">		--start-period=DURATION	<span class="comment">#run之后等待主进程启动的时间，默认0s</span></span><br><span class="line">		--retries=N				<span class="comment">#检查次数，默认3次</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">#健康检测状态返回值</span></span><br><span class="line">0：表示容器健康</span><br><span class="line">1：表示不健康</span><br><span class="line">2：保留位，暂不使用</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">通常健康检测时使用CMD配合命令检测，最后加个||<span class="built_in">exit</span> 1即可，如果正常则不会执行<span class="built_in">exit</span> 1，如果不正常会执行<span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>

<h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><p> 用于定义默认的shell环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">SHELL [<span class="string">"executable"</span>,<span class="string">"parameters"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">默认linux为：</span><br><span class="line">SHELL [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>]</span><br><span class="line">默认windows为：</span><br><span class="line">SHELL [<span class="string">"cmd"</span>,<span class="string">"/S"</span>,<span class="string">"/C"</span>]</span><br></pre></td></tr></table></figure>

<h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>用于定义变量，但指令只在build过程使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">可以在build时使用--build-arg &lt;varname&gt;=&lt;value&gt;来设置</span><br></pre></td></tr></table></figure>

<h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>用于在dockerfile中定义一个触发器，当该镜像文件被别人作为基础镜像文件时会执行该指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法</span></span><br><span class="line">ONBUILD &lt;INSTRUCTION&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">ONBUILD不能自我嵌套</span><br><span class="line">ONBUILD中最好不要使用ADD或COPY指令，因为无法判断另一个制作镜像的人是否有指定的文件路径</span><br></pre></td></tr></table></figure>

<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>实现nginx配置</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">ENV</span> NGX_DOC_ROOT=<span class="string">'/data/web/html/'</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> entrypoint.sh /bin/</span></span><br><span class="line"><span class="comment">#-g表示运行在前台，daemon off表示不使用守护进程运行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/sbin/nginx"</span>,<span class="string">"-g"</span>,<span class="string">"daemon off;"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/entrypoint.sh"</span>]</span></span><br><span class="line"><span class="comment">#上面两个组合起来相当于执行 /bin/entrypoint.sh /usr/sbin/nginx -g daemon off</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#entrypoint.sh</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cat &gt; /etc/nginx/conf.d/www.conf &lt;&lt; EOF</span><br><span class="line">server &#123;</span><br><span class="line">	server_name $&#123;HOSTNAME&#125;;</span><br><span class="line">	listen $&#123;IP:-<span class="number">0.0</span>.<span class="number">0.0</span>&#125;:$&#123;PORT:-<span class="number">80</span>&#125;;</span><br><span class="line">	root $&#123;NGX_DOC_ROOT:-/usr/share/nginx/html&#125;;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#由于CMD定义的变成该脚本的参数，执行此命令就是将参数当作命令执行，从而使得nginx变成id为1的进程</span></span><br><span class="line">exec <span class="string">"$@"</span></span><br></pre></td></tr></table></figure>

<h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可以自建Registry，也可以使用默认的Dockers hub</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>Sponsor Register：第三方Registry，共客户和docker社区使用</li>
<li>Mirror Registry：第三方Registry，只让客户使用</li>
<li>Vendor Registry：由发布docker镜像的供应商提供的Registry</li>
<li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供Registry</li>
</ul>
<h5 id="搭建私有Registry"><a href="#搭建私有Registry" class="headerlink" title="搭建私有Registry"></a>搭建私有Registry</h5><p>此处使用harbor来搭建私有Registry，它有良好的UI界面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装docker-compose，这是一个用于单机管理和运行多个docker容器的工具</span></span><br><span class="line">yum install -y docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处省略harbor下载和解压缩，一般将其解压缩到/usr/local/下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置harbor.conf</span></span><br><span class="line"><span class="comment">#设置ip或主机名</span></span><br><span class="line">hostname = 192.168.163.132</span><br><span class="line"><span class="comment">#访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置on</span></span><br><span class="line">ui_url_protocol = http</span><br><span class="line"><span class="comment">#设置最大子进程数，一般小于等于cpu物理核心数</span></span><br><span class="line">max_job_workers = 3</span><br><span class="line"><span class="comment">#设置管理密码</span></span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"><span class="comment">#配置相关数据库</span></span><br><span class="line">db_password = root123</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line">本地搭建的私有Registry后会不允许你上传和下载操作，因为docker默认使用https协议，即使你私建CA也无法获取docker信任，因此在此处让docker忽略https安全选项，在/etc/docker/daemon.json中定义即可</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"insecure-registries"</span>: [<span class="string">"10.0.86.193"</span>]</span><br><span class="line">&#125;</span><br><span class="line">另外，如果需要远程登录docker服务器，那么还需要指定在unit file中的ExecStart处添加 –insecure-registry</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装，实际就是根据脚本执行docker-compose命令，命令配置文件就是docker-compose.yml</span></span><br><span class="line">./install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动|停止服务</span></span><br><span class="line">docker-compose start|stop</span><br></pre></td></tr></table></figure>

<h4 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h4><p>默认docker不限制资源的使用，即docker可以使用物理机的所有资源。</p>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m：限制容器可用最大物理内存大小</span><br><span class="line"><span class="comment">#注意，在容器中使用free命令不是真的swap空间大小</span></span><br><span class="line">--memory-swap：容器可以与磁盘交互的大小，但算法比较特殊，它的数值不代表真的swap大小</span><br><span class="line">--oom-kill-disable：设置<span class="literal">true</span>时表示禁止被OOM机制(内存不足)杀死</span><br><span class="line">--memory-swapiness：设置使用swap的倾向性，0~100，0表示能不用就不用(不是禁用)，100表示能用就用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>–memory-swap</th>
<th>–memory/-m</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>正数S</td>
<td>整数M</td>
<td>总大小为S，swap为S-M，物理内存为M</td>
</tr>
<tr>
<td>0</td>
<td>整数M</td>
<td>相当于未设置swap</td>
</tr>
<tr>
<td>unset</td>
<td>整数M</td>
<td>若主机(docker host)启用了swap，则容器可用swap=2*M</td>
</tr>
<tr>
<td>-1</td>
<td>整数M</td>
<td>同上，容器可使用最大至主机上的所有swap空间的swap资源</td>
</tr>
</tbody></table>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cpu-shares：指定cpu分配比率</span><br><span class="line">--cpu=&lt;value&gt;：指明cpu核心数使用，可以为小数</span><br></pre></td></tr></table></figure>

<h5 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h5><p>压测一般使用镜像来测试，在docker hub上搜索stress找一个即可，此处不进行演示。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"># docker</a>
              <a href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag"># 容器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/26/zabbix%E8%AF%A6%E8%A7%A3/" rel="prev" title="zabbix详解">
      <i class="fa fa-chevron-left"></i> zabbix详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/30/k8s-1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%83%A8%E7%BD%B2/" rel="next" title="k8s(1)-基本架构及部署">
      k8s(1)-基本架构及部署 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟化"><span class="nav-number">1.</span> <span class="nav-text">虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#软件辅助全虚拟化"><span class="nav-number">1.1.</span> <span class="nav-text">软件辅助全虚拟化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件辅助全虚拟化"><span class="nav-number">1.2.</span> <span class="nav-text">硬件辅助全虚拟化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Namespaces"><span class="nav-number">2.1.</span> <span class="nav-text">Namespaces</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cgroup"><span class="nav-number">2.2.</span> <span class="nav-text">Cgroup</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker"><span class="nav-number">3.</span> <span class="nav-text">docker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装"><span class="nav-number">3.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置"><span class="nav-number">3.2.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令"><span class="nav-number">3.3.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#image"><span class="nav-number">3.3.1.</span> <span class="nav-text">image</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#container"><span class="nav-number">3.3.2.</span> <span class="nav-text">container</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#镜像"><span class="nav-number">3.4.</span> <span class="nav-text">镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组织结构"><span class="nav-number">3.4.1.</span> <span class="nav-text">组织结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#制作镜像"><span class="nav-number">3.4.2.</span> <span class="nav-text">制作镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#推送镜像"><span class="nav-number">3.4.3.</span> <span class="nav-text">推送镜像</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络"><span class="nav-number">3.5.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bridge"><span class="nav-number">3.5.1.</span> <span class="nav-text">Bridge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Host"><span class="nav-number">3.5.2.</span> <span class="nav-text">Host</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#None"><span class="nav-number">3.5.3.</span> <span class="nav-text">None</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Container"><span class="nav-number">3.5.4.</span> <span class="nav-text">Container</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义"><span class="nav-number">3.5.5.</span> <span class="nav-text">自定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置实例"><span class="nav-number">3.5.6.</span> <span class="nav-text">配置实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他配置"><span class="nav-number">3.5.7.</span> <span class="nav-text">其他配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储卷"><span class="nav-number">3.6.</span> <span class="nav-text">存储卷</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念"><span class="nav-number">3.6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型"><span class="nav-number">3.6.2.</span> <span class="nav-text">类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dockerfile"><span class="nav-number">3.7.</span> <span class="nav-text">Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FROM"><span class="nav-number">3.7.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LABEL"><span class="nav-number">3.7.2.</span> <span class="nav-text">LABEL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#COPY"><span class="nav-number">3.7.3.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ADD"><span class="nav-number">3.7.4.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WORKDIR"><span class="nav-number">3.7.5.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VOLUME"><span class="nav-number">3.7.6.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EXPOSE"><span class="nav-number">3.7.7.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ENV"><span class="nav-number">3.7.8.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RUN"><span class="nav-number">3.7.9.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMD"><span class="nav-number">3.7.10.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">3.7.11.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#USER"><span class="nav-number">3.7.12.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">3.7.13.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SHELL"><span class="nav-number">3.7.14.</span> <span class="nav-text">SHELL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARG"><span class="nav-number">3.7.15.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ONBUILD"><span class="nav-number">3.7.16.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例"><span class="nav-number">3.7.17.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Registry"><span class="nav-number">3.8.</span> <span class="nav-text">Registry</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分类"><span class="nav-number">3.8.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#搭建私有Registry"><span class="nav-number">3.8.2.</span> <span class="nav-text">搭建私有Registry</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源限制"><span class="nav-number">3.9.</span> <span class="nav-text">资源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存"><span class="nav-number">3.9.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU"><span class="nav-number">3.9.2.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#压测"><span class="nav-number">3.9.3.</span> <span class="nav-text">压测</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Frdqy"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Frdqy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DQYXACML" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DQYXACML" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1259178786@qq.com" title="E-Mail → mailto:1259178786@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://cenlg00bug.xyz/" title="http:&#x2F;&#x2F;cenlg00bug.xyz&#x2F;" rel="noopener" target="_blank">CENLG</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://mi0.xyz/" title="http:&#x2F;&#x2F;mi0.xyz&#x2F;" rel="noopener" target="_blank">Web安全</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frdqy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
